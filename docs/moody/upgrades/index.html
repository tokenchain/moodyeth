<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>moody.upgrades API documentation</title>
<meta name="description" content="Generated wrapper for Timelock6h Solidity contract." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>moody.upgrades</code></h1>
</header>
<section id="section-intro">
<p>Generated wrapper for Timelock6h Solidity contract.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Generated wrapper for Timelock6h Solidity contract.&#34;&#34;&#34;

# pylint: disable=too-many-arguments

import json
import time
from typing import (  # pylint: disable=unused-import
    Optional,
    Tuple,
    Union,
)

from eth_utils import to_checksum_address
from hexbytes import HexBytes
from web3.contract import ContractFunction
from web3.datastructures import AttributeDict
from web3.exceptions import ContractLogicError

from moody import Bolors
from moody.libeb import MiliDoS
from moody.m.bases import ContractMethod, Validator, ContractBase
from moody.m.tx_params import TxParams

# Try to import a custom validator class definition; if there isn&#39;t one,
# declare one that we can instantiate for the default argument to the
# constructor for Timelock6h below.
try:
    # both mypy and pylint complain about what we&#39;re doing here, but this
    # works just fine, so their messages have been disabled here.
    from . import (  # type: ignore # pylint: disable=import-self
        Timelock6hValidator,
    )
except ImportError:

    class Timelock6hValidator(  # type: ignore
        Validator
    ):
        &#34;&#34;&#34;No-op input validator.&#34;&#34;&#34;

try:
    from .middleware import MIDDLEWARE  # type: ignore
except ImportError:
    pass


class GracePeriodMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the GRACE_PERIOD method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address)
        self._underlying_method = contract_function

    def block_call(self, debug: bool = False) -&gt; int:
        _fn = self._underlying_method()
        returned = _fn.call({
            &#39;from&#39;: self._operate
        })
        return int(returned)

    def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().estimateGas(tx_params.as_dict())


class MaximumDelayMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the MAXIMUM_DELAY method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address)
        self._underlying_method = contract_function

    def block_call(self, debug: bool = False) -&gt; int:
        _fn = self._underlying_method()
        returned = _fn.call({
            &#39;from&#39;: self._operate
        })
        return int(returned)

    def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().estimateGas(tx_params.as_dict())


class MinimumDelayMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the MINIMUM_DELAY method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address)
        self._underlying_method = contract_function

    def block_call(self, debug: bool = False) -&gt; int:
        _fn = self._underlying_method()
        returned = _fn.call({
            &#39;from&#39;: self._operate
        })
        return int(returned)

    def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().estimateGas(tx_params.as_dict())


class AcceptAdminMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the acceptAdmin method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address)
        self._underlying_method = contract_function

    def block_send(self, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; None:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        _fn = self._underlying_method()
        try:

            _t = _fn.buildTransaction({
                &#39;from&#39;: self._operate,
                &#39;gas&#39;: gas,
                &#39;gasPrice&#39;: price
            })
            _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

            if val &gt; 0:
                _t[&#39;value&#39;] = val

            if debug:
                print(f&#34;======== Signing ✅ by {self._operate}&#34;)
                print(f&#34;======== Transaction ✅ check&#34;)
                print(_t)

            if &#39;data&#39; in _t:

                signed = self._web3_eth.account.sign_transaction(_t)
                txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
                tx_receipt = None
                if receiptListen is True:
                    print(&#34;======== awaiting Confirmation 🚸️ -accept_admin&#34;)
                    tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                    if debug:
                        print(&#34;======== TX Result ✅&#34;)
                        print(tx_receipt)

                print(f&#34;======== TX blockHash ✅&#34;)
                if receiptListen is True and tx_receipt is not None:
                    print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
                else:
                    print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

            if receiptListen is False:
                time.sleep(self._wait)


        except ContractLogicError as er:
            print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: accept_admin&#34;)

        except ValueError as err:
            if &#34;message&#34; in err.args[0]:
                message = err.args[0][&#34;message&#34;]
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
            else:
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)

    def send_transaction(self, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().transact(tx_params.as_dict())

    def build_transaction(self, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().buildTransaction(tx_params.as_dict())

    def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().estimateGas(tx_params.as_dict())


class AdminMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the admin method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address)
        self._underlying_method = contract_function

    def block_call(self, debug: bool = False) -&gt; str:
        _fn = self._underlying_method()
        returned = _fn.call({
            &#39;from&#39;: self._operate
        })
        return str(returned)

    def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().estimateGas(tx_params.as_dict())


class CancelTransactionMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the cancelTransaction method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction, validator: Validator = None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) -&gt; any:
        &#34;&#34;&#34;Validate the inputs to the cancelTransaction method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;cancelTransaction&#39;,
            parameter_name=&#39;target&#39;,
            argument_value=target,
        )
        target = self.validate_and_checksum_address(target)
        self.validator.assert_valid(
            method_name=&#39;cancelTransaction&#39;,
            parameter_name=&#39;value&#39;,
            argument_value=value,
        )
        # safeguard against fractional inputs
        value = int(value)
        self.validator.assert_valid(
            method_name=&#39;cancelTransaction&#39;,
            parameter_name=&#39;signature&#39;,
            argument_value=signature,
        )
        self.validator.assert_valid(
            method_name=&#39;cancelTransaction&#39;,
            parameter_name=&#39;data&#39;,
            argument_value=data,
        )
        self.validator.assert_valid(
            method_name=&#39;cancelTransaction&#39;,
            parameter_name=&#39;eta&#39;,
            argument_value=eta,
        )
        # safeguard against fractional inputs
        eta = int(eta)
        return (target, value, signature, data, eta)

    def block_send(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; None:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        _fn = self._underlying_method(target, value, signature, data, eta)
        try:

            _t = _fn.buildTransaction({
                &#39;from&#39;: self._operate,
                &#39;gas&#39;: gas,
                &#39;gasPrice&#39;: price
            })
            _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

            if val &gt; 0:
                _t[&#39;value&#39;] = val

            if debug:
                print(f&#34;======== Signing ✅ by {self._operate}&#34;)
                print(f&#34;======== Transaction ✅ check&#34;)
                print(_t)

            if &#39;data&#39; in _t:

                signed = self._web3_eth.account.sign_transaction(_t)
                txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
                tx_receipt = None
                if receiptListen is True:
                    print(&#34;======== awaiting Confirmation 🚸️ -cancel_transaction&#34;)
                    tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                    if debug:
                        print(&#34;======== TX Result ✅&#34;)
                        print(tx_receipt)

                print(f&#34;======== TX blockHash ✅&#34;)
                if receiptListen is True and tx_receipt is not None:
                    print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
                else:
                    print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

            if receiptListen is False:
                time.sleep(self._wait)


        except ContractLogicError as er:
            print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: cancel_transaction&#34;)

        except ValueError as err:
            if &#34;message&#34; in err.args[0]:
                message = err.args[0][&#34;message&#34;]
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
            else:
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)

    def send_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).transact(tx_params.as_dict())

    def build_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).estimateGas(tx_params.as_dict())


class DelayMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the delay method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address)
        self._underlying_method = contract_function

    def block_call(self, debug: bool = False) -&gt; int:
        _fn = self._underlying_method()
        returned = _fn.call({
            &#39;from&#39;: self._operate
        })
        return int(returned)

    def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().estimateGas(tx_params.as_dict())


class ExecuteTransactionMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the executeTransaction method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction, validator: Validator = None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) -&gt; any:
        &#34;&#34;&#34;Validate the inputs to the executeTransaction method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;executeTransaction&#39;,
            parameter_name=&#39;target&#39;,
            argument_value=target,
        )
        target = self.validate_and_checksum_address(target)
        self.validator.assert_valid(
            method_name=&#39;executeTransaction&#39;,
            parameter_name=&#39;value&#39;,
            argument_value=value,
        )
        # safeguard against fractional inputs
        value = int(value)
        self.validator.assert_valid(
            method_name=&#39;executeTransaction&#39;,
            parameter_name=&#39;signature&#39;,
            argument_value=signature,
        )
        self.validator.assert_valid(
            method_name=&#39;executeTransaction&#39;,
            parameter_name=&#39;data&#39;,
            argument_value=data,
        )
        self.validator.assert_valid(
            method_name=&#39;executeTransaction&#39;,
            parameter_name=&#39;eta&#39;,
            argument_value=eta,
        )
        # safeguard against fractional inputs
        eta = int(eta)
        return (target, value, signature, data, eta)

    def block_send(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; Union[bytes, str]:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        _fn = self._underlying_method(target, value, signature, data, eta)
        try:

            _t = _fn.buildTransaction({
                &#39;from&#39;: self._operate,
                &#39;gas&#39;: gas,
                &#39;gasPrice&#39;: price
            })
            _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

            if val &gt; 0:
                _t[&#39;value&#39;] = val

            if debug:
                print(f&#34;======== Signing ✅ by {self._operate}&#34;)
                print(f&#34;======== Transaction ✅ check&#34;)
                print(_t)

            if &#39;data&#39; in _t:

                signed = self._web3_eth.account.sign_transaction(_t)
                txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
                tx_receipt = None
                if receiptListen is True:
                    print(&#34;======== awaiting Confirmation 🚸️ -execute_transaction&#34;)
                    tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                    if debug:
                        print(&#34;======== TX Result ✅&#34;)
                        print(tx_receipt)

                print(f&#34;======== TX blockHash ✅&#34;)
                if receiptListen is True and tx_receipt is not None:
                    print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
                else:
                    print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

            if receiptListen is False:
                time.sleep(self._wait)


        except ContractLogicError as er:
            print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: execute_transaction&#34;)

        except ValueError as err:
            if &#34;message&#34; in err.args[0]:
                message = err.args[0][&#34;message&#34;]
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
            else:
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)

    def send_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).transact(tx_params.as_dict())

    def build_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).estimateGas(tx_params.as_dict())


class PendingAdminMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the pendingAdmin method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address)
        self._underlying_method = contract_function

    def block_call(self, debug: bool = False) -&gt; str:
        _fn = self._underlying_method()
        returned = _fn.call({
            &#39;from&#39;: self._operate
        })
        return str(returned)

    def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().estimateGas(tx_params.as_dict())


class QueueTransactionMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the queueTransaction method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction, validator: Validator = None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) -&gt; any:
        &#34;&#34;&#34;Validate the inputs to the queueTransaction method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;queueTransaction&#39;,
            parameter_name=&#39;target&#39;,
            argument_value=target,
        )
        target = self.validate_and_checksum_address(target)
        self.validator.assert_valid(
            method_name=&#39;queueTransaction&#39;,
            parameter_name=&#39;value&#39;,
            argument_value=value,
        )
        # safeguard against fractional inputs
        value = int(value)
        self.validator.assert_valid(
            method_name=&#39;queueTransaction&#39;,
            parameter_name=&#39;signature&#39;,
            argument_value=signature,
        )
        self.validator.assert_valid(
            method_name=&#39;queueTransaction&#39;,
            parameter_name=&#39;data&#39;,
            argument_value=data,
        )
        self.validator.assert_valid(
            method_name=&#39;queueTransaction&#39;,
            parameter_name=&#39;eta&#39;,
            argument_value=eta,
        )
        # safeguard against fractional inputs
        eta = int(eta)
        return (target, value, signature, data, eta)

    def block_send(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; Union[bytes, str]:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        _fn = self._underlying_method(target, value, signature, data, eta)
        try:

            _t = _fn.buildTransaction({
                &#39;from&#39;: self._operate,
                &#39;gas&#39;: gas,
                &#39;gasPrice&#39;: price
            })
            _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

            if val &gt; 0:
                _t[&#39;value&#39;] = val

            if debug:
                print(f&#34;======== Signing ✅ by {self._operate}&#34;)
                print(f&#34;======== Transaction ✅ check&#34;)
                print(_t)

            if &#39;data&#39; in _t:

                signed = self._web3_eth.account.sign_transaction(_t)
                txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
                tx_receipt = None
                if receiptListen is True:
                    print(&#34;======== awaiting Confirmation 🚸️ -queue_transaction&#34;)
                    tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                    if debug:
                        print(&#34;======== TX Result ✅&#34;)
                        print(tx_receipt)

                print(f&#34;======== TX blockHash ✅&#34;)
                if receiptListen is True and tx_receipt is not None:
                    print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
                else:
                    print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

            if receiptListen is False:
                time.sleep(self._wait)


        except ContractLogicError as er:
            print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: queue_transaction&#34;)

        except ValueError as err:
            if &#34;message&#34; in err.args[0]:
                message = err.args[0][&#34;message&#34;]
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
            else:
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)

    def send_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).transact(tx_params.as_dict())

    def build_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).estimateGas(tx_params.as_dict())


class QueuedTransactionsMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the queuedTransactions method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction, validator: Validator = None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, index_0: Union[bytes, str]) -&gt; any:
        &#34;&#34;&#34;Validate the inputs to the queuedTransactions method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;queuedTransactions&#39;,
            parameter_name=&#39;index_0&#39;,
            argument_value=index_0,
        )
        return (index_0)

    def block_call(self, index_0: Union[bytes, str], debug: bool = False) -&gt; bool:
        _fn = self._underlying_method(index_0)
        returned = _fn.call({
            &#39;from&#39;: self._operate
        })
        return bool(returned)

    def estimate_gas(self, index_0: Union[bytes, str], tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (index_0) = self.validate_and_normalize_inputs(index_0)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(index_0).estimateGas(tx_params.as_dict())


class SetDelayMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the setDelay method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction, validator: Validator = None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, delay_: int) -&gt; any:
        &#34;&#34;&#34;Validate the inputs to the setDelay method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;setDelay&#39;,
            parameter_name=&#39;delay_&#39;,
            argument_value=delay_,
        )
        # safeguard against fractional inputs
        delay_ = int(delay_)
        return (delay_)

    def block_send(self, delay_: int, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; None:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        _fn = self._underlying_method(delay_)
        try:

            _t = _fn.buildTransaction({
                &#39;from&#39;: self._operate,
                &#39;gas&#39;: gas,
                &#39;gasPrice&#39;: price
            })
            _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

            if val &gt; 0:
                _t[&#39;value&#39;] = val

            if debug:
                print(f&#34;======== Signing ✅ by {self._operate}&#34;)
                print(f&#34;======== Transaction ✅ check&#34;)
                print(_t)

            if &#39;data&#39; in _t:

                signed = self._web3_eth.account.sign_transaction(_t)
                txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
                tx_receipt = None
                if receiptListen is True:
                    print(&#34;======== awaiting Confirmation 🚸️ -set_delay&#34;)
                    tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                    if debug:
                        print(&#34;======== TX Result ✅&#34;)
                        print(tx_receipt)

                print(f&#34;======== TX blockHash ✅&#34;)
                if receiptListen is True and tx_receipt is not None:
                    print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
                else:
                    print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

            if receiptListen is False:
                time.sleep(self._wait)


        except ContractLogicError as er:
            print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: set_delay&#34;)

        except ValueError as err:
            if &#34;message&#34; in err.args[0]:
                message = err.args[0][&#34;message&#34;]
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
            else:
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)

    def send_transaction(self, delay_: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (delay_) = self.validate_and_normalize_inputs(delay_)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(delay_).transact(tx_params.as_dict())

    def build_transaction(self, delay_: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (delay_) = self.validate_and_normalize_inputs(delay_)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(delay_).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, delay_: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (delay_) = self.validate_and_normalize_inputs(delay_)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(delay_).estimateGas(tx_params.as_dict())


class SetPendingAdminMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the setPendingAdmin method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction, validator: Validator = None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, pending_admin_: str) -&gt; any:
        &#34;&#34;&#34;Validate the inputs to the setPendingAdmin method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;setPendingAdmin&#39;,
            parameter_name=&#39;pendingAdmin_&#39;,
            argument_value=pending_admin_,
        )
        pending_admin_ = self.validate_and_checksum_address(pending_admin_)
        return (pending_admin_)

    def block_send(self, pending_admin_: str, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; None:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        _fn = self._underlying_method(pending_admin_)
        try:

            _t = _fn.buildTransaction({
                &#39;from&#39;: self._operate,
                &#39;gas&#39;: gas,
                &#39;gasPrice&#39;: price
            })
            _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

            if val &gt; 0:
                _t[&#39;value&#39;] = val

            if debug:
                print(f&#34;======== Signing ✅ by {self._operate}&#34;)
                print(f&#34;======== Transaction ✅ check&#34;)
                print(_t)

            if &#39;data&#39; in _t:

                signed = self._web3_eth.account.sign_transaction(_t)
                txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
                tx_receipt = None
                if receiptListen is True:
                    print(&#34;======== awaiting Confirmation 🚸️ -set_pending_admin&#34;)
                    tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                    if debug:
                        print(&#34;======== TX Result ✅&#34;)
                        print(tx_receipt)

                print(f&#34;======== TX blockHash ✅&#34;)
                if receiptListen is True and tx_receipt is not None:
                    print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
                else:
                    print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

            if receiptListen is False:
                time.sleep(self._wait)


        except ContractLogicError as er:
            print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: set_pending_admin&#34;)

        except ValueError as err:
            if &#34;message&#34; in err.args[0]:
                message = err.args[0][&#34;message&#34;]
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
            else:
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)

    def send_transaction(self, pending_admin_: str, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (pending_admin_) = self.validate_and_normalize_inputs(pending_admin_)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(pending_admin_).transact(tx_params.as_dict())

    def build_transaction(self, pending_admin_: str, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (pending_admin_) = self.validate_and_normalize_inputs(pending_admin_)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(pending_admin_).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, pending_admin_: str, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (pending_admin_) = self.validate_and_normalize_inputs(pending_admin_)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(pending_admin_).estimateGas(tx_params.as_dict())


class SignatureGenerator:
    _function_signatures = {}

    def __init__(self, abi: any):
        for func in [obj for obj in abi if obj[&#39;type&#39;] == &#39;function&#39;]:
            name = func[&#39;name&#39;]
            types = [input[&#39;type&#39;] for input in func[&#39;inputs&#39;]]
            self._function_signatures[name] = &#39;{}({})&#39;.format(name, &#39;,&#39;.join(types))

    def grace_period(self) -&gt; str:
        return self._function_signatures[&#34;GRACE_PERIOD&#34;]

    def maximum_delay(self) -&gt; str:
        return self._function_signatures[&#34;MAXIMUM_DELAY&#34;]

    def minimum_delay(self) -&gt; str:
        return self._function_signatures[&#34;MINIMUM_DELAY&#34;]

    def accept_admin(self) -&gt; str:
        return self._function_signatures[&#34;acceptAdmin&#34;]

    def admin(self) -&gt; str:
        return self._function_signatures[&#34;admin&#34;]

    def cancel_transaction(self) -&gt; str:
        return self._function_signatures[&#34;cancelTransaction&#34;]

    def delay(self) -&gt; str:
        return self._function_signatures[&#34;delay&#34;]

    def execute_transaction(self) -&gt; str:
        return self._function_signatures[&#34;executeTransaction&#34;]

    def pending_admin(self) -&gt; str:
        return self._function_signatures[&#34;pendingAdmin&#34;]

    def queue_transaction(self) -&gt; str:
        return self._function_signatures[&#34;queueTransaction&#34;]

    def queued_transactions(self) -&gt; str:
        return self._function_signatures[&#34;queuedTransactions&#34;]

    def set_delay(self) -&gt; str:
        return self._function_signatures[&#34;setDelay&#34;]

    def set_pending_admin(self) -&gt; str:
        return self._function_signatures[&#34;setPendingAdmin&#34;]


# pylint: disable=too-many-public-methods,too-many-instance-attributes
class Timelock6h(ContractBase):
    &#34;&#34;&#34;Wrapper class for Timelock6h Solidity contract.

    All method parameters of type `bytes`:code: should be encoded as UTF-8,
    which can be accomplished via `str.encode(&#34;utf_8&#34;)`:code:.
    &#34;&#34;&#34;
    _fn_grace_period: GracePeriodMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`GracePeriodMethod`.
    &#34;&#34;&#34;

    _fn_maximum_delay: MaximumDelayMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`MaximumDelayMethod`.
    &#34;&#34;&#34;

    _fn_minimum_delay: MinimumDelayMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`MinimumDelayMethod`.
    &#34;&#34;&#34;

    _fn_accept_admin: AcceptAdminMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`AcceptAdminMethod`.
    &#34;&#34;&#34;

    _fn_admin: AdminMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`AdminMethod`.
    &#34;&#34;&#34;

    _fn_cancel_transaction: CancelTransactionMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`CancelTransactionMethod`.
    &#34;&#34;&#34;

    _fn_delay: DelayMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`DelayMethod`.
    &#34;&#34;&#34;

    _fn_execute_transaction: ExecuteTransactionMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`ExecuteTransactionMethod`.
    &#34;&#34;&#34;

    _fn_pending_admin: PendingAdminMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`PendingAdminMethod`.
    &#34;&#34;&#34;

    _fn_queue_transaction: QueueTransactionMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`QueueTransactionMethod`.
    &#34;&#34;&#34;

    _fn_queued_transactions: QueuedTransactionsMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`QueuedTransactionsMethod`.
    &#34;&#34;&#34;

    _fn_set_delay: SetDelayMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`SetDelayMethod`.
    &#34;&#34;&#34;

    _fn_set_pending_admin: SetPendingAdminMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`SetPendingAdminMethod`.
    &#34;&#34;&#34;

    def __init__(
            self,
            core_lib: MiliDoS,
            contract_address: str,
            validator: Timelock6hValidator = None,
    ):
        &#34;&#34;&#34;Get an instance of wrapper for smart contract.
        &#34;&#34;&#34;
        # pylint: disable=too-many-statements
        super().__init__()
        self.contract_address = contract_address
        web3 = core_lib.w3

        if not validator:
            validator = Timelock6hValidator(web3, contract_address)

        # if any middleware was imported, inject it
        try:
            MIDDLEWARE
        except NameError:
            pass
        else:
            try:
                for middleware in MIDDLEWARE:
                    web3.middleware_onion.inject(
                        middleware[&#39;function&#39;], layer=middleware[&#39;layer&#39;],
                    )
            except ValueError as value_error:
                if value_error.args == (&#34;You can&#39;t add the same un-named instance twice&#34;,):
                    pass

        self._web3_eth = web3.eth

        functions = self._web3_eth.contract(address=to_checksum_address(contract_address), abi=Timelock6h.abi()).functions
        self.SIGNATURES = SignatureGenerator(Timelock6h.abi())
        self._fn_grace_period = GracePeriodMethod(core_lib, contract_address, functions.GRACE_PERIOD)

        self._fn_maximum_delay = MaximumDelayMethod(core_lib, contract_address, functions.MAXIMUM_DELAY)

        self._fn_minimum_delay = MinimumDelayMethod(core_lib, contract_address, functions.MINIMUM_DELAY)

        self._fn_accept_admin = AcceptAdminMethod(core_lib, contract_address, functions.acceptAdmin)

        self._fn_admin = AdminMethod(core_lib, contract_address, functions.admin)

        self._fn_cancel_transaction = CancelTransactionMethod(core_lib, contract_address, functions.cancelTransaction, validator)

        self._fn_delay = DelayMethod(core_lib, contract_address, functions.delay)

        self._fn_execute_transaction = ExecuteTransactionMethod(core_lib, contract_address, functions.executeTransaction, validator)

        self._fn_pending_admin = PendingAdminMethod(core_lib, contract_address, functions.pendingAdmin)

        self._fn_queue_transaction = QueueTransactionMethod(core_lib, contract_address, functions.queueTransaction, validator)

        self._fn_queued_transactions = QueuedTransactionsMethod(core_lib, contract_address, functions.queuedTransactions, validator)

        self._fn_set_delay = SetDelayMethod(core_lib, contract_address, functions.setDelay, validator)

        self._fn_set_pending_admin = SetPendingAdminMethod(core_lib, contract_address, functions.setPendingAdmin, validator)

    def event_cancel_transaction(
            self, tx_hash: Union[HexBytes, bytes]
    ) -&gt; Tuple[AttributeDict]:
        &#34;&#34;&#34;
        Implementation of event cancel_transaction in contract Timelock6h
        Get log entry for CancelTransaction event.
                :param tx_hash: hash of transaction emitting CancelTransaction event
        &#34;&#34;&#34;
        tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
        return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.CancelTransaction().processReceipt(tx_receipt)

    def event_execute_transaction(
            self, tx_hash: Union[HexBytes, bytes]
    ) -&gt; Tuple[AttributeDict]:
        &#34;&#34;&#34;
        Implementation of event execute_transaction in contract Timelock6h
        Get log entry for ExecuteTransaction event.
                :param tx_hash: hash of transaction emitting ExecuteTransaction event
        &#34;&#34;&#34;
        tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
        return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.ExecuteTransaction().processReceipt(tx_receipt)

    def event_new_admin(
            self, tx_hash: Union[HexBytes, bytes]
    ) -&gt; Tuple[AttributeDict]:
        &#34;&#34;&#34;
        Implementation of event new_admin in contract Timelock6h
        Get log entry for NewAdmin event.
                :param tx_hash: hash of transaction emitting NewAdmin event
        &#34;&#34;&#34;
        tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
        return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.NewAdmin().processReceipt(tx_receipt)

    def event_new_delay(
            self, tx_hash: Union[HexBytes, bytes]
    ) -&gt; Tuple[AttributeDict]:
        &#34;&#34;&#34;
        Implementation of event new_delay in contract Timelock6h
        Get log entry for NewDelay event.
                :param tx_hash: hash of transaction emitting NewDelay event
        &#34;&#34;&#34;
        tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
        return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.NewDelay().processReceipt(tx_receipt)

    def event_new_pending_admin(
            self, tx_hash: Union[HexBytes, bytes]
    ) -&gt; Tuple[AttributeDict]:
        &#34;&#34;&#34;
        Implementation of event new_pending_admin in contract Timelock6h
        Get log entry for NewPendingAdmin event.
                :param tx_hash: hash of transaction emitting NewPendingAdmin event
        &#34;&#34;&#34;
        tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
        return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.NewPendingAdmin().processReceipt(tx_receipt)

    def event_queue_transaction(
            self, tx_hash: Union[HexBytes, bytes]
    ) -&gt; Tuple[AttributeDict]:
        &#34;&#34;&#34;
        Implementation of event queue_transaction in contract Timelock6h
        Get log entry for QueueTransaction event.
                :param tx_hash: hash of transaction emitting QueueTransaction event
        &#34;&#34;&#34;
        tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
        return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.QueueTransaction().processReceipt(tx_receipt)

    def grace_period(self) -&gt; int:
        &#34;&#34;&#34;
        Implementation of grace_period in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_grace_period.block_call()

    def maximum_delay(self) -&gt; int:
        &#34;&#34;&#34;
        Implementation of maximum_delay in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_maximum_delay.block_call()

    def minimum_delay(self) -&gt; int:
        &#34;&#34;&#34;
        Implementation of minimum_delay in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_minimum_delay.block_call()

    def accept_admin(self) -&gt; None:
        &#34;&#34;&#34;
        Implementation of accept_admin in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_accept_admin.block_send(self.call_contract_fee_amount, self.call_contract_fee_price, 0, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)

    def admin(self) -&gt; str:
        &#34;&#34;&#34;
        Implementation of admin in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_admin.block_call()

    def cancel_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) -&gt; None:
        &#34;&#34;&#34;
        Implementation of cancel_transaction in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_cancel_transaction.block_send(target, value, signature, data, eta, self.call_contract_fee_amount, self.call_contract_fee_price, 0, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)

    def delay(self) -&gt; int:
        &#34;&#34;&#34;
        Implementation of delay in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_delay.block_call()

    def execute_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, wei: int = 0) -&gt; Union[bytes, str]:
        &#34;&#34;&#34;
        Implementation of execute_transaction in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_execute_transaction.block_send(target, value, signature, data, eta, self.call_contract_fee_amount, self.call_contract_fee_price, wei, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)

    def pending_admin(self) -&gt; str:
        &#34;&#34;&#34;
        Implementation of pending_admin in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_pending_admin.block_call()

    def queue_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) -&gt; Union[bytes, str]:
        &#34;&#34;&#34;
        Implementation of queue_transaction in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_queue_transaction.block_send(target, value, signature, data, eta, self.call_contract_fee_amount, self.call_contract_fee_price, 0, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)

    def queued_transactions(self, index_0: Union[bytes, str]) -&gt; bool:
        &#34;&#34;&#34;
        Implementation of queued_transactions in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_queued_transactions.block_call(index_0)

    def set_delay(self, delay_: int) -&gt; None:
        &#34;&#34;&#34;
        Implementation of set_delay in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_set_delay.block_send(delay_, self.call_contract_fee_amount, self.call_contract_fee_price, 0, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)

    def set_pending_admin(self, pending_admin_: str) -&gt; None:
        &#34;&#34;&#34;
        Implementation of set_pending_admin in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_set_pending_admin.block_send(pending_admin_, self.call_contract_fee_amount, self.call_contract_fee_price, 0, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)

    def CallContractWait(self, t_long: int) -&gt; &#34;Timelock6h&#34;:
        self._fn_grace_period.setWait(t_long)
        self._fn_maximum_delay.setWait(t_long)
        self._fn_minimum_delay.setWait(t_long)
        self._fn_accept_admin.setWait(t_long)
        self._fn_admin.setWait(t_long)
        self._fn_cancel_transaction.setWait(t_long)
        self._fn_delay.setWait(t_long)
        self._fn_execute_transaction.setWait(t_long)
        self._fn_pending_admin.setWait(t_long)
        self._fn_queue_transaction.setWait(t_long)
        self._fn_queued_transactions.setWait(t_long)
        self._fn_set_delay.setWait(t_long)
        self._fn_set_pending_admin.setWait(t_long)
        return self

    @staticmethod
    def abi():
        &#34;&#34;&#34;Return the ABI to the underlying contract.&#34;&#34;&#34;
        return json.loads(
            &#39;[{&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;admin_&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;delay_&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;constructor&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;bytes32&#34;,&#34;name&#34;:&#34;txHash&#34;,&#34;type&#34;:&#34;bytes32&#34;},{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;CancelTransaction&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;bytes32&#34;,&#34;name&#34;:&#34;txHash&#34;,&#34;type&#34;:&#34;bytes32&#34;},{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;ExecuteTransaction&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;newAdmin&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;name&#34;:&#34;NewAdmin&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;newDelay&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;NewDelay&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;newPendingAdmin&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;name&#34;:&#34;NewPendingAdmin&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;bytes32&#34;,&#34;name&#34;:&#34;txHash&#34;,&#34;type&#34;:&#34;bytes32&#34;},{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;QueueTransaction&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;payable&#34;:true,&#34;stateMutability&#34;:&#34;payable&#34;,&#34;type&#34;:&#34;fallback&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;GRACE_PERIOD&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;MAXIMUM_DELAY&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;MINIMUM_DELAY&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[],&#34;name&#34;:&#34;acceptAdmin&#34;,&#34;outputs&#34;:[],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;admin&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;cancelTransaction&#34;,&#34;outputs&#34;:[],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;delay&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;executeTransaction&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bytes&#34;}],&#34;payable&#34;:true,&#34;stateMutability&#34;:&#34;payable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;pendingAdmin&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;queueTransaction&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bytes32&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bytes32&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;bytes32&#34;,&#34;name&#34;:&#34;index_0&#34;,&#34;type&#34;:&#34;bytes32&#34;}],&#34;name&#34;:&#34;queuedTransactions&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;delay_&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;setDelay&#34;,&#34;outputs&#34;:[],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;pendingAdmin_&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;name&#34;:&#34;setPendingAdmin&#34;,&#34;outputs&#34;:[],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;}]&#39;
            # noqa: E501 (line-too-long)
        )

# pylint: disable=too-many-lines</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="moody.upgrades.Token" href="Token.html">moody.upgrades.Token</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="moody.upgrades.proxy" href="proxy.html">moody.upgrades.proxy</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="moody.upgrades.timelocker" href="timelocker.html">moody.upgrades.timelocker</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="moody.upgrades.AcceptAdminMethod"><code class="flex name class">
<span>class <span class="ident">AcceptAdminMethod</span></span>
<span>(</span><span>elib: <a title="moody.libeb.MiliDoS" href="../libeb.html#moody.libeb.MiliDoS">MiliDoS</a>, contract_address: str, contract_function: web3.contract.ContractFunction)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the acceptAdmin method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AcceptAdminMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the acceptAdmin method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address)
        self._underlying_method = contract_function

    def block_send(self, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; None:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        _fn = self._underlying_method()
        try:

            _t = _fn.buildTransaction({
                &#39;from&#39;: self._operate,
                &#39;gas&#39;: gas,
                &#39;gasPrice&#39;: price
            })
            _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

            if val &gt; 0:
                _t[&#39;value&#39;] = val

            if debug:
                print(f&#34;======== Signing ✅ by {self._operate}&#34;)
                print(f&#34;======== Transaction ✅ check&#34;)
                print(_t)

            if &#39;data&#39; in _t:

                signed = self._web3_eth.account.sign_transaction(_t)
                txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
                tx_receipt = None
                if receiptListen is True:
                    print(&#34;======== awaiting Confirmation 🚸️ -accept_admin&#34;)
                    tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                    if debug:
                        print(&#34;======== TX Result ✅&#34;)
                        print(tx_receipt)

                print(f&#34;======== TX blockHash ✅&#34;)
                if receiptListen is True and tx_receipt is not None:
                    print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
                else:
                    print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

            if receiptListen is False:
                time.sleep(self._wait)


        except ContractLogicError as er:
            print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: accept_admin&#34;)

        except ValueError as err:
            if &#34;message&#34; in err.args[0]:
                message = err.args[0][&#34;message&#34;]
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
            else:
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)

    def send_transaction(self, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().transact(tx_params.as_dict())

    def build_transaction(self, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().buildTransaction(tx_params.as_dict())

    def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.upgrades.AcceptAdminMethod.block_send"><code class="name flex">
<span>def <span class="ident">block_send</span></span>(<span>self, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_call.</p>
<p>:param tx_params: transaction parameters
:returns: the return value of the underlying method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_send(self, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; None:
    &#34;&#34;&#34;Execute underlying contract method via eth_call.

    :param tx_params: transaction parameters
    :returns: the return value of the underlying method.
    &#34;&#34;&#34;
    _fn = self._underlying_method()
    try:

        _t = _fn.buildTransaction({
            &#39;from&#39;: self._operate,
            &#39;gas&#39;: gas,
            &#39;gasPrice&#39;: price
        })
        _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

        if val &gt; 0:
            _t[&#39;value&#39;] = val

        if debug:
            print(f&#34;======== Signing ✅ by {self._operate}&#34;)
            print(f&#34;======== Transaction ✅ check&#34;)
            print(_t)

        if &#39;data&#39; in _t:

            signed = self._web3_eth.account.sign_transaction(_t)
            txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
            tx_receipt = None
            if receiptListen is True:
                print(&#34;======== awaiting Confirmation 🚸️ -accept_admin&#34;)
                tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                if debug:
                    print(&#34;======== TX Result ✅&#34;)
                    print(tx_receipt)

            print(f&#34;======== TX blockHash ✅&#34;)
            if receiptListen is True and tx_receipt is not None:
                print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
            else:
                print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

        if receiptListen is False:
            time.sleep(self._wait)


    except ContractLogicError as er:
        print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: accept_admin&#34;)

    except ValueError as err:
        if &#34;message&#34; in err.args[0]:
            message = err.args[0][&#34;message&#34;]
            print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
        else:
            print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.AcceptAdminMethod.build_transaction"><code class="name flex">
<span>def <span class="ident">build_transaction</span></span>(<span>self, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Construct calldata to be used as input to the method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_transaction(self, tx_params: Optional[TxParams] = None) -&gt; dict:
    &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method().buildTransaction(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.AcceptAdminMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method().estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.AcceptAdminMethod.send_transaction"><code class="name flex">
<span>def <span class="ident">send_transaction</span></span>(<span>self, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> Union[hexbytes.main.HexBytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_sendTransaction.</p>
<p>:param tx_params: transaction parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_transaction(self, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
    &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

    :param tx_params: transaction parameters
    &#34;&#34;&#34;
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method().transact(tx_params.as_dict())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../m/bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../m/bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.upgrades.AdminMethod"><code class="flex name class">
<span>class <span class="ident">AdminMethod</span></span>
<span>(</span><span>elib: <a title="moody.libeb.MiliDoS" href="../libeb.html#moody.libeb.MiliDoS">MiliDoS</a>, contract_address: str, contract_function: web3.contract.ContractFunction)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the admin method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AdminMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the admin method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address)
        self._underlying_method = contract_function

    def block_call(self, debug: bool = False) -&gt; str:
        _fn = self._underlying_method()
        returned = _fn.call({
            &#39;from&#39;: self._operate
        })
        return str(returned)

    def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.upgrades.AdminMethod.block_call"><code class="name flex">
<span>def <span class="ident">block_call</span></span>(<span>self, debug: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_call(self, debug: bool = False) -&gt; str:
    _fn = self._underlying_method()
    returned = _fn.call({
        &#39;from&#39;: self._operate
    })
    return str(returned)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.AdminMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method().estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../m/bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../m/bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.upgrades.CancelTransactionMethod"><code class="flex name class">
<span>class <span class="ident">CancelTransactionMethod</span></span>
<span>(</span><span>elib: <a title="moody.libeb.MiliDoS" href="../libeb.html#moody.libeb.MiliDoS">MiliDoS</a>, contract_address: str, contract_function: web3.contract.ContractFunction, validator: <a title="moody.m.bases.Validator" href="../m/bases.html#moody.m.bases.Validator">Validator</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the cancelTransaction method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CancelTransactionMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the cancelTransaction method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction, validator: Validator = None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) -&gt; any:
        &#34;&#34;&#34;Validate the inputs to the cancelTransaction method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;cancelTransaction&#39;,
            parameter_name=&#39;target&#39;,
            argument_value=target,
        )
        target = self.validate_and_checksum_address(target)
        self.validator.assert_valid(
            method_name=&#39;cancelTransaction&#39;,
            parameter_name=&#39;value&#39;,
            argument_value=value,
        )
        # safeguard against fractional inputs
        value = int(value)
        self.validator.assert_valid(
            method_name=&#39;cancelTransaction&#39;,
            parameter_name=&#39;signature&#39;,
            argument_value=signature,
        )
        self.validator.assert_valid(
            method_name=&#39;cancelTransaction&#39;,
            parameter_name=&#39;data&#39;,
            argument_value=data,
        )
        self.validator.assert_valid(
            method_name=&#39;cancelTransaction&#39;,
            parameter_name=&#39;eta&#39;,
            argument_value=eta,
        )
        # safeguard against fractional inputs
        eta = int(eta)
        return (target, value, signature, data, eta)

    def block_send(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; None:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        _fn = self._underlying_method(target, value, signature, data, eta)
        try:

            _t = _fn.buildTransaction({
                &#39;from&#39;: self._operate,
                &#39;gas&#39;: gas,
                &#39;gasPrice&#39;: price
            })
            _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

            if val &gt; 0:
                _t[&#39;value&#39;] = val

            if debug:
                print(f&#34;======== Signing ✅ by {self._operate}&#34;)
                print(f&#34;======== Transaction ✅ check&#34;)
                print(_t)

            if &#39;data&#39; in _t:

                signed = self._web3_eth.account.sign_transaction(_t)
                txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
                tx_receipt = None
                if receiptListen is True:
                    print(&#34;======== awaiting Confirmation 🚸️ -cancel_transaction&#34;)
                    tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                    if debug:
                        print(&#34;======== TX Result ✅&#34;)
                        print(tx_receipt)

                print(f&#34;======== TX blockHash ✅&#34;)
                if receiptListen is True and tx_receipt is not None:
                    print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
                else:
                    print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

            if receiptListen is False:
                time.sleep(self._wait)


        except ContractLogicError as er:
            print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: cancel_transaction&#34;)

        except ValueError as err:
            if &#34;message&#34; in err.args[0]:
                message = err.args[0][&#34;message&#34;]
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
            else:
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)

    def send_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).transact(tx_params.as_dict())

    def build_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.upgrades.CancelTransactionMethod.block_send"><code class="name flex">
<span>def <span class="ident">block_send</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_call.</p>
<p>:param tx_params: transaction parameters
:returns: the return value of the underlying method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_send(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; None:
    &#34;&#34;&#34;Execute underlying contract method via eth_call.

    :param tx_params: transaction parameters
    :returns: the return value of the underlying method.
    &#34;&#34;&#34;
    _fn = self._underlying_method(target, value, signature, data, eta)
    try:

        _t = _fn.buildTransaction({
            &#39;from&#39;: self._operate,
            &#39;gas&#39;: gas,
            &#39;gasPrice&#39;: price
        })
        _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

        if val &gt; 0:
            _t[&#39;value&#39;] = val

        if debug:
            print(f&#34;======== Signing ✅ by {self._operate}&#34;)
            print(f&#34;======== Transaction ✅ check&#34;)
            print(_t)

        if &#39;data&#39; in _t:

            signed = self._web3_eth.account.sign_transaction(_t)
            txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
            tx_receipt = None
            if receiptListen is True:
                print(&#34;======== awaiting Confirmation 🚸️ -cancel_transaction&#34;)
                tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                if debug:
                    print(&#34;======== TX Result ✅&#34;)
                    print(tx_receipt)

            print(f&#34;======== TX blockHash ✅&#34;)
            if receiptListen is True and tx_receipt is not None:
                print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
            else:
                print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

        if receiptListen is False:
            time.sleep(self._wait)


    except ContractLogicError as er:
        print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: cancel_transaction&#34;)

    except ValueError as err:
        if &#34;message&#34; in err.args[0]:
            message = err.args[0][&#34;message&#34;]
            print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
        else:
            print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.CancelTransactionMethod.build_transaction"><code class="name flex">
<span>def <span class="ident">build_transaction</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Construct calldata to be used as input to the method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; dict:
    &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
    (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(target, value, signature, data, eta).buildTransaction(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.CancelTransactionMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(target, value, signature, data, eta).estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.CancelTransactionMethod.send_transaction"><code class="name flex">
<span>def <span class="ident">send_transaction</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> Union[hexbytes.main.HexBytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_sendTransaction.</p>
<p>:param tx_params: transaction parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
    &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

    :param tx_params: transaction parameters
    &#34;&#34;&#34;
    (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(target, value, signature, data, eta).transact(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.CancelTransactionMethod.validate_and_normalize_inputs"><code class="name flex">
<span>def <span class="ident">validate_and_normalize_inputs</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) ‑> <built-in function any></span>
</code></dt>
<dd>
<div class="desc"><p>Validate the inputs to the cancelTransaction method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_and_normalize_inputs(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) -&gt; any:
    &#34;&#34;&#34;Validate the inputs to the cancelTransaction method.&#34;&#34;&#34;
    self.validator.assert_valid(
        method_name=&#39;cancelTransaction&#39;,
        parameter_name=&#39;target&#39;,
        argument_value=target,
    )
    target = self.validate_and_checksum_address(target)
    self.validator.assert_valid(
        method_name=&#39;cancelTransaction&#39;,
        parameter_name=&#39;value&#39;,
        argument_value=value,
    )
    # safeguard against fractional inputs
    value = int(value)
    self.validator.assert_valid(
        method_name=&#39;cancelTransaction&#39;,
        parameter_name=&#39;signature&#39;,
        argument_value=signature,
    )
    self.validator.assert_valid(
        method_name=&#39;cancelTransaction&#39;,
        parameter_name=&#39;data&#39;,
        argument_value=data,
    )
    self.validator.assert_valid(
        method_name=&#39;cancelTransaction&#39;,
        parameter_name=&#39;eta&#39;,
        argument_value=eta,
    )
    # safeguard against fractional inputs
    eta = int(eta)
    return (target, value, signature, data, eta)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../m/bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../m/bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.upgrades.DelayMethod"><code class="flex name class">
<span>class <span class="ident">DelayMethod</span></span>
<span>(</span><span>elib: <a title="moody.libeb.MiliDoS" href="../libeb.html#moody.libeb.MiliDoS">MiliDoS</a>, contract_address: str, contract_function: web3.contract.ContractFunction)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the delay method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DelayMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the delay method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address)
        self._underlying_method = contract_function

    def block_call(self, debug: bool = False) -&gt; int:
        _fn = self._underlying_method()
        returned = _fn.call({
            &#39;from&#39;: self._operate
        })
        return int(returned)

    def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.upgrades.DelayMethod.block_call"><code class="name flex">
<span>def <span class="ident">block_call</span></span>(<span>self, debug: bool = False) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_call(self, debug: bool = False) -&gt; int:
    _fn = self._underlying_method()
    returned = _fn.call({
        &#39;from&#39;: self._operate
    })
    return int(returned)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.DelayMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method().estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../m/bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../m/bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.upgrades.ExecuteTransactionMethod"><code class="flex name class">
<span>class <span class="ident">ExecuteTransactionMethod</span></span>
<span>(</span><span>elib: <a title="moody.libeb.MiliDoS" href="../libeb.html#moody.libeb.MiliDoS">MiliDoS</a>, contract_address: str, contract_function: web3.contract.ContractFunction, validator: <a title="moody.m.bases.Validator" href="../m/bases.html#moody.m.bases.Validator">Validator</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the executeTransaction method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExecuteTransactionMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the executeTransaction method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction, validator: Validator = None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) -&gt; any:
        &#34;&#34;&#34;Validate the inputs to the executeTransaction method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;executeTransaction&#39;,
            parameter_name=&#39;target&#39;,
            argument_value=target,
        )
        target = self.validate_and_checksum_address(target)
        self.validator.assert_valid(
            method_name=&#39;executeTransaction&#39;,
            parameter_name=&#39;value&#39;,
            argument_value=value,
        )
        # safeguard against fractional inputs
        value = int(value)
        self.validator.assert_valid(
            method_name=&#39;executeTransaction&#39;,
            parameter_name=&#39;signature&#39;,
            argument_value=signature,
        )
        self.validator.assert_valid(
            method_name=&#39;executeTransaction&#39;,
            parameter_name=&#39;data&#39;,
            argument_value=data,
        )
        self.validator.assert_valid(
            method_name=&#39;executeTransaction&#39;,
            parameter_name=&#39;eta&#39;,
            argument_value=eta,
        )
        # safeguard against fractional inputs
        eta = int(eta)
        return (target, value, signature, data, eta)

    def block_send(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; Union[bytes, str]:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        _fn = self._underlying_method(target, value, signature, data, eta)
        try:

            _t = _fn.buildTransaction({
                &#39;from&#39;: self._operate,
                &#39;gas&#39;: gas,
                &#39;gasPrice&#39;: price
            })
            _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

            if val &gt; 0:
                _t[&#39;value&#39;] = val

            if debug:
                print(f&#34;======== Signing ✅ by {self._operate}&#34;)
                print(f&#34;======== Transaction ✅ check&#34;)
                print(_t)

            if &#39;data&#39; in _t:

                signed = self._web3_eth.account.sign_transaction(_t)
                txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
                tx_receipt = None
                if receiptListen is True:
                    print(&#34;======== awaiting Confirmation 🚸️ -execute_transaction&#34;)
                    tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                    if debug:
                        print(&#34;======== TX Result ✅&#34;)
                        print(tx_receipt)

                print(f&#34;======== TX blockHash ✅&#34;)
                if receiptListen is True and tx_receipt is not None:
                    print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
                else:
                    print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

            if receiptListen is False:
                time.sleep(self._wait)


        except ContractLogicError as er:
            print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: execute_transaction&#34;)

        except ValueError as err:
            if &#34;message&#34; in err.args[0]:
                message = err.args[0][&#34;message&#34;]
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
            else:
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)

    def send_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).transact(tx_params.as_dict())

    def build_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.upgrades.ExecuteTransactionMethod.block_send"><code class="name flex">
<span>def <span class="ident">block_send</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) ‑> Union[bytes, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_call.</p>
<p>:param tx_params: transaction parameters
:returns: the return value of the underlying method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_send(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; Union[bytes, str]:
    &#34;&#34;&#34;Execute underlying contract method via eth_call.

    :param tx_params: transaction parameters
    :returns: the return value of the underlying method.
    &#34;&#34;&#34;
    _fn = self._underlying_method(target, value, signature, data, eta)
    try:

        _t = _fn.buildTransaction({
            &#39;from&#39;: self._operate,
            &#39;gas&#39;: gas,
            &#39;gasPrice&#39;: price
        })
        _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

        if val &gt; 0:
            _t[&#39;value&#39;] = val

        if debug:
            print(f&#34;======== Signing ✅ by {self._operate}&#34;)
            print(f&#34;======== Transaction ✅ check&#34;)
            print(_t)

        if &#39;data&#39; in _t:

            signed = self._web3_eth.account.sign_transaction(_t)
            txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
            tx_receipt = None
            if receiptListen is True:
                print(&#34;======== awaiting Confirmation 🚸️ -execute_transaction&#34;)
                tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                if debug:
                    print(&#34;======== TX Result ✅&#34;)
                    print(tx_receipt)

            print(f&#34;======== TX blockHash ✅&#34;)
            if receiptListen is True and tx_receipt is not None:
                print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
            else:
                print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

        if receiptListen is False:
            time.sleep(self._wait)


    except ContractLogicError as er:
        print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: execute_transaction&#34;)

    except ValueError as err:
        if &#34;message&#34; in err.args[0]:
            message = err.args[0][&#34;message&#34;]
            print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
        else:
            print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.ExecuteTransactionMethod.build_transaction"><code class="name flex">
<span>def <span class="ident">build_transaction</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Construct calldata to be used as input to the method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; dict:
    &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
    (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(target, value, signature, data, eta).buildTransaction(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.ExecuteTransactionMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(target, value, signature, data, eta).estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.ExecuteTransactionMethod.send_transaction"><code class="name flex">
<span>def <span class="ident">send_transaction</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> Union[hexbytes.main.HexBytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_sendTransaction.</p>
<p>:param tx_params: transaction parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
    &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

    :param tx_params: transaction parameters
    &#34;&#34;&#34;
    (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(target, value, signature, data, eta).transact(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.ExecuteTransactionMethod.validate_and_normalize_inputs"><code class="name flex">
<span>def <span class="ident">validate_and_normalize_inputs</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) ‑> <built-in function any></span>
</code></dt>
<dd>
<div class="desc"><p>Validate the inputs to the executeTransaction method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_and_normalize_inputs(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) -&gt; any:
    &#34;&#34;&#34;Validate the inputs to the executeTransaction method.&#34;&#34;&#34;
    self.validator.assert_valid(
        method_name=&#39;executeTransaction&#39;,
        parameter_name=&#39;target&#39;,
        argument_value=target,
    )
    target = self.validate_and_checksum_address(target)
    self.validator.assert_valid(
        method_name=&#39;executeTransaction&#39;,
        parameter_name=&#39;value&#39;,
        argument_value=value,
    )
    # safeguard against fractional inputs
    value = int(value)
    self.validator.assert_valid(
        method_name=&#39;executeTransaction&#39;,
        parameter_name=&#39;signature&#39;,
        argument_value=signature,
    )
    self.validator.assert_valid(
        method_name=&#39;executeTransaction&#39;,
        parameter_name=&#39;data&#39;,
        argument_value=data,
    )
    self.validator.assert_valid(
        method_name=&#39;executeTransaction&#39;,
        parameter_name=&#39;eta&#39;,
        argument_value=eta,
    )
    # safeguard against fractional inputs
    eta = int(eta)
    return (target, value, signature, data, eta)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../m/bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../m/bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.upgrades.GracePeriodMethod"><code class="flex name class">
<span>class <span class="ident">GracePeriodMethod</span></span>
<span>(</span><span>elib: <a title="moody.libeb.MiliDoS" href="../libeb.html#moody.libeb.MiliDoS">MiliDoS</a>, contract_address: str, contract_function: web3.contract.ContractFunction)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the GRACE_PERIOD method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GracePeriodMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the GRACE_PERIOD method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address)
        self._underlying_method = contract_function

    def block_call(self, debug: bool = False) -&gt; int:
        _fn = self._underlying_method()
        returned = _fn.call({
            &#39;from&#39;: self._operate
        })
        return int(returned)

    def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.upgrades.GracePeriodMethod.block_call"><code class="name flex">
<span>def <span class="ident">block_call</span></span>(<span>self, debug: bool = False) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_call(self, debug: bool = False) -&gt; int:
    _fn = self._underlying_method()
    returned = _fn.call({
        &#39;from&#39;: self._operate
    })
    return int(returned)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.GracePeriodMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method().estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../m/bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../m/bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.upgrades.MaximumDelayMethod"><code class="flex name class">
<span>class <span class="ident">MaximumDelayMethod</span></span>
<span>(</span><span>elib: <a title="moody.libeb.MiliDoS" href="../libeb.html#moody.libeb.MiliDoS">MiliDoS</a>, contract_address: str, contract_function: web3.contract.ContractFunction)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the MAXIMUM_DELAY method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MaximumDelayMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the MAXIMUM_DELAY method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address)
        self._underlying_method = contract_function

    def block_call(self, debug: bool = False) -&gt; int:
        _fn = self._underlying_method()
        returned = _fn.call({
            &#39;from&#39;: self._operate
        })
        return int(returned)

    def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.upgrades.MaximumDelayMethod.block_call"><code class="name flex">
<span>def <span class="ident">block_call</span></span>(<span>self, debug: bool = False) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_call(self, debug: bool = False) -&gt; int:
    _fn = self._underlying_method()
    returned = _fn.call({
        &#39;from&#39;: self._operate
    })
    return int(returned)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.MaximumDelayMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method().estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../m/bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../m/bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.upgrades.MinimumDelayMethod"><code class="flex name class">
<span>class <span class="ident">MinimumDelayMethod</span></span>
<span>(</span><span>elib: <a title="moody.libeb.MiliDoS" href="../libeb.html#moody.libeb.MiliDoS">MiliDoS</a>, contract_address: str, contract_function: web3.contract.ContractFunction)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the MINIMUM_DELAY method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MinimumDelayMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the MINIMUM_DELAY method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address)
        self._underlying_method = contract_function

    def block_call(self, debug: bool = False) -&gt; int:
        _fn = self._underlying_method()
        returned = _fn.call({
            &#39;from&#39;: self._operate
        })
        return int(returned)

    def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.upgrades.MinimumDelayMethod.block_call"><code class="name flex">
<span>def <span class="ident">block_call</span></span>(<span>self, debug: bool = False) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_call(self, debug: bool = False) -&gt; int:
    _fn = self._underlying_method()
    returned = _fn.call({
        &#39;from&#39;: self._operate
    })
    return int(returned)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.MinimumDelayMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method().estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../m/bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../m/bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.upgrades.PendingAdminMethod"><code class="flex name class">
<span>class <span class="ident">PendingAdminMethod</span></span>
<span>(</span><span>elib: <a title="moody.libeb.MiliDoS" href="../libeb.html#moody.libeb.MiliDoS">MiliDoS</a>, contract_address: str, contract_function: web3.contract.ContractFunction)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the pendingAdmin method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PendingAdminMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the pendingAdmin method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address)
        self._underlying_method = contract_function

    def block_call(self, debug: bool = False) -&gt; str:
        _fn = self._underlying_method()
        returned = _fn.call({
            &#39;from&#39;: self._operate
        })
        return str(returned)

    def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.upgrades.PendingAdminMethod.block_call"><code class="name flex">
<span>def <span class="ident">block_call</span></span>(<span>self, debug: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_call(self, debug: bool = False) -&gt; str:
    _fn = self._underlying_method()
    returned = _fn.call({
        &#39;from&#39;: self._operate
    })
    return str(returned)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.PendingAdminMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method().estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../m/bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../m/bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.upgrades.QueueTransactionMethod"><code class="flex name class">
<span>class <span class="ident">QueueTransactionMethod</span></span>
<span>(</span><span>elib: <a title="moody.libeb.MiliDoS" href="../libeb.html#moody.libeb.MiliDoS">MiliDoS</a>, contract_address: str, contract_function: web3.contract.ContractFunction, validator: <a title="moody.m.bases.Validator" href="../m/bases.html#moody.m.bases.Validator">Validator</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the queueTransaction method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QueueTransactionMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the queueTransaction method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction, validator: Validator = None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) -&gt; any:
        &#34;&#34;&#34;Validate the inputs to the queueTransaction method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;queueTransaction&#39;,
            parameter_name=&#39;target&#39;,
            argument_value=target,
        )
        target = self.validate_and_checksum_address(target)
        self.validator.assert_valid(
            method_name=&#39;queueTransaction&#39;,
            parameter_name=&#39;value&#39;,
            argument_value=value,
        )
        # safeguard against fractional inputs
        value = int(value)
        self.validator.assert_valid(
            method_name=&#39;queueTransaction&#39;,
            parameter_name=&#39;signature&#39;,
            argument_value=signature,
        )
        self.validator.assert_valid(
            method_name=&#39;queueTransaction&#39;,
            parameter_name=&#39;data&#39;,
            argument_value=data,
        )
        self.validator.assert_valid(
            method_name=&#39;queueTransaction&#39;,
            parameter_name=&#39;eta&#39;,
            argument_value=eta,
        )
        # safeguard against fractional inputs
        eta = int(eta)
        return (target, value, signature, data, eta)

    def block_send(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; Union[bytes, str]:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        _fn = self._underlying_method(target, value, signature, data, eta)
        try:

            _t = _fn.buildTransaction({
                &#39;from&#39;: self._operate,
                &#39;gas&#39;: gas,
                &#39;gasPrice&#39;: price
            })
            _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

            if val &gt; 0:
                _t[&#39;value&#39;] = val

            if debug:
                print(f&#34;======== Signing ✅ by {self._operate}&#34;)
                print(f&#34;======== Transaction ✅ check&#34;)
                print(_t)

            if &#39;data&#39; in _t:

                signed = self._web3_eth.account.sign_transaction(_t)
                txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
                tx_receipt = None
                if receiptListen is True:
                    print(&#34;======== awaiting Confirmation 🚸️ -queue_transaction&#34;)
                    tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                    if debug:
                        print(&#34;======== TX Result ✅&#34;)
                        print(tx_receipt)

                print(f&#34;======== TX blockHash ✅&#34;)
                if receiptListen is True and tx_receipt is not None:
                    print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
                else:
                    print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

            if receiptListen is False:
                time.sleep(self._wait)


        except ContractLogicError as er:
            print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: queue_transaction&#34;)

        except ValueError as err:
            if &#34;message&#34; in err.args[0]:
                message = err.args[0][&#34;message&#34;]
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
            else:
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)

    def send_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).transact(tx_params.as_dict())

    def build_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(target, value, signature, data, eta).estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.upgrades.QueueTransactionMethod.block_send"><code class="name flex">
<span>def <span class="ident">block_send</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) ‑> Union[bytes, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_call.</p>
<p>:param tx_params: transaction parameters
:returns: the return value of the underlying method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_send(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; Union[bytes, str]:
    &#34;&#34;&#34;Execute underlying contract method via eth_call.

    :param tx_params: transaction parameters
    :returns: the return value of the underlying method.
    &#34;&#34;&#34;
    _fn = self._underlying_method(target, value, signature, data, eta)
    try:

        _t = _fn.buildTransaction({
            &#39;from&#39;: self._operate,
            &#39;gas&#39;: gas,
            &#39;gasPrice&#39;: price
        })
        _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

        if val &gt; 0:
            _t[&#39;value&#39;] = val

        if debug:
            print(f&#34;======== Signing ✅ by {self._operate}&#34;)
            print(f&#34;======== Transaction ✅ check&#34;)
            print(_t)

        if &#39;data&#39; in _t:

            signed = self._web3_eth.account.sign_transaction(_t)
            txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
            tx_receipt = None
            if receiptListen is True:
                print(&#34;======== awaiting Confirmation 🚸️ -queue_transaction&#34;)
                tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                if debug:
                    print(&#34;======== TX Result ✅&#34;)
                    print(tx_receipt)

            print(f&#34;======== TX blockHash ✅&#34;)
            if receiptListen is True and tx_receipt is not None:
                print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
            else:
                print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

        if receiptListen is False:
            time.sleep(self._wait)


    except ContractLogicError as er:
        print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: queue_transaction&#34;)

    except ValueError as err:
        if &#34;message&#34; in err.args[0]:
            message = err.args[0][&#34;message&#34;]
            print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
        else:
            print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.QueueTransactionMethod.build_transaction"><code class="name flex">
<span>def <span class="ident">build_transaction</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Construct calldata to be used as input to the method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; dict:
    &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
    (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(target, value, signature, data, eta).buildTransaction(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.QueueTransactionMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(target, value, signature, data, eta).estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.QueueTransactionMethod.send_transaction"><code class="name flex">
<span>def <span class="ident">send_transaction</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> Union[hexbytes.main.HexBytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_sendTransaction.</p>
<p>:param tx_params: transaction parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
    &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

    :param tx_params: transaction parameters
    &#34;&#34;&#34;
    (target, value, signature, data, eta) = self.validate_and_normalize_inputs(target, value, signature, data, eta)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(target, value, signature, data, eta).transact(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.QueueTransactionMethod.validate_and_normalize_inputs"><code class="name flex">
<span>def <span class="ident">validate_and_normalize_inputs</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) ‑> <built-in function any></span>
</code></dt>
<dd>
<div class="desc"><p>Validate the inputs to the queueTransaction method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_and_normalize_inputs(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) -&gt; any:
    &#34;&#34;&#34;Validate the inputs to the queueTransaction method.&#34;&#34;&#34;
    self.validator.assert_valid(
        method_name=&#39;queueTransaction&#39;,
        parameter_name=&#39;target&#39;,
        argument_value=target,
    )
    target = self.validate_and_checksum_address(target)
    self.validator.assert_valid(
        method_name=&#39;queueTransaction&#39;,
        parameter_name=&#39;value&#39;,
        argument_value=value,
    )
    # safeguard against fractional inputs
    value = int(value)
    self.validator.assert_valid(
        method_name=&#39;queueTransaction&#39;,
        parameter_name=&#39;signature&#39;,
        argument_value=signature,
    )
    self.validator.assert_valid(
        method_name=&#39;queueTransaction&#39;,
        parameter_name=&#39;data&#39;,
        argument_value=data,
    )
    self.validator.assert_valid(
        method_name=&#39;queueTransaction&#39;,
        parameter_name=&#39;eta&#39;,
        argument_value=eta,
    )
    # safeguard against fractional inputs
    eta = int(eta)
    return (target, value, signature, data, eta)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../m/bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../m/bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.upgrades.QueuedTransactionsMethod"><code class="flex name class">
<span>class <span class="ident">QueuedTransactionsMethod</span></span>
<span>(</span><span>elib: <a title="moody.libeb.MiliDoS" href="../libeb.html#moody.libeb.MiliDoS">MiliDoS</a>, contract_address: str, contract_function: web3.contract.ContractFunction, validator: <a title="moody.m.bases.Validator" href="../m/bases.html#moody.m.bases.Validator">Validator</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the queuedTransactions method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QueuedTransactionsMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the queuedTransactions method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction, validator: Validator = None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, index_0: Union[bytes, str]) -&gt; any:
        &#34;&#34;&#34;Validate the inputs to the queuedTransactions method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;queuedTransactions&#39;,
            parameter_name=&#39;index_0&#39;,
            argument_value=index_0,
        )
        return (index_0)

    def block_call(self, index_0: Union[bytes, str], debug: bool = False) -&gt; bool:
        _fn = self._underlying_method(index_0)
        returned = _fn.call({
            &#39;from&#39;: self._operate
        })
        return bool(returned)

    def estimate_gas(self, index_0: Union[bytes, str], tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (index_0) = self.validate_and_normalize_inputs(index_0)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(index_0).estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.upgrades.QueuedTransactionsMethod.block_call"><code class="name flex">
<span>def <span class="ident">block_call</span></span>(<span>self, index_0: Union[bytes, str], debug: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_call(self, index_0: Union[bytes, str], debug: bool = False) -&gt; bool:
    _fn = self._underlying_method(index_0)
    returned = _fn.call({
        &#39;from&#39;: self._operate
    })
    return bool(returned)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.QueuedTransactionsMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, index_0: Union[bytes, str], tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, index_0: Union[bytes, str], tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    (index_0) = self.validate_and_normalize_inputs(index_0)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(index_0).estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.QueuedTransactionsMethod.validate_and_normalize_inputs"><code class="name flex">
<span>def <span class="ident">validate_and_normalize_inputs</span></span>(<span>self, index_0: Union[bytes, str]) ‑> <built-in function any></span>
</code></dt>
<dd>
<div class="desc"><p>Validate the inputs to the queuedTransactions method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_and_normalize_inputs(self, index_0: Union[bytes, str]) -&gt; any:
    &#34;&#34;&#34;Validate the inputs to the queuedTransactions method.&#34;&#34;&#34;
    self.validator.assert_valid(
        method_name=&#39;queuedTransactions&#39;,
        parameter_name=&#39;index_0&#39;,
        argument_value=index_0,
    )
    return (index_0)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../m/bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../m/bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.upgrades.SetDelayMethod"><code class="flex name class">
<span>class <span class="ident">SetDelayMethod</span></span>
<span>(</span><span>elib: <a title="moody.libeb.MiliDoS" href="../libeb.html#moody.libeb.MiliDoS">MiliDoS</a>, contract_address: str, contract_function: web3.contract.ContractFunction, validator: <a title="moody.m.bases.Validator" href="../m/bases.html#moody.m.bases.Validator">Validator</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the setDelay method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SetDelayMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the setDelay method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction, validator: Validator = None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, delay_: int) -&gt; any:
        &#34;&#34;&#34;Validate the inputs to the setDelay method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;setDelay&#39;,
            parameter_name=&#39;delay_&#39;,
            argument_value=delay_,
        )
        # safeguard against fractional inputs
        delay_ = int(delay_)
        return (delay_)

    def block_send(self, delay_: int, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; None:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        _fn = self._underlying_method(delay_)
        try:

            _t = _fn.buildTransaction({
                &#39;from&#39;: self._operate,
                &#39;gas&#39;: gas,
                &#39;gasPrice&#39;: price
            })
            _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

            if val &gt; 0:
                _t[&#39;value&#39;] = val

            if debug:
                print(f&#34;======== Signing ✅ by {self._operate}&#34;)
                print(f&#34;======== Transaction ✅ check&#34;)
                print(_t)

            if &#39;data&#39; in _t:

                signed = self._web3_eth.account.sign_transaction(_t)
                txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
                tx_receipt = None
                if receiptListen is True:
                    print(&#34;======== awaiting Confirmation 🚸️ -set_delay&#34;)
                    tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                    if debug:
                        print(&#34;======== TX Result ✅&#34;)
                        print(tx_receipt)

                print(f&#34;======== TX blockHash ✅&#34;)
                if receiptListen is True and tx_receipt is not None:
                    print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
                else:
                    print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

            if receiptListen is False:
                time.sleep(self._wait)


        except ContractLogicError as er:
            print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: set_delay&#34;)

        except ValueError as err:
            if &#34;message&#34; in err.args[0]:
                message = err.args[0][&#34;message&#34;]
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
            else:
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)

    def send_transaction(self, delay_: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (delay_) = self.validate_and_normalize_inputs(delay_)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(delay_).transact(tx_params.as_dict())

    def build_transaction(self, delay_: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (delay_) = self.validate_and_normalize_inputs(delay_)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(delay_).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, delay_: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (delay_) = self.validate_and_normalize_inputs(delay_)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(delay_).estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.upgrades.SetDelayMethod.block_send"><code class="name flex">
<span>def <span class="ident">block_send</span></span>(<span>self, delay_: int, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_call.</p>
<p>:param tx_params: transaction parameters
:returns: the return value of the underlying method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_send(self, delay_: int, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; None:
    &#34;&#34;&#34;Execute underlying contract method via eth_call.

    :param tx_params: transaction parameters
    :returns: the return value of the underlying method.
    &#34;&#34;&#34;
    _fn = self._underlying_method(delay_)
    try:

        _t = _fn.buildTransaction({
            &#39;from&#39;: self._operate,
            &#39;gas&#39;: gas,
            &#39;gasPrice&#39;: price
        })
        _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

        if val &gt; 0:
            _t[&#39;value&#39;] = val

        if debug:
            print(f&#34;======== Signing ✅ by {self._operate}&#34;)
            print(f&#34;======== Transaction ✅ check&#34;)
            print(_t)

        if &#39;data&#39; in _t:

            signed = self._web3_eth.account.sign_transaction(_t)
            txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
            tx_receipt = None
            if receiptListen is True:
                print(&#34;======== awaiting Confirmation 🚸️ -set_delay&#34;)
                tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                if debug:
                    print(&#34;======== TX Result ✅&#34;)
                    print(tx_receipt)

            print(f&#34;======== TX blockHash ✅&#34;)
            if receiptListen is True and tx_receipt is not None:
                print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
            else:
                print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

        if receiptListen is False:
            time.sleep(self._wait)


    except ContractLogicError as er:
        print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: set_delay&#34;)

    except ValueError as err:
        if &#34;message&#34; in err.args[0]:
            message = err.args[0][&#34;message&#34;]
            print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
        else:
            print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SetDelayMethod.build_transaction"><code class="name flex">
<span>def <span class="ident">build_transaction</span></span>(<span>self, delay_: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Construct calldata to be used as input to the method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_transaction(self, delay_: int, tx_params: Optional[TxParams] = None) -&gt; dict:
    &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
    (delay_) = self.validate_and_normalize_inputs(delay_)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(delay_).buildTransaction(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SetDelayMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, delay_: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, delay_: int, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    (delay_) = self.validate_and_normalize_inputs(delay_)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(delay_).estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SetDelayMethod.send_transaction"><code class="name flex">
<span>def <span class="ident">send_transaction</span></span>(<span>self, delay_: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> Union[hexbytes.main.HexBytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_sendTransaction.</p>
<p>:param tx_params: transaction parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_transaction(self, delay_: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
    &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

    :param tx_params: transaction parameters
    &#34;&#34;&#34;
    (delay_) = self.validate_and_normalize_inputs(delay_)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(delay_).transact(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SetDelayMethod.validate_and_normalize_inputs"><code class="name flex">
<span>def <span class="ident">validate_and_normalize_inputs</span></span>(<span>self, delay_: int) ‑> <built-in function any></span>
</code></dt>
<dd>
<div class="desc"><p>Validate the inputs to the setDelay method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_and_normalize_inputs(self, delay_: int) -&gt; any:
    &#34;&#34;&#34;Validate the inputs to the setDelay method.&#34;&#34;&#34;
    self.validator.assert_valid(
        method_name=&#39;setDelay&#39;,
        parameter_name=&#39;delay_&#39;,
        argument_value=delay_,
    )
    # safeguard against fractional inputs
    delay_ = int(delay_)
    return (delay_)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../m/bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../m/bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.upgrades.SetPendingAdminMethod"><code class="flex name class">
<span>class <span class="ident">SetPendingAdminMethod</span></span>
<span>(</span><span>elib: <a title="moody.libeb.MiliDoS" href="../libeb.html#moody.libeb.MiliDoS">MiliDoS</a>, contract_address: str, contract_function: web3.contract.ContractFunction, validator: <a title="moody.m.bases.Validator" href="../m/bases.html#moody.m.bases.Validator">Validator</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the setPendingAdmin method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SetPendingAdminMethod(ContractMethod):  # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the setPendingAdmin method.&#34;&#34;&#34;

    def __init__(self, elib: MiliDoS, contract_address: str, contract_function: ContractFunction, validator: Validator = None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(elib, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, pending_admin_: str) -&gt; any:
        &#34;&#34;&#34;Validate the inputs to the setPendingAdmin method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;setPendingAdmin&#39;,
            parameter_name=&#39;pendingAdmin_&#39;,
            argument_value=pending_admin_,
        )
        pending_admin_ = self.validate_and_checksum_address(pending_admin_)
        return (pending_admin_)

    def block_send(self, pending_admin_: str, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; None:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        _fn = self._underlying_method(pending_admin_)
        try:

            _t = _fn.buildTransaction({
                &#39;from&#39;: self._operate,
                &#39;gas&#39;: gas,
                &#39;gasPrice&#39;: price
            })
            _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

            if val &gt; 0:
                _t[&#39;value&#39;] = val

            if debug:
                print(f&#34;======== Signing ✅ by {self._operate}&#34;)
                print(f&#34;======== Transaction ✅ check&#34;)
                print(_t)

            if &#39;data&#39; in _t:

                signed = self._web3_eth.account.sign_transaction(_t)
                txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
                tx_receipt = None
                if receiptListen is True:
                    print(&#34;======== awaiting Confirmation 🚸️ -set_pending_admin&#34;)
                    tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                    if debug:
                        print(&#34;======== TX Result ✅&#34;)
                        print(tx_receipt)

                print(f&#34;======== TX blockHash ✅&#34;)
                if receiptListen is True and tx_receipt is not None:
                    print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
                else:
                    print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

            if receiptListen is False:
                time.sleep(self._wait)


        except ContractLogicError as er:
            print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: set_pending_admin&#34;)

        except ValueError as err:
            if &#34;message&#34; in err.args[0]:
                message = err.args[0][&#34;message&#34;]
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
            else:
                print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)

    def send_transaction(self, pending_admin_: str, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (pending_admin_) = self.validate_and_normalize_inputs(pending_admin_)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(pending_admin_).transact(tx_params.as_dict())

    def build_transaction(self, pending_admin_: str, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (pending_admin_) = self.validate_and_normalize_inputs(pending_admin_)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(pending_admin_).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, pending_admin_: str, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (pending_admin_) = self.validate_and_normalize_inputs(pending_admin_)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(pending_admin_).estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.upgrades.SetPendingAdminMethod.block_send"><code class="name flex">
<span>def <span class="ident">block_send</span></span>(<span>self, pending_admin_: str, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_call.</p>
<p>:param tx_params: transaction parameters
:returns: the return value of the underlying method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_send(self, pending_admin_: str, gas: int, price: int, val: int = 0, debug: bool = False, receiptListen: bool = False) -&gt; None:
    &#34;&#34;&#34;Execute underlying contract method via eth_call.

    :param tx_params: transaction parameters
    :returns: the return value of the underlying method.
    &#34;&#34;&#34;
    _fn = self._underlying_method(pending_admin_)
    try:

        _t = _fn.buildTransaction({
            &#39;from&#39;: self._operate,
            &#39;gas&#39;: gas,
            &#39;gasPrice&#39;: price
        })
        _t[&#39;nonce&#39;] = self._web3_eth.getTransactionCount(self._operate)

        if val &gt; 0:
            _t[&#39;value&#39;] = val

        if debug:
            print(f&#34;======== Signing ✅ by {self._operate}&#34;)
            print(f&#34;======== Transaction ✅ check&#34;)
            print(_t)

        if &#39;data&#39; in _t:

            signed = self._web3_eth.account.sign_transaction(_t)
            txHash = self._web3_eth.sendRawTransaction(signed.rawTransaction)
            tx_receipt = None
            if receiptListen is True:
                print(&#34;======== awaiting Confirmation 🚸️ -set_pending_admin&#34;)
                tx_receipt = self._web3_eth.waitForTransactionReceipt(txHash)
                if debug:
                    print(&#34;======== TX Result ✅&#34;)
                    print(tx_receipt)

            print(f&#34;======== TX blockHash ✅&#34;)
            if receiptListen is True and tx_receipt is not None:
                print(f&#34;{Bolors.OK}{tx_receipt.blockHash.hex()}{Bolors.RESET}&#34;)
            else:
                print(f&#34;{Bolors.WARNING}{txHash.hex()}{Bolors.RESET}&#34;)

        if receiptListen is False:
            time.sleep(self._wait)


    except ContractLogicError as er:
        print(f&#34;{Bolors.FAIL}Error {er} {Bolors.RESET}: set_pending_admin&#34;)

    except ValueError as err:
        if &#34;message&#34; in err.args[0]:
            message = err.args[0][&#34;message&#34;]
            print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET} on set_asset_token: {message}&#34;)
        else:
            print(f&#34;{Bolors.FAIL}Error Revert {Bolors.RESET}: set_asset_token&#34;)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SetPendingAdminMethod.build_transaction"><code class="name flex">
<span>def <span class="ident">build_transaction</span></span>(<span>self, pending_admin_: str, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Construct calldata to be used as input to the method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_transaction(self, pending_admin_: str, tx_params: Optional[TxParams] = None) -&gt; dict:
    &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
    (pending_admin_) = self.validate_and_normalize_inputs(pending_admin_)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(pending_admin_).buildTransaction(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SetPendingAdminMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, pending_admin_: str, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, pending_admin_: str, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    (pending_admin_) = self.validate_and_normalize_inputs(pending_admin_)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(pending_admin_).estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SetPendingAdminMethod.send_transaction"><code class="name flex">
<span>def <span class="ident">send_transaction</span></span>(<span>self, pending_admin_: str, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../m/tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> Union[hexbytes.main.HexBytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_sendTransaction.</p>
<p>:param tx_params: transaction parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_transaction(self, pending_admin_: str, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
    &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

    :param tx_params: transaction parameters
    &#34;&#34;&#34;
    (pending_admin_) = self.validate_and_normalize_inputs(pending_admin_)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(pending_admin_).transact(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SetPendingAdminMethod.validate_and_normalize_inputs"><code class="name flex">
<span>def <span class="ident">validate_and_normalize_inputs</span></span>(<span>self, pending_admin_: str) ‑> <built-in function any></span>
</code></dt>
<dd>
<div class="desc"><p>Validate the inputs to the setPendingAdmin method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_and_normalize_inputs(self, pending_admin_: str) -&gt; any:
    &#34;&#34;&#34;Validate the inputs to the setPendingAdmin method.&#34;&#34;&#34;
    self.validator.assert_valid(
        method_name=&#39;setPendingAdmin&#39;,
        parameter_name=&#39;pendingAdmin_&#39;,
        argument_value=pending_admin_,
    )
    pending_admin_ = self.validate_and_checksum_address(pending_admin_)
    return (pending_admin_)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../m/bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../m/bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../m/bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.upgrades.SignatureGenerator"><code class="flex name class">
<span>class <span class="ident">SignatureGenerator</span></span>
<span>(</span><span>abi: <built-in function any>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignatureGenerator:
    _function_signatures = {}

    def __init__(self, abi: any):
        for func in [obj for obj in abi if obj[&#39;type&#39;] == &#39;function&#39;]:
            name = func[&#39;name&#39;]
            types = [input[&#39;type&#39;] for input in func[&#39;inputs&#39;]]
            self._function_signatures[name] = &#39;{}({})&#39;.format(name, &#39;,&#39;.join(types))

    def grace_period(self) -&gt; str:
        return self._function_signatures[&#34;GRACE_PERIOD&#34;]

    def maximum_delay(self) -&gt; str:
        return self._function_signatures[&#34;MAXIMUM_DELAY&#34;]

    def minimum_delay(self) -&gt; str:
        return self._function_signatures[&#34;MINIMUM_DELAY&#34;]

    def accept_admin(self) -&gt; str:
        return self._function_signatures[&#34;acceptAdmin&#34;]

    def admin(self) -&gt; str:
        return self._function_signatures[&#34;admin&#34;]

    def cancel_transaction(self) -&gt; str:
        return self._function_signatures[&#34;cancelTransaction&#34;]

    def delay(self) -&gt; str:
        return self._function_signatures[&#34;delay&#34;]

    def execute_transaction(self) -&gt; str:
        return self._function_signatures[&#34;executeTransaction&#34;]

    def pending_admin(self) -&gt; str:
        return self._function_signatures[&#34;pendingAdmin&#34;]

    def queue_transaction(self) -&gt; str:
        return self._function_signatures[&#34;queueTransaction&#34;]

    def queued_transactions(self) -&gt; str:
        return self._function_signatures[&#34;queuedTransactions&#34;]

    def set_delay(self) -&gt; str:
        return self._function_signatures[&#34;setDelay&#34;]

    def set_pending_admin(self) -&gt; str:
        return self._function_signatures[&#34;setPendingAdmin&#34;]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="moody.upgrades.SignatureGenerator.accept_admin"><code class="name flex">
<span>def <span class="ident">accept_admin</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accept_admin(self) -&gt; str:
    return self._function_signatures[&#34;acceptAdmin&#34;]</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SignatureGenerator.admin"><code class="name flex">
<span>def <span class="ident">admin</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin(self) -&gt; str:
    return self._function_signatures[&#34;admin&#34;]</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SignatureGenerator.cancel_transaction"><code class="name flex">
<span>def <span class="ident">cancel_transaction</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel_transaction(self) -&gt; str:
    return self._function_signatures[&#34;cancelTransaction&#34;]</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SignatureGenerator.delay"><code class="name flex">
<span>def <span class="ident">delay</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delay(self) -&gt; str:
    return self._function_signatures[&#34;delay&#34;]</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SignatureGenerator.execute_transaction"><code class="name flex">
<span>def <span class="ident">execute_transaction</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_transaction(self) -&gt; str:
    return self._function_signatures[&#34;executeTransaction&#34;]</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SignatureGenerator.grace_period"><code class="name flex">
<span>def <span class="ident">grace_period</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grace_period(self) -&gt; str:
    return self._function_signatures[&#34;GRACE_PERIOD&#34;]</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SignatureGenerator.maximum_delay"><code class="name flex">
<span>def <span class="ident">maximum_delay</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maximum_delay(self) -&gt; str:
    return self._function_signatures[&#34;MAXIMUM_DELAY&#34;]</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SignatureGenerator.minimum_delay"><code class="name flex">
<span>def <span class="ident">minimum_delay</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minimum_delay(self) -&gt; str:
    return self._function_signatures[&#34;MINIMUM_DELAY&#34;]</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SignatureGenerator.pending_admin"><code class="name flex">
<span>def <span class="ident">pending_admin</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pending_admin(self) -&gt; str:
    return self._function_signatures[&#34;pendingAdmin&#34;]</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SignatureGenerator.queue_transaction"><code class="name flex">
<span>def <span class="ident">queue_transaction</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queue_transaction(self) -&gt; str:
    return self._function_signatures[&#34;queueTransaction&#34;]</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SignatureGenerator.queued_transactions"><code class="name flex">
<span>def <span class="ident">queued_transactions</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queued_transactions(self) -&gt; str:
    return self._function_signatures[&#34;queuedTransactions&#34;]</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SignatureGenerator.set_delay"><code class="name flex">
<span>def <span class="ident">set_delay</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_delay(self) -&gt; str:
    return self._function_signatures[&#34;setDelay&#34;]</code></pre>
</details>
</dd>
<dt id="moody.upgrades.SignatureGenerator.set_pending_admin"><code class="name flex">
<span>def <span class="ident">set_pending_admin</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pending_admin(self) -&gt; str:
    return self._function_signatures[&#34;setPendingAdmin&#34;]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="moody.upgrades.Timelock6h"><code class="flex name class">
<span>class <span class="ident">Timelock6h</span></span>
<span>(</span><span>core_lib: <a title="moody.libeb.MiliDoS" href="../libeb.html#moody.libeb.MiliDoS">MiliDoS</a>, contract_address: str, validator: <a title="moody.upgrades.Timelock6hValidator" href="#moody.upgrades.Timelock6hValidator">Timelock6hValidator</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper class for Timelock6h Solidity contract.</p>
<p>All method parameters of type <code>bytes</code>:code: should be encoded as UTF-8,
which can be accomplished via <code>str.encode("utf_8")</code>:code:.</p>
<p>Get an instance of wrapper for smart contract.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Timelock6h(ContractBase):
    &#34;&#34;&#34;Wrapper class for Timelock6h Solidity contract.

    All method parameters of type `bytes`:code: should be encoded as UTF-8,
    which can be accomplished via `str.encode(&#34;utf_8&#34;)`:code:.
    &#34;&#34;&#34;
    _fn_grace_period: GracePeriodMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`GracePeriodMethod`.
    &#34;&#34;&#34;

    _fn_maximum_delay: MaximumDelayMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`MaximumDelayMethod`.
    &#34;&#34;&#34;

    _fn_minimum_delay: MinimumDelayMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`MinimumDelayMethod`.
    &#34;&#34;&#34;

    _fn_accept_admin: AcceptAdminMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`AcceptAdminMethod`.
    &#34;&#34;&#34;

    _fn_admin: AdminMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`AdminMethod`.
    &#34;&#34;&#34;

    _fn_cancel_transaction: CancelTransactionMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`CancelTransactionMethod`.
    &#34;&#34;&#34;

    _fn_delay: DelayMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`DelayMethod`.
    &#34;&#34;&#34;

    _fn_execute_transaction: ExecuteTransactionMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`ExecuteTransactionMethod`.
    &#34;&#34;&#34;

    _fn_pending_admin: PendingAdminMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`PendingAdminMethod`.
    &#34;&#34;&#34;

    _fn_queue_transaction: QueueTransactionMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`QueueTransactionMethod`.
    &#34;&#34;&#34;

    _fn_queued_transactions: QueuedTransactionsMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`QueuedTransactionsMethod`.
    &#34;&#34;&#34;

    _fn_set_delay: SetDelayMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`SetDelayMethod`.
    &#34;&#34;&#34;

    _fn_set_pending_admin: SetPendingAdminMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`SetPendingAdminMethod`.
    &#34;&#34;&#34;

    def __init__(
            self,
            core_lib: MiliDoS,
            contract_address: str,
            validator: Timelock6hValidator = None,
    ):
        &#34;&#34;&#34;Get an instance of wrapper for smart contract.
        &#34;&#34;&#34;
        # pylint: disable=too-many-statements
        super().__init__()
        self.contract_address = contract_address
        web3 = core_lib.w3

        if not validator:
            validator = Timelock6hValidator(web3, contract_address)

        # if any middleware was imported, inject it
        try:
            MIDDLEWARE
        except NameError:
            pass
        else:
            try:
                for middleware in MIDDLEWARE:
                    web3.middleware_onion.inject(
                        middleware[&#39;function&#39;], layer=middleware[&#39;layer&#39;],
                    )
            except ValueError as value_error:
                if value_error.args == (&#34;You can&#39;t add the same un-named instance twice&#34;,):
                    pass

        self._web3_eth = web3.eth

        functions = self._web3_eth.contract(address=to_checksum_address(contract_address), abi=Timelock6h.abi()).functions
        self.SIGNATURES = SignatureGenerator(Timelock6h.abi())
        self._fn_grace_period = GracePeriodMethod(core_lib, contract_address, functions.GRACE_PERIOD)

        self._fn_maximum_delay = MaximumDelayMethod(core_lib, contract_address, functions.MAXIMUM_DELAY)

        self._fn_minimum_delay = MinimumDelayMethod(core_lib, contract_address, functions.MINIMUM_DELAY)

        self._fn_accept_admin = AcceptAdminMethod(core_lib, contract_address, functions.acceptAdmin)

        self._fn_admin = AdminMethod(core_lib, contract_address, functions.admin)

        self._fn_cancel_transaction = CancelTransactionMethod(core_lib, contract_address, functions.cancelTransaction, validator)

        self._fn_delay = DelayMethod(core_lib, contract_address, functions.delay)

        self._fn_execute_transaction = ExecuteTransactionMethod(core_lib, contract_address, functions.executeTransaction, validator)

        self._fn_pending_admin = PendingAdminMethod(core_lib, contract_address, functions.pendingAdmin)

        self._fn_queue_transaction = QueueTransactionMethod(core_lib, contract_address, functions.queueTransaction, validator)

        self._fn_queued_transactions = QueuedTransactionsMethod(core_lib, contract_address, functions.queuedTransactions, validator)

        self._fn_set_delay = SetDelayMethod(core_lib, contract_address, functions.setDelay, validator)

        self._fn_set_pending_admin = SetPendingAdminMethod(core_lib, contract_address, functions.setPendingAdmin, validator)

    def event_cancel_transaction(
            self, tx_hash: Union[HexBytes, bytes]
    ) -&gt; Tuple[AttributeDict]:
        &#34;&#34;&#34;
        Implementation of event cancel_transaction in contract Timelock6h
        Get log entry for CancelTransaction event.
                :param tx_hash: hash of transaction emitting CancelTransaction event
        &#34;&#34;&#34;
        tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
        return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.CancelTransaction().processReceipt(tx_receipt)

    def event_execute_transaction(
            self, tx_hash: Union[HexBytes, bytes]
    ) -&gt; Tuple[AttributeDict]:
        &#34;&#34;&#34;
        Implementation of event execute_transaction in contract Timelock6h
        Get log entry for ExecuteTransaction event.
                :param tx_hash: hash of transaction emitting ExecuteTransaction event
        &#34;&#34;&#34;
        tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
        return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.ExecuteTransaction().processReceipt(tx_receipt)

    def event_new_admin(
            self, tx_hash: Union[HexBytes, bytes]
    ) -&gt; Tuple[AttributeDict]:
        &#34;&#34;&#34;
        Implementation of event new_admin in contract Timelock6h
        Get log entry for NewAdmin event.
                :param tx_hash: hash of transaction emitting NewAdmin event
        &#34;&#34;&#34;
        tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
        return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.NewAdmin().processReceipt(tx_receipt)

    def event_new_delay(
            self, tx_hash: Union[HexBytes, bytes]
    ) -&gt; Tuple[AttributeDict]:
        &#34;&#34;&#34;
        Implementation of event new_delay in contract Timelock6h
        Get log entry for NewDelay event.
                :param tx_hash: hash of transaction emitting NewDelay event
        &#34;&#34;&#34;
        tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
        return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.NewDelay().processReceipt(tx_receipt)

    def event_new_pending_admin(
            self, tx_hash: Union[HexBytes, bytes]
    ) -&gt; Tuple[AttributeDict]:
        &#34;&#34;&#34;
        Implementation of event new_pending_admin in contract Timelock6h
        Get log entry for NewPendingAdmin event.
                :param tx_hash: hash of transaction emitting NewPendingAdmin event
        &#34;&#34;&#34;
        tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
        return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.NewPendingAdmin().processReceipt(tx_receipt)

    def event_queue_transaction(
            self, tx_hash: Union[HexBytes, bytes]
    ) -&gt; Tuple[AttributeDict]:
        &#34;&#34;&#34;
        Implementation of event queue_transaction in contract Timelock6h
        Get log entry for QueueTransaction event.
                :param tx_hash: hash of transaction emitting QueueTransaction event
        &#34;&#34;&#34;
        tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
        return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.QueueTransaction().processReceipt(tx_receipt)

    def grace_period(self) -&gt; int:
        &#34;&#34;&#34;
        Implementation of grace_period in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_grace_period.block_call()

    def maximum_delay(self) -&gt; int:
        &#34;&#34;&#34;
        Implementation of maximum_delay in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_maximum_delay.block_call()

    def minimum_delay(self) -&gt; int:
        &#34;&#34;&#34;
        Implementation of minimum_delay in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_minimum_delay.block_call()

    def accept_admin(self) -&gt; None:
        &#34;&#34;&#34;
        Implementation of accept_admin in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_accept_admin.block_send(self.call_contract_fee_amount, self.call_contract_fee_price, 0, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)

    def admin(self) -&gt; str:
        &#34;&#34;&#34;
        Implementation of admin in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_admin.block_call()

    def cancel_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) -&gt; None:
        &#34;&#34;&#34;
        Implementation of cancel_transaction in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_cancel_transaction.block_send(target, value, signature, data, eta, self.call_contract_fee_amount, self.call_contract_fee_price, 0, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)

    def delay(self) -&gt; int:
        &#34;&#34;&#34;
        Implementation of delay in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_delay.block_call()

    def execute_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, wei: int = 0) -&gt; Union[bytes, str]:
        &#34;&#34;&#34;
        Implementation of execute_transaction in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_execute_transaction.block_send(target, value, signature, data, eta, self.call_contract_fee_amount, self.call_contract_fee_price, wei, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)

    def pending_admin(self) -&gt; str:
        &#34;&#34;&#34;
        Implementation of pending_admin in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_pending_admin.block_call()

    def queue_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) -&gt; Union[bytes, str]:
        &#34;&#34;&#34;
        Implementation of queue_transaction in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_queue_transaction.block_send(target, value, signature, data, eta, self.call_contract_fee_amount, self.call_contract_fee_price, 0, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)

    def queued_transactions(self, index_0: Union[bytes, str]) -&gt; bool:
        &#34;&#34;&#34;
        Implementation of queued_transactions in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_queued_transactions.block_call(index_0)

    def set_delay(self, delay_: int) -&gt; None:
        &#34;&#34;&#34;
        Implementation of set_delay in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_set_delay.block_send(delay_, self.call_contract_fee_amount, self.call_contract_fee_price, 0, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)

    def set_pending_admin(self, pending_admin_: str) -&gt; None:
        &#34;&#34;&#34;
        Implementation of set_pending_admin in contract Timelock6h
        Method of the function



        &#34;&#34;&#34;

        return self._fn_set_pending_admin.block_send(pending_admin_, self.call_contract_fee_amount, self.call_contract_fee_price, 0, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)

    def CallContractWait(self, t_long: int) -&gt; &#34;Timelock6h&#34;:
        self._fn_grace_period.setWait(t_long)
        self._fn_maximum_delay.setWait(t_long)
        self._fn_minimum_delay.setWait(t_long)
        self._fn_accept_admin.setWait(t_long)
        self._fn_admin.setWait(t_long)
        self._fn_cancel_transaction.setWait(t_long)
        self._fn_delay.setWait(t_long)
        self._fn_execute_transaction.setWait(t_long)
        self._fn_pending_admin.setWait(t_long)
        self._fn_queue_transaction.setWait(t_long)
        self._fn_queued_transactions.setWait(t_long)
        self._fn_set_delay.setWait(t_long)
        self._fn_set_pending_admin.setWait(t_long)
        return self

    @staticmethod
    def abi():
        &#34;&#34;&#34;Return the ABI to the underlying contract.&#34;&#34;&#34;
        return json.loads(
            &#39;[{&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;admin_&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;delay_&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;constructor&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;bytes32&#34;,&#34;name&#34;:&#34;txHash&#34;,&#34;type&#34;:&#34;bytes32&#34;},{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;CancelTransaction&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;bytes32&#34;,&#34;name&#34;:&#34;txHash&#34;,&#34;type&#34;:&#34;bytes32&#34;},{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;ExecuteTransaction&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;newAdmin&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;name&#34;:&#34;NewAdmin&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;newDelay&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;NewDelay&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;newPendingAdmin&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;name&#34;:&#34;NewPendingAdmin&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;bytes32&#34;,&#34;name&#34;:&#34;txHash&#34;,&#34;type&#34;:&#34;bytes32&#34;},{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;QueueTransaction&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;payable&#34;:true,&#34;stateMutability&#34;:&#34;payable&#34;,&#34;type&#34;:&#34;fallback&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;GRACE_PERIOD&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;MAXIMUM_DELAY&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;MINIMUM_DELAY&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[],&#34;name&#34;:&#34;acceptAdmin&#34;,&#34;outputs&#34;:[],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;admin&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;cancelTransaction&#34;,&#34;outputs&#34;:[],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;delay&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;executeTransaction&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bytes&#34;}],&#34;payable&#34;:true,&#34;stateMutability&#34;:&#34;payable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;pendingAdmin&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;queueTransaction&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bytes32&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bytes32&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;bytes32&#34;,&#34;name&#34;:&#34;index_0&#34;,&#34;type&#34;:&#34;bytes32&#34;}],&#34;name&#34;:&#34;queuedTransactions&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;delay_&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;setDelay&#34;,&#34;outputs&#34;:[],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;pendingAdmin_&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;name&#34;:&#34;setPendingAdmin&#34;,&#34;outputs&#34;:[],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;}]&#39;
            # noqa: E501 (line-too-long)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractBase" href="../m/bases.html#moody.m.bases.ContractBase">ContractBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="moody.upgrades.Timelock6h.abi"><code class="name flex">
<span>def <span class="ident">abi</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the ABI to the underlying contract.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def abi():
    &#34;&#34;&#34;Return the ABI to the underlying contract.&#34;&#34;&#34;
    return json.loads(
        &#39;[{&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;admin_&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;delay_&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;constructor&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;bytes32&#34;,&#34;name&#34;:&#34;txHash&#34;,&#34;type&#34;:&#34;bytes32&#34;},{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;CancelTransaction&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;bytes32&#34;,&#34;name&#34;:&#34;txHash&#34;,&#34;type&#34;:&#34;bytes32&#34;},{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;ExecuteTransaction&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;newAdmin&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;name&#34;:&#34;NewAdmin&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;newDelay&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;NewDelay&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;newPendingAdmin&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;name&#34;:&#34;NewPendingAdmin&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;bytes32&#34;,&#34;name&#34;:&#34;txHash&#34;,&#34;type&#34;:&#34;bytes32&#34;},{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;QueueTransaction&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;payable&#34;:true,&#34;stateMutability&#34;:&#34;payable&#34;,&#34;type&#34;:&#34;fallback&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;GRACE_PERIOD&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;MAXIMUM_DELAY&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;MINIMUM_DELAY&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[],&#34;name&#34;:&#34;acceptAdmin&#34;,&#34;outputs&#34;:[],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;admin&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;cancelTransaction&#34;,&#34;outputs&#34;:[],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;delay&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;executeTransaction&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bytes&#34;}],&#34;payable&#34;:true,&#34;stateMutability&#34;:&#34;payable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;pendingAdmin&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;target&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;},{&#34;internalType&#34;:&#34;string&#34;,&#34;name&#34;:&#34;signature&#34;,&#34;type&#34;:&#34;string&#34;},{&#34;internalType&#34;:&#34;bytes&#34;,&#34;name&#34;:&#34;data&#34;,&#34;type&#34;:&#34;bytes&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;eta&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;queueTransaction&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bytes32&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bytes32&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;bytes32&#34;,&#34;name&#34;:&#34;index_0&#34;,&#34;type&#34;:&#34;bytes32&#34;}],&#34;name&#34;:&#34;queuedTransactions&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;delay_&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;setDelay&#34;,&#34;outputs&#34;:[],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;pendingAdmin_&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;name&#34;:&#34;setPendingAdmin&#34;,&#34;outputs&#34;:[],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;}]&#39;
        # noqa: E501 (line-too-long)
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="moody.upgrades.Timelock6h.CallContractWait"><code class="name flex">
<span>def <span class="ident">CallContractWait</span></span>(<span>self, t_long: int) ‑> <a title="moody.upgrades.Timelock6h" href="#moody.upgrades.Timelock6h">Timelock6h</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CallContractWait(self, t_long: int) -&gt; &#34;Timelock6h&#34;:
    self._fn_grace_period.setWait(t_long)
    self._fn_maximum_delay.setWait(t_long)
    self._fn_minimum_delay.setWait(t_long)
    self._fn_accept_admin.setWait(t_long)
    self._fn_admin.setWait(t_long)
    self._fn_cancel_transaction.setWait(t_long)
    self._fn_delay.setWait(t_long)
    self._fn_execute_transaction.setWait(t_long)
    self._fn_pending_admin.setWait(t_long)
    self._fn_queue_transaction.setWait(t_long)
    self._fn_queued_transactions.setWait(t_long)
    self._fn_set_delay.setWait(t_long)
    self._fn_set_pending_admin.setWait(t_long)
    return self</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.accept_admin"><code class="name flex">
<span>def <span class="ident">accept_admin</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of accept_admin in contract Timelock6h
Method of the function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accept_admin(self) -&gt; None:
    &#34;&#34;&#34;
    Implementation of accept_admin in contract Timelock6h
    Method of the function



    &#34;&#34;&#34;

    return self._fn_accept_admin.block_send(self.call_contract_fee_amount, self.call_contract_fee_price, 0, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.admin"><code class="name flex">
<span>def <span class="ident">admin</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of admin in contract Timelock6h
Method of the function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin(self) -&gt; str:
    &#34;&#34;&#34;
    Implementation of admin in contract Timelock6h
    Method of the function



    &#34;&#34;&#34;

    return self._fn_admin.block_call()</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.cancel_transaction"><code class="name flex">
<span>def <span class="ident">cancel_transaction</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of cancel_transaction in contract Timelock6h
Method of the function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) -&gt; None:
    &#34;&#34;&#34;
    Implementation of cancel_transaction in contract Timelock6h
    Method of the function



    &#34;&#34;&#34;

    return self._fn_cancel_transaction.block_send(target, value, signature, data, eta, self.call_contract_fee_amount, self.call_contract_fee_price, 0, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.delay"><code class="name flex">
<span>def <span class="ident">delay</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of delay in contract Timelock6h
Method of the function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delay(self) -&gt; int:
    &#34;&#34;&#34;
    Implementation of delay in contract Timelock6h
    Method of the function



    &#34;&#34;&#34;

    return self._fn_delay.block_call()</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.event_cancel_transaction"><code class="name flex">
<span>def <span class="ident">event_cancel_transaction</span></span>(<span>self, tx_hash: Union[hexbytes.main.HexBytes, bytes]) ‑> Tuple[web3.datastructures.AttributeDict]</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of event cancel_transaction in contract Timelock6h
Get log entry for CancelTransaction event.
:param tx_hash: hash of transaction emitting CancelTransaction event</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event_cancel_transaction(
        self, tx_hash: Union[HexBytes, bytes]
) -&gt; Tuple[AttributeDict]:
    &#34;&#34;&#34;
    Implementation of event cancel_transaction in contract Timelock6h
    Get log entry for CancelTransaction event.
            :param tx_hash: hash of transaction emitting CancelTransaction event
    &#34;&#34;&#34;
    tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
    return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.CancelTransaction().processReceipt(tx_receipt)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.event_execute_transaction"><code class="name flex">
<span>def <span class="ident">event_execute_transaction</span></span>(<span>self, tx_hash: Union[hexbytes.main.HexBytes, bytes]) ‑> Tuple[web3.datastructures.AttributeDict]</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of event execute_transaction in contract Timelock6h
Get log entry for ExecuteTransaction event.
:param tx_hash: hash of transaction emitting ExecuteTransaction event</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event_execute_transaction(
        self, tx_hash: Union[HexBytes, bytes]
) -&gt; Tuple[AttributeDict]:
    &#34;&#34;&#34;
    Implementation of event execute_transaction in contract Timelock6h
    Get log entry for ExecuteTransaction event.
            :param tx_hash: hash of transaction emitting ExecuteTransaction event
    &#34;&#34;&#34;
    tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
    return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.ExecuteTransaction().processReceipt(tx_receipt)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.event_new_admin"><code class="name flex">
<span>def <span class="ident">event_new_admin</span></span>(<span>self, tx_hash: Union[hexbytes.main.HexBytes, bytes]) ‑> Tuple[web3.datastructures.AttributeDict]</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of event new_admin in contract Timelock6h
Get log entry for NewAdmin event.
:param tx_hash: hash of transaction emitting NewAdmin event</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event_new_admin(
        self, tx_hash: Union[HexBytes, bytes]
) -&gt; Tuple[AttributeDict]:
    &#34;&#34;&#34;
    Implementation of event new_admin in contract Timelock6h
    Get log entry for NewAdmin event.
            :param tx_hash: hash of transaction emitting NewAdmin event
    &#34;&#34;&#34;
    tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
    return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.NewAdmin().processReceipt(tx_receipt)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.event_new_delay"><code class="name flex">
<span>def <span class="ident">event_new_delay</span></span>(<span>self, tx_hash: Union[hexbytes.main.HexBytes, bytes]) ‑> Tuple[web3.datastructures.AttributeDict]</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of event new_delay in contract Timelock6h
Get log entry for NewDelay event.
:param tx_hash: hash of transaction emitting NewDelay event</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event_new_delay(
        self, tx_hash: Union[HexBytes, bytes]
) -&gt; Tuple[AttributeDict]:
    &#34;&#34;&#34;
    Implementation of event new_delay in contract Timelock6h
    Get log entry for NewDelay event.
            :param tx_hash: hash of transaction emitting NewDelay event
    &#34;&#34;&#34;
    tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
    return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.NewDelay().processReceipt(tx_receipt)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.event_new_pending_admin"><code class="name flex">
<span>def <span class="ident">event_new_pending_admin</span></span>(<span>self, tx_hash: Union[hexbytes.main.HexBytes, bytes]) ‑> Tuple[web3.datastructures.AttributeDict]</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of event new_pending_admin in contract Timelock6h
Get log entry for NewPendingAdmin event.
:param tx_hash: hash of transaction emitting NewPendingAdmin event</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event_new_pending_admin(
        self, tx_hash: Union[HexBytes, bytes]
) -&gt; Tuple[AttributeDict]:
    &#34;&#34;&#34;
    Implementation of event new_pending_admin in contract Timelock6h
    Get log entry for NewPendingAdmin event.
            :param tx_hash: hash of transaction emitting NewPendingAdmin event
    &#34;&#34;&#34;
    tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
    return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.NewPendingAdmin().processReceipt(tx_receipt)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.event_queue_transaction"><code class="name flex">
<span>def <span class="ident">event_queue_transaction</span></span>(<span>self, tx_hash: Union[hexbytes.main.HexBytes, bytes]) ‑> Tuple[web3.datastructures.AttributeDict]</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of event queue_transaction in contract Timelock6h
Get log entry for QueueTransaction event.
:param tx_hash: hash of transaction emitting QueueTransaction event</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event_queue_transaction(
        self, tx_hash: Union[HexBytes, bytes]
) -&gt; Tuple[AttributeDict]:
    &#34;&#34;&#34;
    Implementation of event queue_transaction in contract Timelock6h
    Get log entry for QueueTransaction event.
            :param tx_hash: hash of transaction emitting QueueTransaction event
    &#34;&#34;&#34;
    tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
    return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=Timelock6h.abi()).events.QueueTransaction().processReceipt(tx_receipt)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.execute_transaction"><code class="name flex">
<span>def <span class="ident">execute_transaction</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, wei: int = 0) ‑> Union[bytes, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of execute_transaction in contract Timelock6h
Method of the function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int, wei: int = 0) -&gt; Union[bytes, str]:
    &#34;&#34;&#34;
    Implementation of execute_transaction in contract Timelock6h
    Method of the function



    &#34;&#34;&#34;

    return self._fn_execute_transaction.block_send(target, value, signature, data, eta, self.call_contract_fee_amount, self.call_contract_fee_price, wei, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.grace_period"><code class="name flex">
<span>def <span class="ident">grace_period</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of grace_period in contract Timelock6h
Method of the function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grace_period(self) -&gt; int:
    &#34;&#34;&#34;
    Implementation of grace_period in contract Timelock6h
    Method of the function



    &#34;&#34;&#34;

    return self._fn_grace_period.block_call()</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.maximum_delay"><code class="name flex">
<span>def <span class="ident">maximum_delay</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of maximum_delay in contract Timelock6h
Method of the function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maximum_delay(self) -&gt; int:
    &#34;&#34;&#34;
    Implementation of maximum_delay in contract Timelock6h
    Method of the function



    &#34;&#34;&#34;

    return self._fn_maximum_delay.block_call()</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.minimum_delay"><code class="name flex">
<span>def <span class="ident">minimum_delay</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of minimum_delay in contract Timelock6h
Method of the function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minimum_delay(self) -&gt; int:
    &#34;&#34;&#34;
    Implementation of minimum_delay in contract Timelock6h
    Method of the function



    &#34;&#34;&#34;

    return self._fn_minimum_delay.block_call()</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.pending_admin"><code class="name flex">
<span>def <span class="ident">pending_admin</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of pending_admin in contract Timelock6h
Method of the function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pending_admin(self) -&gt; str:
    &#34;&#34;&#34;
    Implementation of pending_admin in contract Timelock6h
    Method of the function



    &#34;&#34;&#34;

    return self._fn_pending_admin.block_call()</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.queue_transaction"><code class="name flex">
<span>def <span class="ident">queue_transaction</span></span>(<span>self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) ‑> Union[bytes, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of queue_transaction in contract Timelock6h
Method of the function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queue_transaction(self, target: str, value: int, signature: str, data: Union[bytes, str], eta: int) -&gt; Union[bytes, str]:
    &#34;&#34;&#34;
    Implementation of queue_transaction in contract Timelock6h
    Method of the function



    &#34;&#34;&#34;

    return self._fn_queue_transaction.block_send(target, value, signature, data, eta, self.call_contract_fee_amount, self.call_contract_fee_price, 0, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.queued_transactions"><code class="name flex">
<span>def <span class="ident">queued_transactions</span></span>(<span>self, index_0: Union[bytes, str]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of queued_transactions in contract Timelock6h
Method of the function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queued_transactions(self, index_0: Union[bytes, str]) -&gt; bool:
    &#34;&#34;&#34;
    Implementation of queued_transactions in contract Timelock6h
    Method of the function



    &#34;&#34;&#34;

    return self._fn_queued_transactions.block_call(index_0)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.set_delay"><code class="name flex">
<span>def <span class="ident">set_delay</span></span>(<span>self, delay_: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of set_delay in contract Timelock6h
Method of the function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_delay(self, delay_: int) -&gt; None:
    &#34;&#34;&#34;
    Implementation of set_delay in contract Timelock6h
    Method of the function



    &#34;&#34;&#34;

    return self._fn_set_delay.block_send(delay_, self.call_contract_fee_amount, self.call_contract_fee_price, 0, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)</code></pre>
</details>
</dd>
<dt id="moody.upgrades.Timelock6h.set_pending_admin"><code class="name flex">
<span>def <span class="ident">set_pending_admin</span></span>(<span>self, pending_admin_: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of set_pending_admin in contract Timelock6h
Method of the function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pending_admin(self, pending_admin_: str) -&gt; None:
    &#34;&#34;&#34;
    Implementation of set_pending_admin in contract Timelock6h
    Method of the function



    &#34;&#34;&#34;

    return self._fn_set_pending_admin.block_send(pending_admin_, self.call_contract_fee_amount, self.call_contract_fee_price, 0, self.call_contract_debug_flag, self.call_contract_enforce_tx_receipt)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="moody.upgrades.Timelock6hValidator"><code class="flex name class">
<span>class <span class="ident">Timelock6hValidator</span></span>
<span>(</span><span>web3_or_provider: web3.main.Web3, contract_address: str)</span>
</code></dt>
<dd>
<div class="desc"><p>No-op input validator.</p>
<p>Initialize the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Timelock6hValidator(  # type: ignore
    Validator
):
    &#34;&#34;&#34;No-op input validator.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.Validator" href="../m/bases.html#moody.m.bases.Validator">Validator</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.Validator" href="../m/bases.html#moody.m.bases.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.Validator.assert_valid" href="../m/bases.html#moody.m.bases.Validator.assert_valid">assert_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="moody" href="../index.html">moody</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="moody.upgrades.Token" href="Token.html">moody.upgrades.Token</a></code></li>
<li><code><a title="moody.upgrades.proxy" href="proxy.html">moody.upgrades.proxy</a></code></li>
<li><code><a title="moody.upgrades.timelocker" href="timelocker.html">moody.upgrades.timelocker</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="moody.upgrades.AcceptAdminMethod" href="#moody.upgrades.AcceptAdminMethod">AcceptAdminMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.upgrades.AcceptAdminMethod.block_send" href="#moody.upgrades.AcceptAdminMethod.block_send">block_send</a></code></li>
<li><code><a title="moody.upgrades.AcceptAdminMethod.build_transaction" href="#moody.upgrades.AcceptAdminMethod.build_transaction">build_transaction</a></code></li>
<li><code><a title="moody.upgrades.AcceptAdminMethod.estimate_gas" href="#moody.upgrades.AcceptAdminMethod.estimate_gas">estimate_gas</a></code></li>
<li><code><a title="moody.upgrades.AcceptAdminMethod.send_transaction" href="#moody.upgrades.AcceptAdminMethod.send_transaction">send_transaction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.upgrades.AdminMethod" href="#moody.upgrades.AdminMethod">AdminMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.upgrades.AdminMethod.block_call" href="#moody.upgrades.AdminMethod.block_call">block_call</a></code></li>
<li><code><a title="moody.upgrades.AdminMethod.estimate_gas" href="#moody.upgrades.AdminMethod.estimate_gas">estimate_gas</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.upgrades.CancelTransactionMethod" href="#moody.upgrades.CancelTransactionMethod">CancelTransactionMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.upgrades.CancelTransactionMethod.block_send" href="#moody.upgrades.CancelTransactionMethod.block_send">block_send</a></code></li>
<li><code><a title="moody.upgrades.CancelTransactionMethod.build_transaction" href="#moody.upgrades.CancelTransactionMethod.build_transaction">build_transaction</a></code></li>
<li><code><a title="moody.upgrades.CancelTransactionMethod.estimate_gas" href="#moody.upgrades.CancelTransactionMethod.estimate_gas">estimate_gas</a></code></li>
<li><code><a title="moody.upgrades.CancelTransactionMethod.send_transaction" href="#moody.upgrades.CancelTransactionMethod.send_transaction">send_transaction</a></code></li>
<li><code><a title="moody.upgrades.CancelTransactionMethod.validate_and_normalize_inputs" href="#moody.upgrades.CancelTransactionMethod.validate_and_normalize_inputs">validate_and_normalize_inputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.upgrades.DelayMethod" href="#moody.upgrades.DelayMethod">DelayMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.upgrades.DelayMethod.block_call" href="#moody.upgrades.DelayMethod.block_call">block_call</a></code></li>
<li><code><a title="moody.upgrades.DelayMethod.estimate_gas" href="#moody.upgrades.DelayMethod.estimate_gas">estimate_gas</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.upgrades.ExecuteTransactionMethod" href="#moody.upgrades.ExecuteTransactionMethod">ExecuteTransactionMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.upgrades.ExecuteTransactionMethod.block_send" href="#moody.upgrades.ExecuteTransactionMethod.block_send">block_send</a></code></li>
<li><code><a title="moody.upgrades.ExecuteTransactionMethod.build_transaction" href="#moody.upgrades.ExecuteTransactionMethod.build_transaction">build_transaction</a></code></li>
<li><code><a title="moody.upgrades.ExecuteTransactionMethod.estimate_gas" href="#moody.upgrades.ExecuteTransactionMethod.estimate_gas">estimate_gas</a></code></li>
<li><code><a title="moody.upgrades.ExecuteTransactionMethod.send_transaction" href="#moody.upgrades.ExecuteTransactionMethod.send_transaction">send_transaction</a></code></li>
<li><code><a title="moody.upgrades.ExecuteTransactionMethod.validate_and_normalize_inputs" href="#moody.upgrades.ExecuteTransactionMethod.validate_and_normalize_inputs">validate_and_normalize_inputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.upgrades.GracePeriodMethod" href="#moody.upgrades.GracePeriodMethod">GracePeriodMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.upgrades.GracePeriodMethod.block_call" href="#moody.upgrades.GracePeriodMethod.block_call">block_call</a></code></li>
<li><code><a title="moody.upgrades.GracePeriodMethod.estimate_gas" href="#moody.upgrades.GracePeriodMethod.estimate_gas">estimate_gas</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.upgrades.MaximumDelayMethod" href="#moody.upgrades.MaximumDelayMethod">MaximumDelayMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.upgrades.MaximumDelayMethod.block_call" href="#moody.upgrades.MaximumDelayMethod.block_call">block_call</a></code></li>
<li><code><a title="moody.upgrades.MaximumDelayMethod.estimate_gas" href="#moody.upgrades.MaximumDelayMethod.estimate_gas">estimate_gas</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.upgrades.MinimumDelayMethod" href="#moody.upgrades.MinimumDelayMethod">MinimumDelayMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.upgrades.MinimumDelayMethod.block_call" href="#moody.upgrades.MinimumDelayMethod.block_call">block_call</a></code></li>
<li><code><a title="moody.upgrades.MinimumDelayMethod.estimate_gas" href="#moody.upgrades.MinimumDelayMethod.estimate_gas">estimate_gas</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.upgrades.PendingAdminMethod" href="#moody.upgrades.PendingAdminMethod">PendingAdminMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.upgrades.PendingAdminMethod.block_call" href="#moody.upgrades.PendingAdminMethod.block_call">block_call</a></code></li>
<li><code><a title="moody.upgrades.PendingAdminMethod.estimate_gas" href="#moody.upgrades.PendingAdminMethod.estimate_gas">estimate_gas</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.upgrades.QueueTransactionMethod" href="#moody.upgrades.QueueTransactionMethod">QueueTransactionMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.upgrades.QueueTransactionMethod.block_send" href="#moody.upgrades.QueueTransactionMethod.block_send">block_send</a></code></li>
<li><code><a title="moody.upgrades.QueueTransactionMethod.build_transaction" href="#moody.upgrades.QueueTransactionMethod.build_transaction">build_transaction</a></code></li>
<li><code><a title="moody.upgrades.QueueTransactionMethod.estimate_gas" href="#moody.upgrades.QueueTransactionMethod.estimate_gas">estimate_gas</a></code></li>
<li><code><a title="moody.upgrades.QueueTransactionMethod.send_transaction" href="#moody.upgrades.QueueTransactionMethod.send_transaction">send_transaction</a></code></li>
<li><code><a title="moody.upgrades.QueueTransactionMethod.validate_and_normalize_inputs" href="#moody.upgrades.QueueTransactionMethod.validate_and_normalize_inputs">validate_and_normalize_inputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.upgrades.QueuedTransactionsMethod" href="#moody.upgrades.QueuedTransactionsMethod">QueuedTransactionsMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.upgrades.QueuedTransactionsMethod.block_call" href="#moody.upgrades.QueuedTransactionsMethod.block_call">block_call</a></code></li>
<li><code><a title="moody.upgrades.QueuedTransactionsMethod.estimate_gas" href="#moody.upgrades.QueuedTransactionsMethod.estimate_gas">estimate_gas</a></code></li>
<li><code><a title="moody.upgrades.QueuedTransactionsMethod.validate_and_normalize_inputs" href="#moody.upgrades.QueuedTransactionsMethod.validate_and_normalize_inputs">validate_and_normalize_inputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.upgrades.SetDelayMethod" href="#moody.upgrades.SetDelayMethod">SetDelayMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.upgrades.SetDelayMethod.block_send" href="#moody.upgrades.SetDelayMethod.block_send">block_send</a></code></li>
<li><code><a title="moody.upgrades.SetDelayMethod.build_transaction" href="#moody.upgrades.SetDelayMethod.build_transaction">build_transaction</a></code></li>
<li><code><a title="moody.upgrades.SetDelayMethod.estimate_gas" href="#moody.upgrades.SetDelayMethod.estimate_gas">estimate_gas</a></code></li>
<li><code><a title="moody.upgrades.SetDelayMethod.send_transaction" href="#moody.upgrades.SetDelayMethod.send_transaction">send_transaction</a></code></li>
<li><code><a title="moody.upgrades.SetDelayMethod.validate_and_normalize_inputs" href="#moody.upgrades.SetDelayMethod.validate_and_normalize_inputs">validate_and_normalize_inputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.upgrades.SetPendingAdminMethod" href="#moody.upgrades.SetPendingAdminMethod">SetPendingAdminMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.upgrades.SetPendingAdminMethod.block_send" href="#moody.upgrades.SetPendingAdminMethod.block_send">block_send</a></code></li>
<li><code><a title="moody.upgrades.SetPendingAdminMethod.build_transaction" href="#moody.upgrades.SetPendingAdminMethod.build_transaction">build_transaction</a></code></li>
<li><code><a title="moody.upgrades.SetPendingAdminMethod.estimate_gas" href="#moody.upgrades.SetPendingAdminMethod.estimate_gas">estimate_gas</a></code></li>
<li><code><a title="moody.upgrades.SetPendingAdminMethod.send_transaction" href="#moody.upgrades.SetPendingAdminMethod.send_transaction">send_transaction</a></code></li>
<li><code><a title="moody.upgrades.SetPendingAdminMethod.validate_and_normalize_inputs" href="#moody.upgrades.SetPendingAdminMethod.validate_and_normalize_inputs">validate_and_normalize_inputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.upgrades.SignatureGenerator" href="#moody.upgrades.SignatureGenerator">SignatureGenerator</a></code></h4>
<ul class="two-column">
<li><code><a title="moody.upgrades.SignatureGenerator.accept_admin" href="#moody.upgrades.SignatureGenerator.accept_admin">accept_admin</a></code></li>
<li><code><a title="moody.upgrades.SignatureGenerator.admin" href="#moody.upgrades.SignatureGenerator.admin">admin</a></code></li>
<li><code><a title="moody.upgrades.SignatureGenerator.cancel_transaction" href="#moody.upgrades.SignatureGenerator.cancel_transaction">cancel_transaction</a></code></li>
<li><code><a title="moody.upgrades.SignatureGenerator.delay" href="#moody.upgrades.SignatureGenerator.delay">delay</a></code></li>
<li><code><a title="moody.upgrades.SignatureGenerator.execute_transaction" href="#moody.upgrades.SignatureGenerator.execute_transaction">execute_transaction</a></code></li>
<li><code><a title="moody.upgrades.SignatureGenerator.grace_period" href="#moody.upgrades.SignatureGenerator.grace_period">grace_period</a></code></li>
<li><code><a title="moody.upgrades.SignatureGenerator.maximum_delay" href="#moody.upgrades.SignatureGenerator.maximum_delay">maximum_delay</a></code></li>
<li><code><a title="moody.upgrades.SignatureGenerator.minimum_delay" href="#moody.upgrades.SignatureGenerator.minimum_delay">minimum_delay</a></code></li>
<li><code><a title="moody.upgrades.SignatureGenerator.pending_admin" href="#moody.upgrades.SignatureGenerator.pending_admin">pending_admin</a></code></li>
<li><code><a title="moody.upgrades.SignatureGenerator.queue_transaction" href="#moody.upgrades.SignatureGenerator.queue_transaction">queue_transaction</a></code></li>
<li><code><a title="moody.upgrades.SignatureGenerator.queued_transactions" href="#moody.upgrades.SignatureGenerator.queued_transactions">queued_transactions</a></code></li>
<li><code><a title="moody.upgrades.SignatureGenerator.set_delay" href="#moody.upgrades.SignatureGenerator.set_delay">set_delay</a></code></li>
<li><code><a title="moody.upgrades.SignatureGenerator.set_pending_admin" href="#moody.upgrades.SignatureGenerator.set_pending_admin">set_pending_admin</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.upgrades.Timelock6h" href="#moody.upgrades.Timelock6h">Timelock6h</a></code></h4>
<ul class="">
<li><code><a title="moody.upgrades.Timelock6h.CallContractWait" href="#moody.upgrades.Timelock6h.CallContractWait">CallContractWait</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.abi" href="#moody.upgrades.Timelock6h.abi">abi</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.accept_admin" href="#moody.upgrades.Timelock6h.accept_admin">accept_admin</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.admin" href="#moody.upgrades.Timelock6h.admin">admin</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.cancel_transaction" href="#moody.upgrades.Timelock6h.cancel_transaction">cancel_transaction</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.delay" href="#moody.upgrades.Timelock6h.delay">delay</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.event_cancel_transaction" href="#moody.upgrades.Timelock6h.event_cancel_transaction">event_cancel_transaction</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.event_execute_transaction" href="#moody.upgrades.Timelock6h.event_execute_transaction">event_execute_transaction</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.event_new_admin" href="#moody.upgrades.Timelock6h.event_new_admin">event_new_admin</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.event_new_delay" href="#moody.upgrades.Timelock6h.event_new_delay">event_new_delay</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.event_new_pending_admin" href="#moody.upgrades.Timelock6h.event_new_pending_admin">event_new_pending_admin</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.event_queue_transaction" href="#moody.upgrades.Timelock6h.event_queue_transaction">event_queue_transaction</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.execute_transaction" href="#moody.upgrades.Timelock6h.execute_transaction">execute_transaction</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.grace_period" href="#moody.upgrades.Timelock6h.grace_period">grace_period</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.maximum_delay" href="#moody.upgrades.Timelock6h.maximum_delay">maximum_delay</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.minimum_delay" href="#moody.upgrades.Timelock6h.minimum_delay">minimum_delay</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.pending_admin" href="#moody.upgrades.Timelock6h.pending_admin">pending_admin</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.queue_transaction" href="#moody.upgrades.Timelock6h.queue_transaction">queue_transaction</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.queued_transactions" href="#moody.upgrades.Timelock6h.queued_transactions">queued_transactions</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.set_delay" href="#moody.upgrades.Timelock6h.set_delay">set_delay</a></code></li>
<li><code><a title="moody.upgrades.Timelock6h.set_pending_admin" href="#moody.upgrades.Timelock6h.set_pending_admin">set_pending_admin</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.upgrades.Timelock6hValidator" href="#moody.upgrades.Timelock6hValidator">Timelock6hValidator</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>