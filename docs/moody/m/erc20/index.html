<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>moody.m.erc20 API documentation</title>
<meta name="description" content="Generated wrapper for ERC20 Solidity contract." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>moody.m.erc20</code></h1>
</header>
<section id="section-intro">
<p>Generated wrapper for ERC20 Solidity contract.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Generated wrapper for ERC20 Solidity contract.&#34;&#34;&#34;

# pylint: disable=too-many-arguments

import json
from typing import (  # pylint: disable=unused-import
    Any,
    List,
    Optional,
    Tuple,
    Union,
)

from eth_utils import to_checksum_address
from mypy_extensions import TypedDict  # pylint: disable=unused-import
from hexbytes import HexBytes
from web3 import Web3
from web3.contract import ContractFunction
from web3.datastructures import AttributeDict
from web3.providers.base import BaseProvider

from ..bases import ContractMethod, Validator
from ..tx_params import TxParams


# Try to import a custom validator class definition; if there isn&#39;t one,
# declare one that we can instantiate for the default argument to the
# constructor for ERC20 below.
try:
    # both mypy and pylint complain about what we&#39;re doing here, but this
    # works just fine, so their messages have been disabled here.
    from . import (  # type: ignore # pylint: disable=import-self
        ERC20Validator,
    )
except ImportError:

    class ERC20Validator(  # type: ignore
        Validator
    ):
        &#34;&#34;&#34;No-op input validator.&#34;&#34;&#34;

try:
    from .middleware import MIDDLEWARE  # type: ignore
except ImportError:
    pass





class AllowanceMethod(ContractMethod): # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the allowance method.&#34;&#34;&#34;

    def __init__(self, web3_or_provider: Union[Web3, BaseProvider], contract_address: str, contract_function: ContractFunction, validator: Validator=None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(web3_or_provider, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, owner: str, spender: str):
        &#34;&#34;&#34;Validate the inputs to the allowance method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;allowance&#39;,
            parameter_name=&#39;owner&#39;,
            argument_value=owner,
        )
        owner = self.validate_and_checksum_address(owner)
        self.validator.assert_valid(
            method_name=&#39;allowance&#39;,
            parameter_name=&#39;spender&#39;,
            argument_value=spender,
        )
        spender = self.validate_and_checksum_address(spender)
        return (owner, spender)


    def block_call(self, owner: str, spender: str, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; int:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters

        &#34;&#34;&#34;
        (owner, spender) = self.validate_and_normalize_inputs(owner, spender)

        tx_params: Optional[TxParams] = None
        tx_params = super().normalize_tx_params(tx_params)
        returned = self._underlying_method(owner, spender).call(tx_params.as_dict())
        return int(returned)

    def estimate_gas(self, owner: str, spender: str, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (owner, spender) = self.validate_and_normalize_inputs(owner, spender)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(owner, spender).estimateGas(tx_params.as_dict())

class ApproveMethod(ContractMethod): # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the approve method.&#34;&#34;&#34;

    def __init__(self, web3_or_provider: Union[Web3, BaseProvider], contract_address: str, contract_function: ContractFunction, validator: Validator=None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(web3_or_provider, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, spender: str, amount: int):
        &#34;&#34;&#34;Validate the inputs to the approve method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;approve&#39;,
            parameter_name=&#39;spender&#39;,
            argument_value=spender,
        )
        spender = self.validate_and_checksum_address(spender)
        self.validator.assert_valid(
            method_name=&#39;approve&#39;,
            parameter_name=&#39;amount&#39;,
            argument_value=amount,
        )
        # safeguard against fractional inputs
        amount = int(amount)
        return (spender, amount)


    def block_call(self, spender: str, amount: int, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        (spender, amount) = self.validate_and_normalize_inputs(spender, amount)

        tx_params: Optional[TxParams] = None
        tx_params = super().normalize_tx_params(tx_params)
        returned = self._underlying_method(spender, amount).call(tx_params.as_dict())
        return bool(returned)

    def send_transaction(self, spender: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (spender, amount) = self.validate_and_normalize_inputs(spender, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, amount).transact(tx_params.as_dict())

    def build_transaction(self, spender: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (spender, amount) = self.validate_and_normalize_inputs(spender, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, amount).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, spender: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (spender, amount) = self.validate_and_normalize_inputs(spender, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, amount).estimateGas(tx_params.as_dict())

class BalanceOfMethod(ContractMethod): # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the balanceOf method.&#34;&#34;&#34;

    def __init__(self, web3_or_provider: Union[Web3, BaseProvider], contract_address: str, contract_function: ContractFunction, validator: Validator=None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(web3_or_provider, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, account: str):
        &#34;&#34;&#34;Validate the inputs to the balanceOf method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;balanceOf&#39;,
            parameter_name=&#39;account&#39;,
            argument_value=account,
        )
        account = self.validate_and_checksum_address(account)
        return (account)


    def block_call(self, account: str, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; int:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters

        &#34;&#34;&#34;
        (account) = self.validate_and_normalize_inputs(account)

        tx_params: Optional[TxParams] = None
        tx_params = super().normalize_tx_params(tx_params)
        returned = self._underlying_method(account).call(tx_params.as_dict())
        return int(returned)

    def estimate_gas(self, account: str, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (account) = self.validate_and_normalize_inputs(account)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(account).estimateGas(tx_params.as_dict())

class DecreaseAllowanceMethod(ContractMethod): # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the decreaseAllowance method.&#34;&#34;&#34;

    def __init__(self, web3_or_provider: Union[Web3, BaseProvider], contract_address: str, contract_function: ContractFunction, validator: Validator=None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(web3_or_provider, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, spender: str, subtracted_value: int):
        &#34;&#34;&#34;Validate the inputs to the decreaseAllowance method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;decreaseAllowance&#39;,
            parameter_name=&#39;spender&#39;,
            argument_value=spender,
        )
        spender = self.validate_and_checksum_address(spender)
        self.validator.assert_valid(
            method_name=&#39;decreaseAllowance&#39;,
            parameter_name=&#39;subtractedValue&#39;,
            argument_value=subtracted_value,
        )
        # safeguard against fractional inputs
        subtracted_value = int(subtracted_value)
        return (spender, subtracted_value)


    def block_call(self, spender: str, subtracted_value: int, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        (spender, subtracted_value) = self.validate_and_normalize_inputs(spender, subtracted_value)

        tx_params: Optional[TxParams] = None
        tx_params = super().normalize_tx_params(tx_params)
        returned = self._underlying_method(spender, subtracted_value).call(tx_params.as_dict())
        return bool(returned)

    def send_transaction(self, spender: str, subtracted_value: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (spender, subtracted_value) = self.validate_and_normalize_inputs(spender, subtracted_value)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, subtracted_value).transact(tx_params.as_dict())

    def build_transaction(self, spender: str, subtracted_value: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (spender, subtracted_value) = self.validate_and_normalize_inputs(spender, subtracted_value)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, subtracted_value).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, spender: str, subtracted_value: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (spender, subtracted_value) = self.validate_and_normalize_inputs(spender, subtracted_value)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, subtracted_value).estimateGas(tx_params.as_dict())

class IncreaseAllowanceMethod(ContractMethod): # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the increaseAllowance method.&#34;&#34;&#34;

    def __init__(self, web3_or_provider: Union[Web3, BaseProvider], contract_address: str, contract_function: ContractFunction, validator: Validator=None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(web3_or_provider, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, spender: str, added_value: int):
        &#34;&#34;&#34;Validate the inputs to the increaseAllowance method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;increaseAllowance&#39;,
            parameter_name=&#39;spender&#39;,
            argument_value=spender,
        )
        spender = self.validate_and_checksum_address(spender)
        self.validator.assert_valid(
            method_name=&#39;increaseAllowance&#39;,
            parameter_name=&#39;addedValue&#39;,
            argument_value=added_value,
        )
        # safeguard against fractional inputs
        added_value = int(added_value)
        return (spender, added_value)


    def block_call(self, spender: str, added_value: int, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        (spender, added_value) = self.validate_and_normalize_inputs(spender, added_value)

        tx_params: Optional[TxParams] = None
        tx_params = super().normalize_tx_params(tx_params)
        returned = self._underlying_method(spender, added_value).call(tx_params.as_dict())
        return bool(returned)

    def send_transaction(self, spender: str, added_value: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (spender, added_value) = self.validate_and_normalize_inputs(spender, added_value)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, added_value).transact(tx_params.as_dict())

    def build_transaction(self, spender: str, added_value: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (spender, added_value) = self.validate_and_normalize_inputs(spender, added_value)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, added_value).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, spender: str, added_value: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (spender, added_value) = self.validate_and_normalize_inputs(spender, added_value)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, added_value).estimateGas(tx_params.as_dict())

class TotalSupplyMethod(ContractMethod): # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the totalSupply method.&#34;&#34;&#34;

    def __init__(self, web3_or_provider: Union[Web3, BaseProvider], contract_address: str, contract_function: ContractFunction):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(web3_or_provider, contract_address)
        self._underlying_method = contract_function


    def block_call(self, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; int:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters

        &#34;&#34;&#34;

        tx_params: Optional[TxParams] = None
        tx_params = super().normalize_tx_params(tx_params)
        returned = self._underlying_method().call(tx_params.as_dict())
        return int(returned)

    def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().estimateGas(tx_params.as_dict())

class TransferMethod(ContractMethod): # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the transfer method.&#34;&#34;&#34;

    def __init__(self, web3_or_provider: Union[Web3, BaseProvider], contract_address: str, contract_function: ContractFunction, validator: Validator=None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(web3_or_provider, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, recipient: str, amount: int):
        &#34;&#34;&#34;Validate the inputs to the transfer method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;transfer&#39;,
            parameter_name=&#39;recipient&#39;,
            argument_value=recipient,
        )
        recipient = self.validate_and_checksum_address(recipient)
        self.validator.assert_valid(
            method_name=&#39;transfer&#39;,
            parameter_name=&#39;amount&#39;,
            argument_value=amount,
        )
        # safeguard against fractional inputs
        amount = int(amount)
        return (recipient, amount)


    def block_call(self, recipient: str, amount: int, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        (recipient, amount) = self.validate_and_normalize_inputs(recipient, amount)

        tx_params: Optional[TxParams] = None
        tx_params = super().normalize_tx_params(tx_params)
        returned = self._underlying_method(recipient, amount).call(tx_params.as_dict())
        return bool(returned)

    def send_transaction(self, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (recipient, amount) = self.validate_and_normalize_inputs(recipient, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(recipient, amount).transact(tx_params.as_dict())

    def build_transaction(self, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (recipient, amount) = self.validate_and_normalize_inputs(recipient, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(recipient, amount).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (recipient, amount) = self.validate_and_normalize_inputs(recipient, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(recipient, amount).estimateGas(tx_params.as_dict())

class TransferFromMethod(ContractMethod): # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the transferFrom method.&#34;&#34;&#34;

    def __init__(self, web3_or_provider: Union[Web3, BaseProvider], contract_address: str, contract_function: ContractFunction, validator: Validator=None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(web3_or_provider, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, sender: str, recipient: str, amount: int):
        &#34;&#34;&#34;Validate the inputs to the transferFrom method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;transferFrom&#39;,
            parameter_name=&#39;sender&#39;,
            argument_value=sender,
        )
        sender = self.validate_and_checksum_address(sender)
        self.validator.assert_valid(
            method_name=&#39;transferFrom&#39;,
            parameter_name=&#39;recipient&#39;,
            argument_value=recipient,
        )
        recipient = self.validate_and_checksum_address(recipient)
        self.validator.assert_valid(
            method_name=&#39;transferFrom&#39;,
            parameter_name=&#39;amount&#39;,
            argument_value=amount,
        )
        # safeguard against fractional inputs
        amount = int(amount)
        return (sender, recipient, amount)


    def block_call(self, sender: str, recipient: str, amount: int, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        (sender, recipient, amount) = self.validate_and_normalize_inputs(sender, recipient, amount)

        tx_params: Optional[TxParams] = None
        tx_params = super().normalize_tx_params(tx_params)
        returned = self._underlying_method(sender, recipient, amount).call(tx_params.as_dict())
        return bool(returned)

    def send_transaction(self, sender: str, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (sender, recipient, amount) = self.validate_and_normalize_inputs(sender, recipient, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(sender, recipient, amount).transact(tx_params.as_dict())

    def build_transaction(self, sender: str, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (sender, recipient, amount) = self.validate_and_normalize_inputs(sender, recipient, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(sender, recipient, amount).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, sender: str, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (sender, recipient, amount) = self.validate_and_normalize_inputs(sender, recipient, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(sender, recipient, amount).estimateGas(tx_params.as_dict())

# pylint: disable=too-many-public-methods,too-many-instance-attributes
class ERC20:
    &#34;&#34;&#34;Wrapper class for ERC20 Solidity contract.&#34;&#34;&#34;
    _fn_allowance: AllowanceMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`AllowanceMethod`.
    &#34;&#34;&#34;

    _fn_approve: ApproveMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`ApproveMethod`.
    &#34;&#34;&#34;

    _fn_balance_of: BalanceOfMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`BalanceOfMethod`.
    &#34;&#34;&#34;

    _fn_decrease_allowance: DecreaseAllowanceMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`DecreaseAllowanceMethod`.
    &#34;&#34;&#34;

    _fn_increase_allowance: IncreaseAllowanceMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`IncreaseAllowanceMethod`.
    &#34;&#34;&#34;

    _fn_total_supply: TotalSupplyMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`TotalSupplyMethod`.
    &#34;&#34;&#34;

    _fn_transfer: TransferMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`TransferMethod`.
    &#34;&#34;&#34;

    _fn_transfer_from: TransferFromMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`TransferFromMethod`.
    &#34;&#34;&#34;


    def __init__(
        self,
        web3_or_provider: Union[Web3, BaseProvider],
        contract_address: str,
        validator: ERC20Validator = None,
    ):
        &#34;&#34;&#34;Get an instance of wrapper for smart contract.

        :param web3_or_provider: Either an instance of `web3.Web3`:code: or
            `web3.providers.base.BaseProvider`:code:
        :param contract_address: where the contract has been deployed
        :param validator: for validation of method inputs.
        &#34;&#34;&#34;
        # pylint: disable=too-many-statements

        self.contract_address = contract_address

        if not validator:
            validator = ERC20Validator(web3_or_provider, contract_address)

        web3 = None
        if isinstance(web3_or_provider, BaseProvider):
            web3 = Web3(web3_or_provider)
        elif isinstance(web3_or_provider, Web3):
            web3 = web3_or_provider
        else:
            raise TypeError(
                &#34;Expected parameter &#39;web3_or_provider&#39; to be an instance of either&#34;
                + &#34; Web3 or BaseProvider&#34;
            )

        # if any middleware was imported, inject it
        try:
            MIDDLEWARE
        except NameError:
            pass
        else:
            try:
                for middleware in MIDDLEWARE:
                    web3.middleware_onion.inject(
                         middleware[&#39;function&#39;], layer=middleware[&#39;layer&#39;],
                    )
            except ValueError as value_error:
                if value_error.args == (&#34;You can&#39;t add the same un-named instance twice&#34;,):
                    pass

        self._web3_eth = web3.eth

        functions = self._web3_eth.contract(address=to_checksum_address(contract_address), abi=ERC20.abi()).functions

        self.call_contract_fee_amount:int = 1000000
        self.call_contract_debug_flag:bool = False

        self._fn_allowance = AllowanceMethod(web3_or_provider, contract_address, functions.allowance, validator)

        self._fn_approve = ApproveMethod(web3_or_provider, contract_address, functions.approve, validator)

        self._fn_balance_of = BalanceOfMethod(web3_or_provider, contract_address, functions.balanceOf, validator)

        self._fn_decrease_allowance = DecreaseAllowanceMethod(web3_or_provider, contract_address, functions.decreaseAllowance, validator)

        self._fn_increase_allowance = IncreaseAllowanceMethod(web3_or_provider, contract_address, functions.increaseAllowance, validator)

        self._fn_total_supply = TotalSupplyMethod(web3_or_provider, contract_address, functions.totalSupply)

        self._fn_transfer = TransferMethod(web3_or_provider, contract_address, functions.transfer, validator)

        self._fn_transfer_from = TransferFromMethod(web3_or_provider, contract_address, functions.transferFrom, validator)


    &#34;&#34;&#34;
    Implementation of event approval in contract ERC20
    Get log entry for Approval event.
            :param tx_hash: hash of transaction emitting Approval event
    &#34;&#34;&#34;
    
    def event_approval(
            self, tx_hash: Union[HexBytes, bytes]
    ) -&gt; Tuple[AttributeDict]:
        tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
        return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=ERC20.abi()).events.Approval().processReceipt(tx_receipt)
    &#34;&#34;&#34;
    Implementation of event transfer in contract ERC20
    Get log entry for Transfer event.
            :param tx_hash: hash of transaction emitting Transfer event
    &#34;&#34;&#34;
    
    def event_transfer(
            self, tx_hash: Union[HexBytes, bytes]
    ) -&gt; Tuple[AttributeDict]:
        tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
        return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=ERC20.abi()).events.Transfer().processReceipt(tx_receipt)



    
    &#34;&#34;&#34;
    implementation of allowance in contract ERC20
    
    &#34;&#34;&#34;
    
    def allowance(self,owner: str, spender: str) -&gt; int:
        return self._fn_allowance.block_call(owner, spender)    
    &#34;&#34;&#34;
    implementation of approve in contract ERC20
    
    &#34;&#34;&#34;
    
    def approve(self,spender: str, amount: int) -&gt; bool:
        return self._fn_approve.block_call(spender, amount, 0,self.call_contract_fee_amount,self.call_contract_debug_flag)    
    &#34;&#34;&#34;
    implementation of balance_of in contract ERC20
    
    &#34;&#34;&#34;
    
    def balance_of(self,account: str) -&gt; int:
        return self._fn_balance_of.block_call(account)    
    &#34;&#34;&#34;
    implementation of decrease_allowance in contract ERC20
    
    &#34;&#34;&#34;
    
    def decrease_allowance(self,spender: str, subtracted_value: int) -&gt; bool:
        return self._fn_decrease_allowance.block_call(spender, subtracted_value, 0,self.call_contract_fee_amount,self.call_contract_debug_flag)    
    &#34;&#34;&#34;
    implementation of increase_allowance in contract ERC20
    
    &#34;&#34;&#34;
    
    def increase_allowance(self,spender: str, added_value: int) -&gt; bool:
        return self._fn_increase_allowance.block_call(spender, added_value, 0,self.call_contract_fee_amount,self.call_contract_debug_flag)    
    &#34;&#34;&#34;
    implementation of total_supply in contract ERC20
    
    &#34;&#34;&#34;
    
    def total_supply(self) -&gt; int:
        return self._fn_total_supply.block_call()    
    &#34;&#34;&#34;
    implementation of transfer in contract ERC20
    
    &#34;&#34;&#34;
    
    def transfer(self,recipient: str, amount: int) -&gt; bool:
        return self._fn_transfer.block_call(recipient, amount, 0,self.call_contract_fee_amount,self.call_contract_debug_flag)    
    &#34;&#34;&#34;
    implementation of transfer_from in contract ERC20
    
    &#34;&#34;&#34;
    
    def transfer_from(self,sender: str, recipient: str, amount: int) -&gt; bool:
        return self._fn_transfer_from.block_call(sender, recipient, amount, 0,self.call_contract_fee_amount,self.call_contract_debug_flag)








    def CallContractFee(self, amount:int)-&gt; &#34;ERC20&#34;:
        self.call_contract_fee_amount = amount
        return self

    def CallDebug(self, yesno: bool) -&gt; &#34;ERC20&#34;:
        self.call_contract_debug_flag = yesno
        return self






    @staticmethod
    def abi():
        &#34;&#34;&#34;Return the ABI to the underlying contract.&#34;&#34;&#34;
        return json.loads(
            &#39;[{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;owner&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;spender&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;Approval&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;from&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;to&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;Transfer&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;owner&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;spender&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;name&#34;:&#34;allowance&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;spender&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;amount&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;approve&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;account&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;name&#34;:&#34;balanceOf&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;spender&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;subtractedValue&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;decreaseAllowance&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;spender&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;addedValue&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;increaseAllowance&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;totalSupply&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;recipient&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;amount&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;transfer&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;sender&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;recipient&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;amount&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;transferFrom&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;}]&#39;  # noqa: E501 (line-too-long)
        )

# pylint: disable=too-many-lines</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="moody.m.erc20.AllowanceMethod"><code class="flex name class">
<span>class <span class="ident">AllowanceMethod</span></span>
<span>(</span><span>web3_or_provider: Union[web3.main.Web3, web3.providers.base.BaseProvider], contract_address: str, contract_function: web3.contract.ContractFunction, validator: <a title="moody.m.bases.Validator" href="../bases.html#moody.m.bases.Validator">Validator</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the allowance method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AllowanceMethod(ContractMethod): # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the allowance method.&#34;&#34;&#34;

    def __init__(self, web3_or_provider: Union[Web3, BaseProvider], contract_address: str, contract_function: ContractFunction, validator: Validator=None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(web3_or_provider, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, owner: str, spender: str):
        &#34;&#34;&#34;Validate the inputs to the allowance method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;allowance&#39;,
            parameter_name=&#39;owner&#39;,
            argument_value=owner,
        )
        owner = self.validate_and_checksum_address(owner)
        self.validator.assert_valid(
            method_name=&#39;allowance&#39;,
            parameter_name=&#39;spender&#39;,
            argument_value=spender,
        )
        spender = self.validate_and_checksum_address(spender)
        return (owner, spender)


    def block_call(self, owner: str, spender: str, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; int:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters

        &#34;&#34;&#34;
        (owner, spender) = self.validate_and_normalize_inputs(owner, spender)

        tx_params: Optional[TxParams] = None
        tx_params = super().normalize_tx_params(tx_params)
        returned = self._underlying_method(owner, spender).call(tx_params.as_dict())
        return int(returned)

    def estimate_gas(self, owner: str, spender: str, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (owner, spender) = self.validate_and_normalize_inputs(owner, spender)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(owner, spender).estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.m.erc20.AllowanceMethod.block_call"><code class="name flex">
<span>def <span class="ident">block_call</span></span>(<span>self, owner: str, spender: str, val: int = 0, fee: int = 1000000, debug: bool = False) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_call.</p>
<p>:param tx_params: transaction parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_call(self, owner: str, spender: str, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; int:
    &#34;&#34;&#34;Execute underlying contract method via eth_call.

    :param tx_params: transaction parameters

    &#34;&#34;&#34;
    (owner, spender) = self.validate_and_normalize_inputs(owner, spender)

    tx_params: Optional[TxParams] = None
    tx_params = super().normalize_tx_params(tx_params)
    returned = self._underlying_method(owner, spender).call(tx_params.as_dict())
    return int(returned)</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.AllowanceMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, owner: str, spender: str, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, owner: str, spender: str, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    (owner, spender) = self.validate_and_normalize_inputs(owner, spender)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(owner, spender).estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.AllowanceMethod.validate_and_normalize_inputs"><code class="name flex">
<span>def <span class="ident">validate_and_normalize_inputs</span></span>(<span>self, owner: str, spender: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the inputs to the allowance method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_and_normalize_inputs(self, owner: str, spender: str):
    &#34;&#34;&#34;Validate the inputs to the allowance method.&#34;&#34;&#34;
    self.validator.assert_valid(
        method_name=&#39;allowance&#39;,
        parameter_name=&#39;owner&#39;,
        argument_value=owner,
    )
    owner = self.validate_and_checksum_address(owner)
    self.validator.assert_valid(
        method_name=&#39;allowance&#39;,
        parameter_name=&#39;spender&#39;,
        argument_value=spender,
    )
    spender = self.validate_and_checksum_address(spender)
    return (owner, spender)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.m.erc20.ApproveMethod"><code class="flex name class">
<span>class <span class="ident">ApproveMethod</span></span>
<span>(</span><span>web3_or_provider: Union[web3.main.Web3, web3.providers.base.BaseProvider], contract_address: str, contract_function: web3.contract.ContractFunction, validator: <a title="moody.m.bases.Validator" href="../bases.html#moody.m.bases.Validator">Validator</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the approve method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ApproveMethod(ContractMethod): # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the approve method.&#34;&#34;&#34;

    def __init__(self, web3_or_provider: Union[Web3, BaseProvider], contract_address: str, contract_function: ContractFunction, validator: Validator=None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(web3_or_provider, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, spender: str, amount: int):
        &#34;&#34;&#34;Validate the inputs to the approve method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;approve&#39;,
            parameter_name=&#39;spender&#39;,
            argument_value=spender,
        )
        spender = self.validate_and_checksum_address(spender)
        self.validator.assert_valid(
            method_name=&#39;approve&#39;,
            parameter_name=&#39;amount&#39;,
            argument_value=amount,
        )
        # safeguard against fractional inputs
        amount = int(amount)
        return (spender, amount)


    def block_call(self, spender: str, amount: int, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        (spender, amount) = self.validate_and_normalize_inputs(spender, amount)

        tx_params: Optional[TxParams] = None
        tx_params = super().normalize_tx_params(tx_params)
        returned = self._underlying_method(spender, amount).call(tx_params.as_dict())
        return bool(returned)

    def send_transaction(self, spender: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (spender, amount) = self.validate_and_normalize_inputs(spender, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, amount).transact(tx_params.as_dict())

    def build_transaction(self, spender: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (spender, amount) = self.validate_and_normalize_inputs(spender, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, amount).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, spender: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (spender, amount) = self.validate_and_normalize_inputs(spender, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, amount).estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.m.erc20.ApproveMethod.block_call"><code class="name flex">
<span>def <span class="ident">block_call</span></span>(<span>self, spender: str, amount: int, val: int = 0, fee: int = 1000000, debug: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_call.</p>
<p>:param tx_params: transaction parameters
:returns: the return value of the underlying method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_call(self, spender: str, amount: int, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; bool:
    &#34;&#34;&#34;Execute underlying contract method via eth_call.

    :param tx_params: transaction parameters
    :returns: the return value of the underlying method.
    &#34;&#34;&#34;
    (spender, amount) = self.validate_and_normalize_inputs(spender, amount)

    tx_params: Optional[TxParams] = None
    tx_params = super().normalize_tx_params(tx_params)
    returned = self._underlying_method(spender, amount).call(tx_params.as_dict())
    return bool(returned)</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.ApproveMethod.build_transaction"><code class="name flex">
<span>def <span class="ident">build_transaction</span></span>(<span>self, spender: str, amount: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Construct calldata to be used as input to the method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_transaction(self, spender: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; dict:
    &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
    (spender, amount) = self.validate_and_normalize_inputs(spender, amount)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(spender, amount).buildTransaction(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.ApproveMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, spender: str, amount: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, spender: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    (spender, amount) = self.validate_and_normalize_inputs(spender, amount)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(spender, amount).estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.ApproveMethod.send_transaction"><code class="name flex">
<span>def <span class="ident">send_transaction</span></span>(<span>self, spender: str, amount: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> Union[hexbytes.main.HexBytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_sendTransaction.</p>
<p>:param tx_params: transaction parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_transaction(self, spender: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
    &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

    :param tx_params: transaction parameters
    &#34;&#34;&#34;
    (spender, amount) = self.validate_and_normalize_inputs(spender, amount)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(spender, amount).transact(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.ApproveMethod.validate_and_normalize_inputs"><code class="name flex">
<span>def <span class="ident">validate_and_normalize_inputs</span></span>(<span>self, spender: str, amount: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the inputs to the approve method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_and_normalize_inputs(self, spender: str, amount: int):
    &#34;&#34;&#34;Validate the inputs to the approve method.&#34;&#34;&#34;
    self.validator.assert_valid(
        method_name=&#39;approve&#39;,
        parameter_name=&#39;spender&#39;,
        argument_value=spender,
    )
    spender = self.validate_and_checksum_address(spender)
    self.validator.assert_valid(
        method_name=&#39;approve&#39;,
        parameter_name=&#39;amount&#39;,
        argument_value=amount,
    )
    # safeguard against fractional inputs
    amount = int(amount)
    return (spender, amount)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.m.erc20.BalanceOfMethod"><code class="flex name class">
<span>class <span class="ident">BalanceOfMethod</span></span>
<span>(</span><span>web3_or_provider: Union[web3.main.Web3, web3.providers.base.BaseProvider], contract_address: str, contract_function: web3.contract.ContractFunction, validator: <a title="moody.m.bases.Validator" href="../bases.html#moody.m.bases.Validator">Validator</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the balanceOf method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BalanceOfMethod(ContractMethod): # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the balanceOf method.&#34;&#34;&#34;

    def __init__(self, web3_or_provider: Union[Web3, BaseProvider], contract_address: str, contract_function: ContractFunction, validator: Validator=None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(web3_or_provider, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, account: str):
        &#34;&#34;&#34;Validate the inputs to the balanceOf method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;balanceOf&#39;,
            parameter_name=&#39;account&#39;,
            argument_value=account,
        )
        account = self.validate_and_checksum_address(account)
        return (account)


    def block_call(self, account: str, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; int:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters

        &#34;&#34;&#34;
        (account) = self.validate_and_normalize_inputs(account)

        tx_params: Optional[TxParams] = None
        tx_params = super().normalize_tx_params(tx_params)
        returned = self._underlying_method(account).call(tx_params.as_dict())
        return int(returned)

    def estimate_gas(self, account: str, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (account) = self.validate_and_normalize_inputs(account)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(account).estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.m.erc20.BalanceOfMethod.block_call"><code class="name flex">
<span>def <span class="ident">block_call</span></span>(<span>self, account: str, val: int = 0, fee: int = 1000000, debug: bool = False) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_call.</p>
<p>:param tx_params: transaction parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_call(self, account: str, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; int:
    &#34;&#34;&#34;Execute underlying contract method via eth_call.

    :param tx_params: transaction parameters

    &#34;&#34;&#34;
    (account) = self.validate_and_normalize_inputs(account)

    tx_params: Optional[TxParams] = None
    tx_params = super().normalize_tx_params(tx_params)
    returned = self._underlying_method(account).call(tx_params.as_dict())
    return int(returned)</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.BalanceOfMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, account: str, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, account: str, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    (account) = self.validate_and_normalize_inputs(account)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(account).estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.BalanceOfMethod.validate_and_normalize_inputs"><code class="name flex">
<span>def <span class="ident">validate_and_normalize_inputs</span></span>(<span>self, account: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the inputs to the balanceOf method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_and_normalize_inputs(self, account: str):
    &#34;&#34;&#34;Validate the inputs to the balanceOf method.&#34;&#34;&#34;
    self.validator.assert_valid(
        method_name=&#39;balanceOf&#39;,
        parameter_name=&#39;account&#39;,
        argument_value=account,
    )
    account = self.validate_and_checksum_address(account)
    return (account)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.m.erc20.DecreaseAllowanceMethod"><code class="flex name class">
<span>class <span class="ident">DecreaseAllowanceMethod</span></span>
<span>(</span><span>web3_or_provider: Union[web3.main.Web3, web3.providers.base.BaseProvider], contract_address: str, contract_function: web3.contract.ContractFunction, validator: <a title="moody.m.bases.Validator" href="../bases.html#moody.m.bases.Validator">Validator</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the decreaseAllowance method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DecreaseAllowanceMethod(ContractMethod): # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the decreaseAllowance method.&#34;&#34;&#34;

    def __init__(self, web3_or_provider: Union[Web3, BaseProvider], contract_address: str, contract_function: ContractFunction, validator: Validator=None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(web3_or_provider, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, spender: str, subtracted_value: int):
        &#34;&#34;&#34;Validate the inputs to the decreaseAllowance method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;decreaseAllowance&#39;,
            parameter_name=&#39;spender&#39;,
            argument_value=spender,
        )
        spender = self.validate_and_checksum_address(spender)
        self.validator.assert_valid(
            method_name=&#39;decreaseAllowance&#39;,
            parameter_name=&#39;subtractedValue&#39;,
            argument_value=subtracted_value,
        )
        # safeguard against fractional inputs
        subtracted_value = int(subtracted_value)
        return (spender, subtracted_value)


    def block_call(self, spender: str, subtracted_value: int, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        (spender, subtracted_value) = self.validate_and_normalize_inputs(spender, subtracted_value)

        tx_params: Optional[TxParams] = None
        tx_params = super().normalize_tx_params(tx_params)
        returned = self._underlying_method(spender, subtracted_value).call(tx_params.as_dict())
        return bool(returned)

    def send_transaction(self, spender: str, subtracted_value: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (spender, subtracted_value) = self.validate_and_normalize_inputs(spender, subtracted_value)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, subtracted_value).transact(tx_params.as_dict())

    def build_transaction(self, spender: str, subtracted_value: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (spender, subtracted_value) = self.validate_and_normalize_inputs(spender, subtracted_value)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, subtracted_value).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, spender: str, subtracted_value: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (spender, subtracted_value) = self.validate_and_normalize_inputs(spender, subtracted_value)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, subtracted_value).estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.m.erc20.DecreaseAllowanceMethod.block_call"><code class="name flex">
<span>def <span class="ident">block_call</span></span>(<span>self, spender: str, subtracted_value: int, val: int = 0, fee: int = 1000000, debug: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_call.</p>
<p>:param tx_params: transaction parameters
:returns: the return value of the underlying method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_call(self, spender: str, subtracted_value: int, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; bool:
    &#34;&#34;&#34;Execute underlying contract method via eth_call.

    :param tx_params: transaction parameters
    :returns: the return value of the underlying method.
    &#34;&#34;&#34;
    (spender, subtracted_value) = self.validate_and_normalize_inputs(spender, subtracted_value)

    tx_params: Optional[TxParams] = None
    tx_params = super().normalize_tx_params(tx_params)
    returned = self._underlying_method(spender, subtracted_value).call(tx_params.as_dict())
    return bool(returned)</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.DecreaseAllowanceMethod.build_transaction"><code class="name flex">
<span>def <span class="ident">build_transaction</span></span>(<span>self, spender: str, subtracted_value: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Construct calldata to be used as input to the method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_transaction(self, spender: str, subtracted_value: int, tx_params: Optional[TxParams] = None) -&gt; dict:
    &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
    (spender, subtracted_value) = self.validate_and_normalize_inputs(spender, subtracted_value)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(spender, subtracted_value).buildTransaction(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.DecreaseAllowanceMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, spender: str, subtracted_value: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, spender: str, subtracted_value: int, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    (spender, subtracted_value) = self.validate_and_normalize_inputs(spender, subtracted_value)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(spender, subtracted_value).estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.DecreaseAllowanceMethod.send_transaction"><code class="name flex">
<span>def <span class="ident">send_transaction</span></span>(<span>self, spender: str, subtracted_value: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> Union[hexbytes.main.HexBytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_sendTransaction.</p>
<p>:param tx_params: transaction parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_transaction(self, spender: str, subtracted_value: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
    &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

    :param tx_params: transaction parameters
    &#34;&#34;&#34;
    (spender, subtracted_value) = self.validate_and_normalize_inputs(spender, subtracted_value)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(spender, subtracted_value).transact(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.DecreaseAllowanceMethod.validate_and_normalize_inputs"><code class="name flex">
<span>def <span class="ident">validate_and_normalize_inputs</span></span>(<span>self, spender: str, subtracted_value: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the inputs to the decreaseAllowance method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_and_normalize_inputs(self, spender: str, subtracted_value: int):
    &#34;&#34;&#34;Validate the inputs to the decreaseAllowance method.&#34;&#34;&#34;
    self.validator.assert_valid(
        method_name=&#39;decreaseAllowance&#39;,
        parameter_name=&#39;spender&#39;,
        argument_value=spender,
    )
    spender = self.validate_and_checksum_address(spender)
    self.validator.assert_valid(
        method_name=&#39;decreaseAllowance&#39;,
        parameter_name=&#39;subtractedValue&#39;,
        argument_value=subtracted_value,
    )
    # safeguard against fractional inputs
    subtracted_value = int(subtracted_value)
    return (spender, subtracted_value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.m.erc20.ERC20"><code class="flex name class">
<span>class <span class="ident">ERC20</span></span>
<span>(</span><span>web3_or_provider: Union[web3.main.Web3, web3.providers.base.BaseProvider], contract_address: str, validator: <a title="moody.m.erc20.ERC20Validator" href="#moody.m.erc20.ERC20Validator">ERC20Validator</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper class for ERC20 Solidity contract.</p>
<p>Get an instance of wrapper for smart contract.</p>
<p>:param web3_or_provider: Either an instance of <code>web3.Web3</code>:code: or
<code>web3.providers.base.BaseProvider</code>:code:
:param contract_address: where the contract has been deployed
:param validator: for validation of method inputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ERC20:
    &#34;&#34;&#34;Wrapper class for ERC20 Solidity contract.&#34;&#34;&#34;
    _fn_allowance: AllowanceMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`AllowanceMethod`.
    &#34;&#34;&#34;

    _fn_approve: ApproveMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`ApproveMethod`.
    &#34;&#34;&#34;

    _fn_balance_of: BalanceOfMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`BalanceOfMethod`.
    &#34;&#34;&#34;

    _fn_decrease_allowance: DecreaseAllowanceMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`DecreaseAllowanceMethod`.
    &#34;&#34;&#34;

    _fn_increase_allowance: IncreaseAllowanceMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`IncreaseAllowanceMethod`.
    &#34;&#34;&#34;

    _fn_total_supply: TotalSupplyMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`TotalSupplyMethod`.
    &#34;&#34;&#34;

    _fn_transfer: TransferMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`TransferMethod`.
    &#34;&#34;&#34;

    _fn_transfer_from: TransferFromMethod
    &#34;&#34;&#34;Constructor-initialized instance of
    :class:`TransferFromMethod`.
    &#34;&#34;&#34;


    def __init__(
        self,
        web3_or_provider: Union[Web3, BaseProvider],
        contract_address: str,
        validator: ERC20Validator = None,
    ):
        &#34;&#34;&#34;Get an instance of wrapper for smart contract.

        :param web3_or_provider: Either an instance of `web3.Web3`:code: or
            `web3.providers.base.BaseProvider`:code:
        :param contract_address: where the contract has been deployed
        :param validator: for validation of method inputs.
        &#34;&#34;&#34;
        # pylint: disable=too-many-statements

        self.contract_address = contract_address

        if not validator:
            validator = ERC20Validator(web3_or_provider, contract_address)

        web3 = None
        if isinstance(web3_or_provider, BaseProvider):
            web3 = Web3(web3_or_provider)
        elif isinstance(web3_or_provider, Web3):
            web3 = web3_or_provider
        else:
            raise TypeError(
                &#34;Expected parameter &#39;web3_or_provider&#39; to be an instance of either&#34;
                + &#34; Web3 or BaseProvider&#34;
            )

        # if any middleware was imported, inject it
        try:
            MIDDLEWARE
        except NameError:
            pass
        else:
            try:
                for middleware in MIDDLEWARE:
                    web3.middleware_onion.inject(
                         middleware[&#39;function&#39;], layer=middleware[&#39;layer&#39;],
                    )
            except ValueError as value_error:
                if value_error.args == (&#34;You can&#39;t add the same un-named instance twice&#34;,):
                    pass

        self._web3_eth = web3.eth

        functions = self._web3_eth.contract(address=to_checksum_address(contract_address), abi=ERC20.abi()).functions

        self.call_contract_fee_amount:int = 1000000
        self.call_contract_debug_flag:bool = False

        self._fn_allowance = AllowanceMethod(web3_or_provider, contract_address, functions.allowance, validator)

        self._fn_approve = ApproveMethod(web3_or_provider, contract_address, functions.approve, validator)

        self._fn_balance_of = BalanceOfMethod(web3_or_provider, contract_address, functions.balanceOf, validator)

        self._fn_decrease_allowance = DecreaseAllowanceMethod(web3_or_provider, contract_address, functions.decreaseAllowance, validator)

        self._fn_increase_allowance = IncreaseAllowanceMethod(web3_or_provider, contract_address, functions.increaseAllowance, validator)

        self._fn_total_supply = TotalSupplyMethod(web3_or_provider, contract_address, functions.totalSupply)

        self._fn_transfer = TransferMethod(web3_or_provider, contract_address, functions.transfer, validator)

        self._fn_transfer_from = TransferFromMethod(web3_or_provider, contract_address, functions.transferFrom, validator)


    &#34;&#34;&#34;
    Implementation of event approval in contract ERC20
    Get log entry for Approval event.
            :param tx_hash: hash of transaction emitting Approval event
    &#34;&#34;&#34;
    
    def event_approval(
            self, tx_hash: Union[HexBytes, bytes]
    ) -&gt; Tuple[AttributeDict]:
        tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
        return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=ERC20.abi()).events.Approval().processReceipt(tx_receipt)
    &#34;&#34;&#34;
    Implementation of event transfer in contract ERC20
    Get log entry for Transfer event.
            :param tx_hash: hash of transaction emitting Transfer event
    &#34;&#34;&#34;
    
    def event_transfer(
            self, tx_hash: Union[HexBytes, bytes]
    ) -&gt; Tuple[AttributeDict]:
        tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
        return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=ERC20.abi()).events.Transfer().processReceipt(tx_receipt)



    
    &#34;&#34;&#34;
    implementation of allowance in contract ERC20
    
    &#34;&#34;&#34;
    
    def allowance(self,owner: str, spender: str) -&gt; int:
        return self._fn_allowance.block_call(owner, spender)    
    &#34;&#34;&#34;
    implementation of approve in contract ERC20
    
    &#34;&#34;&#34;
    
    def approve(self,spender: str, amount: int) -&gt; bool:
        return self._fn_approve.block_call(spender, amount, 0,self.call_contract_fee_amount,self.call_contract_debug_flag)    
    &#34;&#34;&#34;
    implementation of balance_of in contract ERC20
    
    &#34;&#34;&#34;
    
    def balance_of(self,account: str) -&gt; int:
        return self._fn_balance_of.block_call(account)    
    &#34;&#34;&#34;
    implementation of decrease_allowance in contract ERC20
    
    &#34;&#34;&#34;
    
    def decrease_allowance(self,spender: str, subtracted_value: int) -&gt; bool:
        return self._fn_decrease_allowance.block_call(spender, subtracted_value, 0,self.call_contract_fee_amount,self.call_contract_debug_flag)    
    &#34;&#34;&#34;
    implementation of increase_allowance in contract ERC20
    
    &#34;&#34;&#34;
    
    def increase_allowance(self,spender: str, added_value: int) -&gt; bool:
        return self._fn_increase_allowance.block_call(spender, added_value, 0,self.call_contract_fee_amount,self.call_contract_debug_flag)    
    &#34;&#34;&#34;
    implementation of total_supply in contract ERC20
    
    &#34;&#34;&#34;
    
    def total_supply(self) -&gt; int:
        return self._fn_total_supply.block_call()    
    &#34;&#34;&#34;
    implementation of transfer in contract ERC20
    
    &#34;&#34;&#34;
    
    def transfer(self,recipient: str, amount: int) -&gt; bool:
        return self._fn_transfer.block_call(recipient, amount, 0,self.call_contract_fee_amount,self.call_contract_debug_flag)    
    &#34;&#34;&#34;
    implementation of transfer_from in contract ERC20
    
    &#34;&#34;&#34;
    
    def transfer_from(self,sender: str, recipient: str, amount: int) -&gt; bool:
        return self._fn_transfer_from.block_call(sender, recipient, amount, 0,self.call_contract_fee_amount,self.call_contract_debug_flag)








    def CallContractFee(self, amount:int)-&gt; &#34;ERC20&#34;:
        self.call_contract_fee_amount = amount
        return self

    def CallDebug(self, yesno: bool) -&gt; &#34;ERC20&#34;:
        self.call_contract_debug_flag = yesno
        return self






    @staticmethod
    def abi():
        &#34;&#34;&#34;Return the ABI to the underlying contract.&#34;&#34;&#34;
        return json.loads(
            &#39;[{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;owner&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;spender&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;Approval&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;from&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;to&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;Transfer&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;owner&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;spender&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;name&#34;:&#34;allowance&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;spender&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;amount&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;approve&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;account&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;name&#34;:&#34;balanceOf&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;spender&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;subtractedValue&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;decreaseAllowance&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;spender&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;addedValue&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;increaseAllowance&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;totalSupply&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;recipient&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;amount&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;transfer&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;sender&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;recipient&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;amount&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;transferFrom&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;}]&#39;  # noqa: E501 (line-too-long)
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="moody.m.erc20.ERC20.abi"><code class="name flex">
<span>def <span class="ident">abi</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the ABI to the underlying contract.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def abi():
    &#34;&#34;&#34;Return the ABI to the underlying contract.&#34;&#34;&#34;
    return json.loads(
        &#39;[{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;owner&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;spender&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;Approval&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;anonymous&#34;:false,&#34;inputs&#34;:[{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;from&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:true,&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;to&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;indexed&#34;:false,&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;value&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;Transfer&#34;,&#34;type&#34;:&#34;event&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;owner&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;spender&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;name&#34;:&#34;allowance&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;spender&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;amount&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;approve&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;account&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;name&#34;:&#34;balanceOf&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;spender&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;subtractedValue&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;decreaseAllowance&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;spender&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;addedValue&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;increaseAllowance&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:true,&#34;inputs&#34;:[],&#34;name&#34;:&#34;totalSupply&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;view&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;recipient&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;amount&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;transfer&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;},{&#34;constant&#34;:false,&#34;inputs&#34;:[{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;sender&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;address&#34;,&#34;name&#34;:&#34;recipient&#34;,&#34;type&#34;:&#34;address&#34;},{&#34;internalType&#34;:&#34;uint256&#34;,&#34;name&#34;:&#34;amount&#34;,&#34;type&#34;:&#34;uint256&#34;}],&#34;name&#34;:&#34;transferFrom&#34;,&#34;outputs&#34;:[{&#34;internalType&#34;:&#34;bool&#34;,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;payable&#34;:false,&#34;stateMutability&#34;:&#34;nonpayable&#34;,&#34;type&#34;:&#34;function&#34;}]&#39;  # noqa: E501 (line-too-long)
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="moody.m.erc20.ERC20.CallContractFee"><code class="name flex">
<span>def <span class="ident">CallContractFee</span></span>(<span>self, amount: int) ‑> <a title="moody.m.erc20.ERC20" href="#moody.m.erc20.ERC20">ERC20</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CallContractFee(self, amount:int)-&gt; &#34;ERC20&#34;:
    self.call_contract_fee_amount = amount
    return self</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.ERC20.CallDebug"><code class="name flex">
<span>def <span class="ident">CallDebug</span></span>(<span>self, yesno: bool) ‑> <a title="moody.m.erc20.ERC20" href="#moody.m.erc20.ERC20">ERC20</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CallDebug(self, yesno: bool) -&gt; &#34;ERC20&#34;:
    self.call_contract_debug_flag = yesno
    return self</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.ERC20.allowance"><code class="name flex">
<span>def <span class="ident">allowance</span></span>(<span>self, owner: str, spender: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def allowance(self,owner: str, spender: str) -&gt; int:
    return self._fn_allowance.block_call(owner, spender)    </code></pre>
</details>
</dd>
<dt id="moody.m.erc20.ERC20.approve"><code class="name flex">
<span>def <span class="ident">approve</span></span>(<span>self, spender: str, amount: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approve(self,spender: str, amount: int) -&gt; bool:
    return self._fn_approve.block_call(spender, amount, 0,self.call_contract_fee_amount,self.call_contract_debug_flag)    </code></pre>
</details>
</dd>
<dt id="moody.m.erc20.ERC20.balance_of"><code class="name flex">
<span>def <span class="ident">balance_of</span></span>(<span>self, account: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def balance_of(self,account: str) -&gt; int:
    return self._fn_balance_of.block_call(account)    </code></pre>
</details>
</dd>
<dt id="moody.m.erc20.ERC20.decrease_allowance"><code class="name flex">
<span>def <span class="ident">decrease_allowance</span></span>(<span>self, spender: str, subtracted_value: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrease_allowance(self,spender: str, subtracted_value: int) -&gt; bool:
    return self._fn_decrease_allowance.block_call(spender, subtracted_value, 0,self.call_contract_fee_amount,self.call_contract_debug_flag)    </code></pre>
</details>
</dd>
<dt id="moody.m.erc20.ERC20.event_approval"><code class="name flex">
<span>def <span class="ident">event_approval</span></span>(<span>self, tx_hash: Union[hexbytes.main.HexBytes, bytes]) ‑> Tuple[web3.datastructures.AttributeDict]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event_approval(
        self, tx_hash: Union[HexBytes, bytes]
) -&gt; Tuple[AttributeDict]:
    tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
    return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=ERC20.abi()).events.Approval().processReceipt(tx_receipt)</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.ERC20.event_transfer"><code class="name flex">
<span>def <span class="ident">event_transfer</span></span>(<span>self, tx_hash: Union[hexbytes.main.HexBytes, bytes]) ‑> Tuple[web3.datastructures.AttributeDict]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event_transfer(
        self, tx_hash: Union[HexBytes, bytes]
) -&gt; Tuple[AttributeDict]:
    tx_receipt = self._web3_eth.getTransactionReceipt(tx_hash)
    return self._web3_eth.contract(address=to_checksum_address(self.contract_address), abi=ERC20.abi()).events.Transfer().processReceipt(tx_receipt)</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.ERC20.increase_allowance"><code class="name flex">
<span>def <span class="ident">increase_allowance</span></span>(<span>self, spender: str, added_value: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def increase_allowance(self,spender: str, added_value: int) -&gt; bool:
    return self._fn_increase_allowance.block_call(spender, added_value, 0,self.call_contract_fee_amount,self.call_contract_debug_flag)    </code></pre>
</details>
</dd>
<dt id="moody.m.erc20.ERC20.total_supply"><code class="name flex">
<span>def <span class="ident">total_supply</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def total_supply(self) -&gt; int:
    return self._fn_total_supply.block_call()    </code></pre>
</details>
</dd>
<dt id="moody.m.erc20.ERC20.transfer"><code class="name flex">
<span>def <span class="ident">transfer</span></span>(<span>self, recipient: str, amount: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transfer(self,recipient: str, amount: int) -&gt; bool:
    return self._fn_transfer.block_call(recipient, amount, 0,self.call_contract_fee_amount,self.call_contract_debug_flag)    </code></pre>
</details>
</dd>
<dt id="moody.m.erc20.ERC20.transfer_from"><code class="name flex">
<span>def <span class="ident">transfer_from</span></span>(<span>self, sender: str, recipient: str, amount: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transfer_from(self,sender: str, recipient: str, amount: int) -&gt; bool:
    return self._fn_transfer_from.block_call(sender, recipient, amount, 0,self.call_contract_fee_amount,self.call_contract_debug_flag)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="moody.m.erc20.ERC20Validator"><code class="flex name class">
<span>class <span class="ident">ERC20Validator</span></span>
<span>(</span><span>web3_or_provider: Union[web3.main.Web3, web3.providers.base.BaseProvider], contract_address: str)</span>
</code></dt>
<dd>
<div class="desc"><p>No-op input validator.</p>
<p>Initialize the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ERC20Validator(  # type: ignore
    Validator
):
    &#34;&#34;&#34;No-op input validator.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.Validator" href="../bases.html#moody.m.bases.Validator">Validator</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.Validator" href="../bases.html#moody.m.bases.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.Validator.assert_valid" href="../bases.html#moody.m.bases.Validator.assert_valid">assert_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.m.erc20.IncreaseAllowanceMethod"><code class="flex name class">
<span>class <span class="ident">IncreaseAllowanceMethod</span></span>
<span>(</span><span>web3_or_provider: Union[web3.main.Web3, web3.providers.base.BaseProvider], contract_address: str, contract_function: web3.contract.ContractFunction, validator: <a title="moody.m.bases.Validator" href="../bases.html#moody.m.bases.Validator">Validator</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the increaseAllowance method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IncreaseAllowanceMethod(ContractMethod): # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the increaseAllowance method.&#34;&#34;&#34;

    def __init__(self, web3_or_provider: Union[Web3, BaseProvider], contract_address: str, contract_function: ContractFunction, validator: Validator=None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(web3_or_provider, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, spender: str, added_value: int):
        &#34;&#34;&#34;Validate the inputs to the increaseAllowance method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;increaseAllowance&#39;,
            parameter_name=&#39;spender&#39;,
            argument_value=spender,
        )
        spender = self.validate_and_checksum_address(spender)
        self.validator.assert_valid(
            method_name=&#39;increaseAllowance&#39;,
            parameter_name=&#39;addedValue&#39;,
            argument_value=added_value,
        )
        # safeguard against fractional inputs
        added_value = int(added_value)
        return (spender, added_value)


    def block_call(self, spender: str, added_value: int, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        (spender, added_value) = self.validate_and_normalize_inputs(spender, added_value)

        tx_params: Optional[TxParams] = None
        tx_params = super().normalize_tx_params(tx_params)
        returned = self._underlying_method(spender, added_value).call(tx_params.as_dict())
        return bool(returned)

    def send_transaction(self, spender: str, added_value: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (spender, added_value) = self.validate_and_normalize_inputs(spender, added_value)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, added_value).transact(tx_params.as_dict())

    def build_transaction(self, spender: str, added_value: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (spender, added_value) = self.validate_and_normalize_inputs(spender, added_value)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, added_value).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, spender: str, added_value: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (spender, added_value) = self.validate_and_normalize_inputs(spender, added_value)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(spender, added_value).estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.m.erc20.IncreaseAllowanceMethod.block_call"><code class="name flex">
<span>def <span class="ident">block_call</span></span>(<span>self, spender: str, added_value: int, val: int = 0, fee: int = 1000000, debug: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_call.</p>
<p>:param tx_params: transaction parameters
:returns: the return value of the underlying method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_call(self, spender: str, added_value: int, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; bool:
    &#34;&#34;&#34;Execute underlying contract method via eth_call.

    :param tx_params: transaction parameters
    :returns: the return value of the underlying method.
    &#34;&#34;&#34;
    (spender, added_value) = self.validate_and_normalize_inputs(spender, added_value)

    tx_params: Optional[TxParams] = None
    tx_params = super().normalize_tx_params(tx_params)
    returned = self._underlying_method(spender, added_value).call(tx_params.as_dict())
    return bool(returned)</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.IncreaseAllowanceMethod.build_transaction"><code class="name flex">
<span>def <span class="ident">build_transaction</span></span>(<span>self, spender: str, added_value: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Construct calldata to be used as input to the method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_transaction(self, spender: str, added_value: int, tx_params: Optional[TxParams] = None) -&gt; dict:
    &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
    (spender, added_value) = self.validate_and_normalize_inputs(spender, added_value)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(spender, added_value).buildTransaction(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.IncreaseAllowanceMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, spender: str, added_value: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, spender: str, added_value: int, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    (spender, added_value) = self.validate_and_normalize_inputs(spender, added_value)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(spender, added_value).estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.IncreaseAllowanceMethod.send_transaction"><code class="name flex">
<span>def <span class="ident">send_transaction</span></span>(<span>self, spender: str, added_value: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> Union[hexbytes.main.HexBytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_sendTransaction.</p>
<p>:param tx_params: transaction parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_transaction(self, spender: str, added_value: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
    &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

    :param tx_params: transaction parameters
    &#34;&#34;&#34;
    (spender, added_value) = self.validate_and_normalize_inputs(spender, added_value)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(spender, added_value).transact(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.IncreaseAllowanceMethod.validate_and_normalize_inputs"><code class="name flex">
<span>def <span class="ident">validate_and_normalize_inputs</span></span>(<span>self, spender: str, added_value: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the inputs to the increaseAllowance method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_and_normalize_inputs(self, spender: str, added_value: int):
    &#34;&#34;&#34;Validate the inputs to the increaseAllowance method.&#34;&#34;&#34;
    self.validator.assert_valid(
        method_name=&#39;increaseAllowance&#39;,
        parameter_name=&#39;spender&#39;,
        argument_value=spender,
    )
    spender = self.validate_and_checksum_address(spender)
    self.validator.assert_valid(
        method_name=&#39;increaseAllowance&#39;,
        parameter_name=&#39;addedValue&#39;,
        argument_value=added_value,
    )
    # safeguard against fractional inputs
    added_value = int(added_value)
    return (spender, added_value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.m.erc20.TotalSupplyMethod"><code class="flex name class">
<span>class <span class="ident">TotalSupplyMethod</span></span>
<span>(</span><span>web3_or_provider: Union[web3.main.Web3, web3.providers.base.BaseProvider], contract_address: str, contract_function: web3.contract.ContractFunction)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the totalSupply method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TotalSupplyMethod(ContractMethod): # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the totalSupply method.&#34;&#34;&#34;

    def __init__(self, web3_or_provider: Union[Web3, BaseProvider], contract_address: str, contract_function: ContractFunction):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(web3_or_provider, contract_address)
        self._underlying_method = contract_function


    def block_call(self, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; int:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters

        &#34;&#34;&#34;

        tx_params: Optional[TxParams] = None
        tx_params = super().normalize_tx_params(tx_params)
        returned = self._underlying_method().call(tx_params.as_dict())
        return int(returned)

    def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method().estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.m.erc20.TotalSupplyMethod.block_call"><code class="name flex">
<span>def <span class="ident">block_call</span></span>(<span>self, val: int = 0, fee: int = 1000000, debug: bool = False) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_call.</p>
<p>:param tx_params: transaction parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_call(self, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; int:
    &#34;&#34;&#34;Execute underlying contract method via eth_call.

    :param tx_params: transaction parameters

    &#34;&#34;&#34;

    tx_params: Optional[TxParams] = None
    tx_params = super().normalize_tx_params(tx_params)
    returned = self._underlying_method().call(tx_params.as_dict())
    return int(returned)</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.TotalSupplyMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method().estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.m.erc20.TransferFromMethod"><code class="flex name class">
<span>class <span class="ident">TransferFromMethod</span></span>
<span>(</span><span>web3_or_provider: Union[web3.main.Web3, web3.providers.base.BaseProvider], contract_address: str, contract_function: web3.contract.ContractFunction, validator: <a title="moody.m.bases.Validator" href="../bases.html#moody.m.bases.Validator">Validator</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the transferFrom method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TransferFromMethod(ContractMethod): # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the transferFrom method.&#34;&#34;&#34;

    def __init__(self, web3_or_provider: Union[Web3, BaseProvider], contract_address: str, contract_function: ContractFunction, validator: Validator=None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(web3_or_provider, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, sender: str, recipient: str, amount: int):
        &#34;&#34;&#34;Validate the inputs to the transferFrom method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;transferFrom&#39;,
            parameter_name=&#39;sender&#39;,
            argument_value=sender,
        )
        sender = self.validate_and_checksum_address(sender)
        self.validator.assert_valid(
            method_name=&#39;transferFrom&#39;,
            parameter_name=&#39;recipient&#39;,
            argument_value=recipient,
        )
        recipient = self.validate_and_checksum_address(recipient)
        self.validator.assert_valid(
            method_name=&#39;transferFrom&#39;,
            parameter_name=&#39;amount&#39;,
            argument_value=amount,
        )
        # safeguard against fractional inputs
        amount = int(amount)
        return (sender, recipient, amount)


    def block_call(self, sender: str, recipient: str, amount: int, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        (sender, recipient, amount) = self.validate_and_normalize_inputs(sender, recipient, amount)

        tx_params: Optional[TxParams] = None
        tx_params = super().normalize_tx_params(tx_params)
        returned = self._underlying_method(sender, recipient, amount).call(tx_params.as_dict())
        return bool(returned)

    def send_transaction(self, sender: str, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (sender, recipient, amount) = self.validate_and_normalize_inputs(sender, recipient, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(sender, recipient, amount).transact(tx_params.as_dict())

    def build_transaction(self, sender: str, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (sender, recipient, amount) = self.validate_and_normalize_inputs(sender, recipient, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(sender, recipient, amount).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, sender: str, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (sender, recipient, amount) = self.validate_and_normalize_inputs(sender, recipient, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(sender, recipient, amount).estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.m.erc20.TransferFromMethod.block_call"><code class="name flex">
<span>def <span class="ident">block_call</span></span>(<span>self, sender: str, recipient: str, amount: int, val: int = 0, fee: int = 1000000, debug: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_call.</p>
<p>:param tx_params: transaction parameters
:returns: the return value of the underlying method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_call(self, sender: str, recipient: str, amount: int, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; bool:
    &#34;&#34;&#34;Execute underlying contract method via eth_call.

    :param tx_params: transaction parameters
    :returns: the return value of the underlying method.
    &#34;&#34;&#34;
    (sender, recipient, amount) = self.validate_and_normalize_inputs(sender, recipient, amount)

    tx_params: Optional[TxParams] = None
    tx_params = super().normalize_tx_params(tx_params)
    returned = self._underlying_method(sender, recipient, amount).call(tx_params.as_dict())
    return bool(returned)</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.TransferFromMethod.build_transaction"><code class="name flex">
<span>def <span class="ident">build_transaction</span></span>(<span>self, sender: str, recipient: str, amount: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Construct calldata to be used as input to the method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_transaction(self, sender: str, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; dict:
    &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
    (sender, recipient, amount) = self.validate_and_normalize_inputs(sender, recipient, amount)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(sender, recipient, amount).buildTransaction(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.TransferFromMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, sender: str, recipient: str, amount: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, sender: str, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    (sender, recipient, amount) = self.validate_and_normalize_inputs(sender, recipient, amount)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(sender, recipient, amount).estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.TransferFromMethod.send_transaction"><code class="name flex">
<span>def <span class="ident">send_transaction</span></span>(<span>self, sender: str, recipient: str, amount: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> Union[hexbytes.main.HexBytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_sendTransaction.</p>
<p>:param tx_params: transaction parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_transaction(self, sender: str, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
    &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

    :param tx_params: transaction parameters
    &#34;&#34;&#34;
    (sender, recipient, amount) = self.validate_and_normalize_inputs(sender, recipient, amount)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(sender, recipient, amount).transact(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.TransferFromMethod.validate_and_normalize_inputs"><code class="name flex">
<span>def <span class="ident">validate_and_normalize_inputs</span></span>(<span>self, sender: str, recipient: str, amount: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the inputs to the transferFrom method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_and_normalize_inputs(self, sender: str, recipient: str, amount: int):
    &#34;&#34;&#34;Validate the inputs to the transferFrom method.&#34;&#34;&#34;
    self.validator.assert_valid(
        method_name=&#39;transferFrom&#39;,
        parameter_name=&#39;sender&#39;,
        argument_value=sender,
    )
    sender = self.validate_and_checksum_address(sender)
    self.validator.assert_valid(
        method_name=&#39;transferFrom&#39;,
        parameter_name=&#39;recipient&#39;,
        argument_value=recipient,
    )
    recipient = self.validate_and_checksum_address(recipient)
    self.validator.assert_valid(
        method_name=&#39;transferFrom&#39;,
        parameter_name=&#39;amount&#39;,
        argument_value=amount,
    )
    # safeguard against fractional inputs
    amount = int(amount)
    return (sender, recipient, amount)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="moody.m.erc20.TransferMethod"><code class="flex name class">
<span>class <span class="ident">TransferMethod</span></span>
<span>(</span><span>web3_or_provider: Union[web3.main.Web3, web3.providers.base.BaseProvider], contract_address: str, contract_function: web3.contract.ContractFunction, validator: <a title="moody.m.bases.Validator" href="../bases.html#moody.m.bases.Validator">Validator</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Various interfaces to the transfer method.</p>
<p>Persist instance data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TransferMethod(ContractMethod): # pylint: disable=invalid-name
    &#34;&#34;&#34;Various interfaces to the transfer method.&#34;&#34;&#34;

    def __init__(self, web3_or_provider: Union[Web3, BaseProvider], contract_address: str, contract_function: ContractFunction, validator: Validator=None):
        &#34;&#34;&#34;Persist instance data.&#34;&#34;&#34;
        super().__init__(web3_or_provider, contract_address, validator)
        self._underlying_method = contract_function

    def validate_and_normalize_inputs(self, recipient: str, amount: int):
        &#34;&#34;&#34;Validate the inputs to the transfer method.&#34;&#34;&#34;
        self.validator.assert_valid(
            method_name=&#39;transfer&#39;,
            parameter_name=&#39;recipient&#39;,
            argument_value=recipient,
        )
        recipient = self.validate_and_checksum_address(recipient)
        self.validator.assert_valid(
            method_name=&#39;transfer&#39;,
            parameter_name=&#39;amount&#39;,
            argument_value=amount,
        )
        # safeguard against fractional inputs
        amount = int(amount)
        return (recipient, amount)


    def block_call(self, recipient: str, amount: int, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;Execute underlying contract method via eth_call.

        :param tx_params: transaction parameters
        :returns: the return value of the underlying method.
        &#34;&#34;&#34;
        (recipient, amount) = self.validate_and_normalize_inputs(recipient, amount)

        tx_params: Optional[TxParams] = None
        tx_params = super().normalize_tx_params(tx_params)
        returned = self._underlying_method(recipient, amount).call(tx_params.as_dict())
        return bool(returned)

    def send_transaction(self, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
        &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

        :param tx_params: transaction parameters
        &#34;&#34;&#34;
        (recipient, amount) = self.validate_and_normalize_inputs(recipient, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(recipient, amount).transact(tx_params.as_dict())

    def build_transaction(self, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; dict:
        &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
        (recipient, amount) = self.validate_and_normalize_inputs(recipient, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(recipient, amount).buildTransaction(tx_params.as_dict())

    def estimate_gas(self, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; int:
        &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
        (recipient, amount) = self.validate_and_normalize_inputs(recipient, amount)
        tx_params = super().normalize_tx_params(tx_params)
        return self._underlying_method(recipient, amount).estimateGas(tx_params.as_dict())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.m.bases.ContractMethod" href="../bases.html#moody.m.bases.ContractMethod">ContractMethod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.m.erc20.TransferMethod.block_call"><code class="name flex">
<span>def <span class="ident">block_call</span></span>(<span>self, recipient: str, amount: int, val: int = 0, fee: int = 1000000, debug: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_call.</p>
<p>:param tx_params: transaction parameters
:returns: the return value of the underlying method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_call(self, recipient: str, amount: int, val: int = 0, fee: int = 1000000, debug: bool = False) -&gt; bool:
    &#34;&#34;&#34;Execute underlying contract method via eth_call.

    :param tx_params: transaction parameters
    :returns: the return value of the underlying method.
    &#34;&#34;&#34;
    (recipient, amount) = self.validate_and_normalize_inputs(recipient, amount)

    tx_params: Optional[TxParams] = None
    tx_params = super().normalize_tx_params(tx_params)
    returned = self._underlying_method(recipient, amount).call(tx_params.as_dict())
    return bool(returned)</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.TransferMethod.build_transaction"><code class="name flex">
<span>def <span class="ident">build_transaction</span></span>(<span>self, recipient: str, amount: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Construct calldata to be used as input to the method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_transaction(self, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; dict:
    &#34;&#34;&#34;Construct calldata to be used as input to the method.&#34;&#34;&#34;
    (recipient, amount) = self.validate_and_normalize_inputs(recipient, amount)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(recipient, amount).buildTransaction(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.TransferMethod.estimate_gas"><code class="name flex">
<span>def <span class="ident">estimate_gas</span></span>(<span>self, recipient: str, amount: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate gas consumption of method call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas(self, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; int:
    &#34;&#34;&#34;Estimate gas consumption of method call.&#34;&#34;&#34;
    (recipient, amount) = self.validate_and_normalize_inputs(recipient, amount)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(recipient, amount).estimateGas(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.TransferMethod.send_transaction"><code class="name flex">
<span>def <span class="ident">send_transaction</span></span>(<span>self, recipient: str, amount: int, tx_params: Union[<a title="moody.m.tx_params.TxParams" href="../tx_params.html#moody.m.tx_params.TxParams">TxParams</a>, NoneType] = None) ‑> Union[hexbytes.main.HexBytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Execute underlying contract method via eth_sendTransaction.</p>
<p>:param tx_params: transaction parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_transaction(self, recipient: str, amount: int, tx_params: Optional[TxParams] = None) -&gt; Union[HexBytes, bytes]:
    &#34;&#34;&#34;Execute underlying contract method via eth_sendTransaction.

    :param tx_params: transaction parameters
    &#34;&#34;&#34;
    (recipient, amount) = self.validate_and_normalize_inputs(recipient, amount)
    tx_params = super().normalize_tx_params(tx_params)
    return self._underlying_method(recipient, amount).transact(tx_params.as_dict())</code></pre>
</details>
</dd>
<dt id="moody.m.erc20.TransferMethod.validate_and_normalize_inputs"><code class="name flex">
<span>def <span class="ident">validate_and_normalize_inputs</span></span>(<span>self, recipient: str, amount: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the inputs to the transfer method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_and_normalize_inputs(self, recipient: str, amount: int):
    &#34;&#34;&#34;Validate the inputs to the transfer method.&#34;&#34;&#34;
    self.validator.assert_valid(
        method_name=&#39;transfer&#39;,
        parameter_name=&#39;recipient&#39;,
        argument_value=recipient,
    )
    recipient = self.validate_and_checksum_address(recipient)
    self.validator.assert_valid(
        method_name=&#39;transfer&#39;,
        parameter_name=&#39;amount&#39;,
        argument_value=amount,
    )
    # safeguard against fractional inputs
    amount = int(amount)
    return (recipient, amount)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="moody.m.bases.ContractMethod" href="../bases.html#moody.m.bases.ContractMethod">ContractMethod</a></b></code>:
<ul class="hlist">
<li><code><a title="moody.m.bases.ContractMethod.normalize_tx_params" href="../bases.html#moody.m.bases.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="moody.m.bases.ContractMethod.validate_and_checksum_address" href="../bases.html#moody.m.bases.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="moody.m" href="../index.html">moody.m</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="moody.m.erc20.AllowanceMethod" href="#moody.m.erc20.AllowanceMethod">AllowanceMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.m.erc20.AllowanceMethod.block_call" href="#moody.m.erc20.AllowanceMethod.block_call">block_call</a></code></li>
<li><code><a title="moody.m.erc20.AllowanceMethod.estimate_gas" href="#moody.m.erc20.AllowanceMethod.estimate_gas">estimate_gas</a></code></li>
<li><code><a title="moody.m.erc20.AllowanceMethod.validate_and_normalize_inputs" href="#moody.m.erc20.AllowanceMethod.validate_and_normalize_inputs">validate_and_normalize_inputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.m.erc20.ApproveMethod" href="#moody.m.erc20.ApproveMethod">ApproveMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.m.erc20.ApproveMethod.block_call" href="#moody.m.erc20.ApproveMethod.block_call">block_call</a></code></li>
<li><code><a title="moody.m.erc20.ApproveMethod.build_transaction" href="#moody.m.erc20.ApproveMethod.build_transaction">build_transaction</a></code></li>
<li><code><a title="moody.m.erc20.ApproveMethod.estimate_gas" href="#moody.m.erc20.ApproveMethod.estimate_gas">estimate_gas</a></code></li>
<li><code><a title="moody.m.erc20.ApproveMethod.send_transaction" href="#moody.m.erc20.ApproveMethod.send_transaction">send_transaction</a></code></li>
<li><code><a title="moody.m.erc20.ApproveMethod.validate_and_normalize_inputs" href="#moody.m.erc20.ApproveMethod.validate_and_normalize_inputs">validate_and_normalize_inputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.m.erc20.BalanceOfMethod" href="#moody.m.erc20.BalanceOfMethod">BalanceOfMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.m.erc20.BalanceOfMethod.block_call" href="#moody.m.erc20.BalanceOfMethod.block_call">block_call</a></code></li>
<li><code><a title="moody.m.erc20.BalanceOfMethod.estimate_gas" href="#moody.m.erc20.BalanceOfMethod.estimate_gas">estimate_gas</a></code></li>
<li><code><a title="moody.m.erc20.BalanceOfMethod.validate_and_normalize_inputs" href="#moody.m.erc20.BalanceOfMethod.validate_and_normalize_inputs">validate_and_normalize_inputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.m.erc20.DecreaseAllowanceMethod" href="#moody.m.erc20.DecreaseAllowanceMethod">DecreaseAllowanceMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.m.erc20.DecreaseAllowanceMethod.block_call" href="#moody.m.erc20.DecreaseAllowanceMethod.block_call">block_call</a></code></li>
<li><code><a title="moody.m.erc20.DecreaseAllowanceMethod.build_transaction" href="#moody.m.erc20.DecreaseAllowanceMethod.build_transaction">build_transaction</a></code></li>
<li><code><a title="moody.m.erc20.DecreaseAllowanceMethod.estimate_gas" href="#moody.m.erc20.DecreaseAllowanceMethod.estimate_gas">estimate_gas</a></code></li>
<li><code><a title="moody.m.erc20.DecreaseAllowanceMethod.send_transaction" href="#moody.m.erc20.DecreaseAllowanceMethod.send_transaction">send_transaction</a></code></li>
<li><code><a title="moody.m.erc20.DecreaseAllowanceMethod.validate_and_normalize_inputs" href="#moody.m.erc20.DecreaseAllowanceMethod.validate_and_normalize_inputs">validate_and_normalize_inputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.m.erc20.ERC20" href="#moody.m.erc20.ERC20">ERC20</a></code></h4>
<ul class="two-column">
<li><code><a title="moody.m.erc20.ERC20.CallContractFee" href="#moody.m.erc20.ERC20.CallContractFee">CallContractFee</a></code></li>
<li><code><a title="moody.m.erc20.ERC20.CallDebug" href="#moody.m.erc20.ERC20.CallDebug">CallDebug</a></code></li>
<li><code><a title="moody.m.erc20.ERC20.abi" href="#moody.m.erc20.ERC20.abi">abi</a></code></li>
<li><code><a title="moody.m.erc20.ERC20.allowance" href="#moody.m.erc20.ERC20.allowance">allowance</a></code></li>
<li><code><a title="moody.m.erc20.ERC20.approve" href="#moody.m.erc20.ERC20.approve">approve</a></code></li>
<li><code><a title="moody.m.erc20.ERC20.balance_of" href="#moody.m.erc20.ERC20.balance_of">balance_of</a></code></li>
<li><code><a title="moody.m.erc20.ERC20.decrease_allowance" href="#moody.m.erc20.ERC20.decrease_allowance">decrease_allowance</a></code></li>
<li><code><a title="moody.m.erc20.ERC20.event_approval" href="#moody.m.erc20.ERC20.event_approval">event_approval</a></code></li>
<li><code><a title="moody.m.erc20.ERC20.event_transfer" href="#moody.m.erc20.ERC20.event_transfer">event_transfer</a></code></li>
<li><code><a title="moody.m.erc20.ERC20.increase_allowance" href="#moody.m.erc20.ERC20.increase_allowance">increase_allowance</a></code></li>
<li><code><a title="moody.m.erc20.ERC20.total_supply" href="#moody.m.erc20.ERC20.total_supply">total_supply</a></code></li>
<li><code><a title="moody.m.erc20.ERC20.transfer" href="#moody.m.erc20.ERC20.transfer">transfer</a></code></li>
<li><code><a title="moody.m.erc20.ERC20.transfer_from" href="#moody.m.erc20.ERC20.transfer_from">transfer_from</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.m.erc20.ERC20Validator" href="#moody.m.erc20.ERC20Validator">ERC20Validator</a></code></h4>
</li>
<li>
<h4><code><a title="moody.m.erc20.IncreaseAllowanceMethod" href="#moody.m.erc20.IncreaseAllowanceMethod">IncreaseAllowanceMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.m.erc20.IncreaseAllowanceMethod.block_call" href="#moody.m.erc20.IncreaseAllowanceMethod.block_call">block_call</a></code></li>
<li><code><a title="moody.m.erc20.IncreaseAllowanceMethod.build_transaction" href="#moody.m.erc20.IncreaseAllowanceMethod.build_transaction">build_transaction</a></code></li>
<li><code><a title="moody.m.erc20.IncreaseAllowanceMethod.estimate_gas" href="#moody.m.erc20.IncreaseAllowanceMethod.estimate_gas">estimate_gas</a></code></li>
<li><code><a title="moody.m.erc20.IncreaseAllowanceMethod.send_transaction" href="#moody.m.erc20.IncreaseAllowanceMethod.send_transaction">send_transaction</a></code></li>
<li><code><a title="moody.m.erc20.IncreaseAllowanceMethod.validate_and_normalize_inputs" href="#moody.m.erc20.IncreaseAllowanceMethod.validate_and_normalize_inputs">validate_and_normalize_inputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.m.erc20.TotalSupplyMethod" href="#moody.m.erc20.TotalSupplyMethod">TotalSupplyMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.m.erc20.TotalSupplyMethod.block_call" href="#moody.m.erc20.TotalSupplyMethod.block_call">block_call</a></code></li>
<li><code><a title="moody.m.erc20.TotalSupplyMethod.estimate_gas" href="#moody.m.erc20.TotalSupplyMethod.estimate_gas">estimate_gas</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.m.erc20.TransferFromMethod" href="#moody.m.erc20.TransferFromMethod">TransferFromMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.m.erc20.TransferFromMethod.block_call" href="#moody.m.erc20.TransferFromMethod.block_call">block_call</a></code></li>
<li><code><a title="moody.m.erc20.TransferFromMethod.build_transaction" href="#moody.m.erc20.TransferFromMethod.build_transaction">build_transaction</a></code></li>
<li><code><a title="moody.m.erc20.TransferFromMethod.estimate_gas" href="#moody.m.erc20.TransferFromMethod.estimate_gas">estimate_gas</a></code></li>
<li><code><a title="moody.m.erc20.TransferFromMethod.send_transaction" href="#moody.m.erc20.TransferFromMethod.send_transaction">send_transaction</a></code></li>
<li><code><a title="moody.m.erc20.TransferFromMethod.validate_and_normalize_inputs" href="#moody.m.erc20.TransferFromMethod.validate_and_normalize_inputs">validate_and_normalize_inputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.m.erc20.TransferMethod" href="#moody.m.erc20.TransferMethod">TransferMethod</a></code></h4>
<ul class="">
<li><code><a title="moody.m.erc20.TransferMethod.block_call" href="#moody.m.erc20.TransferMethod.block_call">block_call</a></code></li>
<li><code><a title="moody.m.erc20.TransferMethod.build_transaction" href="#moody.m.erc20.TransferMethod.build_transaction">build_transaction</a></code></li>
<li><code><a title="moody.m.erc20.TransferMethod.estimate_gas" href="#moody.m.erc20.TransferMethod.estimate_gas">estimate_gas</a></code></li>
<li><code><a title="moody.m.erc20.TransferMethod.send_transaction" href="#moody.m.erc20.TransferMethod.send_transaction">send_transaction</a></code></li>
<li><code><a title="moody.m.erc20.TransferMethod.validate_and_normalize_inputs" href="#moody.m.erc20.TransferMethod.validate_and_normalize_inputs">validate_and_normalize_inputs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>