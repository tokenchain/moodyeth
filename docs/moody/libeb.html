<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>moody.libeb API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>moody.libeb</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import codecs
import json
import os
import subprocess
import time
from threading import Lock
from typing import List, Tuple, Optional

import re

# ========================== Of course
from hexbytes import HexBytes
from web3 import Web3, HTTPProvider
from web3.contract import Contract as Web3Contract
from web3.datastructures import AttributeDict
from web3.exceptions import TransactionNotFound, ContractLogicError, InvalidAddress, TimeExhausted
from web3.logs import DISCARD
from web3.middleware import geth_poa_middleware
from web3.types import BlockData

# ========================== Of course
from . import Bolors, Evm, DefaultKeys, root_base_path, MetaSetting
from .buildercompile.remotecompile import BuildRemoteLinuxCommand
from .buildercompile.transpile import BuildLang, filter_file_name, BuildLangForge
from .conf import Config
from .exceptions import FoundUndeployedLibraries
from .paths import Paths


def web3_provider(address: str) -&gt; Web3:
    try:
        if address.startswith(&#39;http&#39;):  # HTTP
            return Web3(Web3.HTTPProvider(address))
        if address.startswith(&#39;ws&#39;):  # WebSocket
            return Web3(Web3.WebsocketProvider(address))
        return Web3(Web3.IPCProvider(address))
    except FileNotFoundError:
        raise ValueError(&#34;Failed to initialize web3 provider (is eth_node set?)&#34;) from None


w3_lock = Lock()
event_lock = Lock()
statement = &#39;End : {}, IO File {}&#39;


def extract_tx_by_address(address, block: BlockData) -&gt; list:
    # Note: block attribute dict has to be generated with full_transactions=True flag
    return [tx for tx in block.transactions if tx.to and address.lower() == tx.to.lower()]


def event_log(tx_hash: str, events: List[str], provider: Web3, contract: Web3Contract) -&gt; Tuple[str, Optional[AttributeDict]]:
    &#34;&#34;&#34;
    Extracts logs of @event from tx_hash if present
    :param tx_hash:
    :param events: Case sensitive events name
    :param provider:
    :param contract: Web3 Contract
    :return: event name and log represented in &#39;AttributeDict&#39; or &#39;None&#39; if not found
    &#34;&#34;&#34;
    try:
        receipt = provider.eth.getTransactionReceipt(tx_hash)
    except TransactionNotFound:
        time.sleep(3000)  # hard coded sleep for 3 seconds... maybe this will help?
        # retry
        try:
            receipt = provider.eth.getTransactionReceipt(tx_hash)
        except TransactionNotFound:
            return &#39;&#39;, None

    for event in events:
        # we discard warning as we do best effort to find wanted event, not always there
        # as we listen to the entire contract tx, might
        log = getattr(contract.events, event)().processReceipt(receipt, DISCARD)
        if log:
            data_index = 0
            return event, log[data_index]
    # todo: fix this - seems like some weird return
    return &#39;&#39;, None


def normalize_address(address: str):
    &#34;&#34;&#34;Converts address to address acceptable by web3&#34;&#34;&#34;
    return Web3.toChecksumAddress(address.lower())


def Logd(anystr: any):
    print(anystr)


def writeFile(content, filename):
    fo = open(filename, &#34;w&#34;)
    fo.write(content)
    fo.close()
    print(statement.format(time.ctime(), filename))


class HexJsonEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, HexBytes):
            return obj.hex()
        return super().default(obj)


def _parseValue(val):
    # check for nested dict structures to iterate through
    if &#39;dict&#39; in str(type(val)).lower():
        return toDict(val)
    # convert &#39;HexBytes&#39; type to &#39;str&#39;
    elif &#39;HexBytes&#39; in str(type(val)):
        return val.hex()
    else:
        return val


def toDict(dictToParse):
    # convert any &#39;AttributeDict&#39; type found to &#39;dict&#39;
    parsedDict = dict(dictToParse)
    for key, val in parsedDict.items():
        if &#39;list&#39; in str(type(val)):
            parsedDict[key] = [_parseValue(x) for x in val]
        else:
            parsedDict[key] = _parseValue(val)
    return parsedDict


# binops
regex1 = r&#34;\/\/*.*&#34;
# solidity version cutter
regex2 = r&#34;^(\d+\.)?(\d+\.)?(\*|\d+)&#34;


class IDos:
    def hasContractName(self, name: str) -&gt; bool:
        pass

    def getAddr(self, keyname: str) -&gt; str:
        pass

    def isAddress(self, add: str) -&gt; bool:
        pass


class BinOp:
    &#34;&#34;&#34;
    The binary operation for the ops. Taking care the operations for library linking and the related stuffs.
    &#34;&#34;&#34;

    def __init__(self, bin_content: str, file_name: str):
        self.bin_raw = bin_content
        self.bin_knifed = bin_content
        self.bin_undeploy_lib = dict()
        self.file_name = file_name
        self.debug = False

    def setDebug(self, de: bool):
        self.debug = de

    def GetRawBin(self) -&gt; str:
        return self.bin_raw

    def GetKnifedBin(self) -&gt; str:
        return self.bin_knifed

    def checkBinForUndeployLib(self) -&gt; bool:
        matches = re.finditer(regex1, self.bin_raw, re.MULTILINE)
        found = False
        for matchNum, match in enumerate(matches, start=1):
            print(&#34;Library {matchNum} is found at {start}-{end}: {match}&#34;.format(matchNum=matchNum, start=match.start(), end=match.end(), match=match.group()))
            k, v = self.fromLine(match.group())
            self.bin_undeploy_lib[k] = v
            found = True
        return found

    def fromLine(self, input_line: str) -&gt; Tuple[str, str]:
        class_name = input_line.split(&#34;:&#34;)[1]
        return class_name, input_line

    def _placehd(self, instruction_line: str) -&gt; str:
        return &#34;__{}__&#34;.format(str(instruction_line).split(&#34;-&gt;&#34;)[0].strip(&#34; //&#34;))

    def anaylze(self, databank: IDos) -&gt; bool:
        if len(self.bin_undeploy_lib) == 0:
            print(&#34;🚧 Nothing to process&#34;)
            return False

        for class_name, instruction_line in self.bin_undeploy_lib.items():
            if databank.hasContractName(class_name) is True:
                print(f&#34;💽 Found support Class {class_name} - deployment address&#34;)
                if databank.isAddress(databank.getAddr(class_name)):
                    self._knifeBinClass(class_name, self._placehd(instruction_line), databank.getAddr(class_name))
                else:
                    print(&#34;🧊 The found library address is not valid - {}, {}&#34;.format(class_name, databank.getAddr(class_name)))
                    raise FoundUndeployedLibraries
            else:
                print(&#34;⚠️ Unfound library Error- {}, please make sure you have this library deployed.&#34;.format(class_name))
                raise FoundUndeployedLibraries

        self.bin_knifed = self.bin_knifed.splitlines(True)[0]
        self.bin_knifed = self.bin_knifed.replace(&#34;\n&#34;, &#34;&#34;)
        # self.bin_knifed = &#34;0x&#34; + self.bin_knifed
        if self.debug is True:
            print(f&#34;After processed bin file - {self.file_name}.bin (should be done now)&#34;)
            print(self.bin_knifed)
            # print(self.bin_raw)
            print(&#34;File content end ##&#34;)
        else:
            print(f&#34;After processed bin file - {self.file_name}.bin&#34;)

        return True

    def _knifeBinClass(self, c: str, k: str, address: str) -&gt; None:
        # address_step_1 = address.lower()
        address_step_2 = address.replace(&#34;0x&#34;, &#34;&#34;)
        self.bin_knifed = self.bin_knifed.replace(k, address_step_2)
        print(f&#34;🍡 Linked successfully for Solidity Class {c} with {address}&#34;)


class SolWeb3Tool(object):
    &#34;&#34;&#34;
    This is the tool to build operation of the compiling solidity contract source code
    Try to make some improvement of code to make better access
    This is the artifact manager as we know it
    &#34;&#34;&#34;
    OUTPUT_BUILD = &#34;build&#34;
    WORKSPACE_PATH = &#34;&#34;
    solfolder = &#34;&#34;
    file_name = &#34;xxx.sol&#34;
    prefixname = &#34;&#34;
    statement = &#39;End : {}, IO File {}&#39;

    def __init__(self):
        self._abi = None
        self._bin = None
        self._meta = None
        self.combined_data = None
        self._key = None

    def setBuildNameSpace(self, path: str) -&gt; &#34;SolWeb3Tool&#34;:
        self.OUTPUT_BUILD = path
        return self

    def setBasePath(self, path: str) -&gt; &#34;SolWeb3Tool&#34;:
        self.WORKSPACE_PATH = path
        return self

    def SplitForgeBuild(self, class_name: str) -&gt; &#34;SolWeb3Tool&#34;:
        uncutjson = dict()
        combinedjson = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}.sol&#34;.format(class_name), &#34;{}.json&#34;.format(class_name))
        try:
            uncutjson = json.load(codecs.open(combinedjson, &#39;r&#39;, &#39;utf-8-sig&#39;))
        except FileNotFoundError:
            print(&#34;Some of the files from the build in forge is not found&#34;)
            exit(3)
        abifile = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}.sol&#34;.format(class_name), &#34;{}.abi&#34;.format(class_name))
        binfile = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}.sol&#34;.format(class_name), &#34;{}.bin&#34;.format(class_name))

        if &#34;abi&#34; in uncutjson:
            predum = uncutjson[&#34;abi&#34;]
            writeFile(json.dumps(predum, ensure_ascii=False), abifile)

        if &#34;deployedBytecode&#34; in uncutjson:
            pr = uncutjson[&#34;deployedBytecode&#34;]
            if &#34;object&#34; in pr:
                pr2 = pr[&#34;object&#34;]
                pr2 = pr2.replace(&#34;0x&#34;, &#34;&#34;)
                writeFile(pr2, binfile)
            if &#34;linkReferences&#34; in pr:
                links = pr[&#34;linkReferences&#34;]
                for a in links:
                    print(&#34;found link&#34;)

        return self

    def GetCodeClassFromBuild(self, class_name: str) -&gt; &#34;SolWeb3Tool&#34;:
        &#34;&#34;&#34;
        get the independent files and content from the file system
        :param class_name:
        :return:
        &#34;&#34;&#34;
        p1bin = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}.bin&#34;.format(class_name))
        p2abi = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}.abi&#34;.format(class_name))
        metafile = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}_meta.json&#34;.format(class_name))
        try:
            self._bin = codecs.open(p1bin, &#39;r&#39;, &#39;utf-8-sig&#39;).read()
            self._abi = json.load(codecs.open(p2abi, &#39;r&#39;, &#39;utf-8-sig&#39;))
            self._meta = json.load(codecs.open(metafile, &#39;r&#39;, &#39;utf-8-sig&#39;))
        except FileNotFoundError:
            print(&#34;Some of the files from the build is not found&#34;)
            exit(3)
        return self

    def LoadInternalMeta(self, class_name: str) -&gt; &#34;SolWeb3Tool&#34;:
        metafile = os.path.join(root_base_path, self.OUTPUT_BUILD, &#34;{}_meta.json&#34;.format(class_name))
        self._meta = json.load(codecs.open(metafile, &#39;r&#39;, &#39;utf-8-sig&#39;))
        return self

    def GetMetadata(self) -&gt; dict:
        return self._meta

    def GetSourceFileRead(self, file_name: str) -&gt; str:
        asfile = os.path.join(self.WORKSPACE_PATH, file_name)
        return self.ReadAsStr(asfile)

    def ReadAsStr(self, file_name: str) -&gt; str:
        return codecs.open(file_name, &#39;r&#39;, &#39;utf-8-sig&#39;).read()

    def ReadAsStrAndEscape(self, file_name: str) -&gt; str:
        loaded = self.ReadAsStr(file_name)
        return re.escape(loaded)

    def GetMetaCompilerVer(self, full: bool = False) -&gt; str:
        if &#34;compiler&#34; not in self._meta:
            print(&#34;key compiler is not found&#34;)
            return &#34;&#34;
        if &#34;version&#34; not in self._meta[&#34;compiler&#34;]:
            print(&#34;key version is not found&#34;)
            return &#34;&#34;

        version_text = self._meta[&#34;compiler&#34;][&#34;version&#34;]
        matches = re.search(regex2, version_text)

        if full is True:
            return version_text.replace(&#39;.Emscripten.clang&#39;, &#39;&#39;)
        else:
            return matches.group()

    def GetMetaSettings(self) -&gt; any:

        if &#34;settings&#34; not in self._meta:
            print(&#34;key settings is not found&#34;)
            return False
        if &#34;evmVersion&#34; not in self._meta[&#34;settings&#34;]:
            print(&#34;key version is not found&#34;)
            return False
        if &#34;libraries&#34; not in self._meta[&#34;settings&#34;]:
            print(&#34;key version is not found&#34;)
            return False

        if &#34;optimizer&#34; not in self._meta[&#34;settings&#34;]:
            print(&#34;key version is not found&#34;)
            return False

        meta = MetaSetting(
            evm=self._meta[&#34;settings&#34;][&#34;evmVersion&#34;],
            solidity_ver=self.GetMetaCompilerVer(False),
            solidity_ver_full=self.GetMetaCompilerVer(True),
            linkLib=self._meta[&#34;settings&#34;][&#34;libraries&#34;],
            optimization_runs=self._meta[&#34;settings&#34;][&#34;optimizer&#34;][&#34;runs&#34;],
            optimization_enabled=self._meta[&#34;settings&#34;][&#34;optimizer&#34;][&#34;enabled&#34;]
        )

        return meta

    def GetCombinedFile(self) -&gt; &#34;SolWeb3Tool&#34;:
        pathc = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;combined.json&#34;)
        try:
            pathcli = codecs.open(pathc, &#39;r&#39;, &#39;utf-8-sig&#39;)
            self.combined_data = json.load(pathcli)
        except Exception as e:
            print(&#34;Problems from loading items from the file: &#34;, e)
        return self

    def byClassName(self, path: str, classname: str) -&gt; str:
        # generating the string with path and class name
        return &#34;{prefix}:{name}&#34;.format(prefix=path, name=classname)

    def GetCodeTag(self, fullname) -&gt; [str, str]:
        &#34;&#34;&#34;
        Search for the abi session and the bin session from the meta source file
        from combined.json
        :param fullname: initial file name
        :return: abi code and the bin code
        &#34;&#34;&#34;
        return self.combined_data[&#34;contracts&#34;][fullname][&#34;abi&#34;], self.combined_data[&#34;contracts&#34;][fullname][&#34;bin&#34;]

    def GetCode(self, path: str, classname: str) -&gt; [str, str]:
        &#34;&#34;&#34;
        Search for the abi session and the bin session from the meta source file
        get the code and abi from combined.json
        :param path:
        :param classname:
        :return:
        &#34;&#34;&#34;
        return self.GetCodeTag(self.byClassName(path, classname))

    def CompileBash(self) -&gt; None:
        &#34;&#34;&#34;
        This is the remote command to execute the solc_remote bash file
        using remote compile method to compile the sol files
        all works will be done with the remote server or using the docker
        &#34;&#34;&#34;
        list_files = subprocess.run([&#34;{}/solc_remote&#34;.format(self.WORKSPACE_PATH)])
        print(&#34;The exit code was: %d&#34; % list_files.returncode)

    @property
    def abi(self) -&gt; str:
        return self._abi

    @property
    def bin(self) -&gt; str:
        return self._bin

    @property
    def workspace(self) -&gt; str:
        return self.WORKSPACE_PATH

    def StoreTxResult(self, tx_result_data: any, filepath: str) -&gt; None:
        &#34;&#34;&#34;
        Having the result of the transaction data to be stored in an external JSON file.
        :param tx_result_data: input data
        :param filepath: the file name path
        :return: nothing to return
        &#34;&#34;&#34;
        predump = toDict(tx_result_data)
        writeFile(json.dumps(predump, ensure_ascii=False), filepath)


class MiliDoS(IDos):
    &#34;&#34;&#34;
    This is the base package function core for all the related operations to execute
    The center hub of the progress source code is in here
    &#34;&#34;&#34;

    EVM_VERSION = Evm.BERLIN

    def __init__(self, _nodeCfg: Config):
        # the hidden list
        self._contract_dict = dict()
        self._sol_list = list()
        # publicly accessible
        self.project_workspace_root = &#34;&#34;
        self.accountAddr = None
        self.pathfinder = None
        self.artifact_manager = None
        self._sol_link = None
        self.is_deploy = False
        self.is_internal = False
        self.is_forge = False
        self.deployed_address = False
        self.last_class = &#34;&#34;
        self.list_type = &#34;list_address&#34;
        self.network_cfg = _nodeCfg
        self.w3 = web3_provider(_nodeCfg.rpc_url)
        self._optimizations = 200
        result = self.w3.isConnected()
        if not result:
            print(f&#34;try to connect {self.network_cfg.network_name}  {Bolors.WARNING} {self.network_cfg.rpc_url}: {result} {Bolors.RESET}&#34;)
            exit(0)
            return
        else:
            print(f&#34;You are now connected to {Bolors.OK} {self.network_cfg.network_name} {self.network_cfg.rpc_url} {Bolors.RESET}&#34;)

    def withPOA(self) -&gt; &#34;MiliDoS&#34;:
        &#34;&#34;&#34;
        the normal usual term to fix some POA related problems
        :return:
        &#34;&#34;&#34;
        self.w3.middleware_onion.inject(geth_poa_middleware, layer=0)
        return self

    def isAddress(self, address: str) -&gt; bool:
        &#34;&#34;&#34;
        Verification of the valid EVM address
        :param address:
        :return:
        &#34;&#34;&#34;
        return self.w3.isAddress(address)

    def connect(self, workspace: str, history: any) -&gt; None:

        &#34;&#34;&#34;
        connect the existing deployed contract
        :param workspace: the workspace directory
        :param history: the deployed history folder under the deploy_history
        :return:
        &#34;&#34;&#34;
        self.is_deploy = False
        self.artifact_manager = SolWeb3Tool()
        if history is False:
            self.pathfinder = Paths(workspace).setDefaultPath().Network(self.network_cfg.network_name)
        else:
            self.pathfinder = Paths(workspace).SetUseHistory(history).Network(self.network_cfg.network_name)

        self.ready_io(True)

    def SetupContract(self):
        pass

    def after_deployment_initialize_settings(self):
        &#34;&#34;&#34;
        setup contract starting params
        setup the starting time using bang
        setup the first member
        :return:
        &#34;&#34;&#34;
        pass

    def setWorkspace(self, path: str, readio: bool = True) -&gt; &#34;MiliDoS&#34;:
        self.project_workspace_root = path
        self.artifact_manager = SolWeb3Tool()
        self.pathfinder = Paths(path).setDefaultPath().Network(self.network_cfg.network_name)
        if readio:
            self.ready_io(True)
        return self

    def setClassSolNames(self, to_compile_contract_list: list) -&gt; &#34;MiliDoS&#34;:
        self._sol_list = to_compile_contract_list
        return self

    def setClassSolLinks(self, compile_links: list) -&gt; &#34;MiliDoS&#34;:
        self._sol_link = compile_links
        return self

    def setEvm(self, version_evm: str) -&gt; &#34;MiliDoS&#34;:
        &#34;&#34;&#34;
        the specify the version of the ethereum virtual machine
        :param version_evm: the version of the EVM
        :return:
        &#34;&#34;&#34;
        self.EVM_VERSION = version_evm
        return self

    def setOptimizationRuns(self, runs: int) -&gt; &#34;MiliDoS&#34;:
        self._optimizations = runs
        return self

    def remoteCompile(self, ver: str) -&gt; &#34;MiliDoS&#34;:
        &#34;&#34;&#34;
        all parameters will be inserted automatically according to the previous setup
        :param ver:
        :return:
        &#34;&#34;&#34;
        if ver == &#34;&#34;:
            print(&#34;there is no solidity version specified&#34;)
            exit(0)
        self.pathfinder.setSolVersion(ver)
        self.pathfinder.setEvm(self.EVM_VERSION)
        BuildRemoteLinuxCommand(self.pathfinder, self._optimizations, self._sol_list, self._sol_link)
        return self

    def useForge(self) -&gt; &#34;MiliDoS&#34;:
        # ==================================================
        if self._sol_list is not None:
            for v in self._sol_list:
                based_name = os.path.basename(v)
                class_name = based_name.replace(&#34;.sol&#34;, &#34;&#34;)
                # class_name_process = filter_file_name(based_name).replace(&#39;.sol&#39;, &#39;&#39;)
                self.artifact_manager.SplitForgeBuild(class_name)
            self.is_forge = True
        return self

    def localTranspile(self, dapp_ts_folder: str = None) -&gt; &#34;MiliDoS&#34;:
        &#34;&#34;&#34;
        :param dapp_ts_folder: the destination is follow by this path {dapp_ts_folder}/src/api/abi/xxx.ts
        if this valuable is None then there will not be any copy files to the destination
        :return: instance of moody
        &#34;&#34;&#34;
        self.pathfinder.updateTargetDappFolder(dapp_ts_folder)
        if self.is_forge:
            BuildLangForge(self.pathfinder, self._sol_list)
        else:
            BuildLang(self.pathfinder, self._sol_list)
        return self

    def get_block(self, block_identifier, full_transactions: bool = False):
        &#34;&#34;&#34;
        to see the block information
        :param block_identifier:
        :param full_transactions:
        :return: instance of moody
        &#34;&#34;&#34;
        with w3_lock:
            res = self.w3.eth.getBlock(block_identifier, full_transactions)
        return res

    def erc20_contract(self):
        cTool = SolWeb3Tool()
        cTool.setBuildNameSpace(&#34;artifact&#34;).GetCodeClassFromBuild(&#34;ERC20&#34;)
        return self.w3.eth.contract(abi=cTool.abi)

    def estimate_gas_price(self):
        return self.w3.eth.gasPrice

    def send_contract_tx(self, contract: Web3Contract, function_name: str, from_acc: str,
                         private_key: bytes, gas: int = 0, gas_price: int = 0, _value: int = 0,
                         args: Tuple = ()):
        &#34;&#34;&#34;
        Creates the contract tx and signs it with private_key to be transmitted as raw tx
        &#34;&#34;&#34;

        tx = getattr(contract.functions, function_name)(*args).buildTransaction(
            {
                &#39;from&#39;: from_acc,
                &#39;chainId&#39;: self.w3.eth.chainId,
                # gas_price is in gwei
                &#39;gasPrice&#39;: gas_price * 1e9 if gas_price else self.estimate_gas_price(),
                &#39;gas&#39;: gas or None,
                &#39;nonce&#39;: self.w3.eth.getTransactionCount(from_acc, block_identifier=&#39;pending&#39;),
                &#39;value&#39;: _value
            })
        signed_txn = self.w3.eth.account.sign_transaction(tx, private_key)
        return self.w3.eth.sendRawTransaction(signed_txn.rawTransaction)

    def contract_event_in_range(self, contract, event_name: str, from_block: int = 0, to_block: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        scans the blockchain, and yields blocks that has contract tx with the provided event
        Note: Be cautions with the range provided, as the logic creates query for each block which could be a bottleneck.
        :param from_block: starting block, defaults to 0
        :param to_block: end block, defaults to &#39;latest&#39;
        :param provider:
        :param logger:
        :param contract:
        :param event_name: name of the contract emit event you wish to be notified of
        &#34;&#34;&#34;
        if to_block is None:
            to_block = self.w3.eth.blockNumber

        with w3_lock:

            if isinstance(self.w3.provider, HTTPProvider):
                for block_num in range(from_block, to_block + 1):
                    block = self.w3.eth.getBlock(block_num, full_transactions=True)
                    contract_transactions = extract_tx_by_address(contract.address, block)

                    if not contract_transactions:
                        continue
                    for tx in contract_transactions:
                        _, log = event_log(tx_hash=tx.hash, events=[event_name], provider=self.w3, contract=contract.tracked_contract)
                        if log is None:
                            continue
                        yield log
            else:
                event = getattr(contract.tracked_contract.events, event_name)
                event_filter = event.createFilter(fromBlock=from_block, toBlock=to_block)

                for tx in event_filter.get_new_entries():
                    _, log = event_log(tx_hash=tx.hash, events=[event_name], provider=self.w3, contract=contract.tracked_contract)

                    if log is None:
                        continue

                    yield log

    def AuthByMemo(self, phrase: str = None) -&gt; &#34;MiliDoS&#34;:
        keyLo = self.w3.eth.account.from_mnemonic(phrase)
        # self.w3.eth.defaultAccount = keyoo.address
        self.w3.eth.account = keyLo
        # self.w3.eth.get_transaction_count
        # self.w3.eth.accounts[0] = keyLo.address
        # self.w3.eth.defaultAccount(f&#34;0x{keyLo.key}&#34;)
        is_address = self.w3.isAddress(keyLo.address)
        # self.w3.isChecksumAddress(keyLo.address)
        self.accountAddr = keyLo.address
        print(f&#34;🔫 You are now using {keyLo.address} and it is a {&#39;valid key&#39; if is_address else &#39;invalid key&#39;}&#34;)

        return self

    def Auth(self, private_key_line: str = None) -&gt; &#34;MiliDoS&#34;:
        &#34;&#34;&#34;
        switching the operating address to a different one that is given by the private key
        :param private_key_line: the input private key
        :return:
        &#34;&#34;&#34;
        if private_key_line is None:
            private_key_line = DefaultKeys.k0

        # f&#34;0x{private_key_line}&#34;
        keyLo = self.w3.eth.account.from_key(f&#34;0x{private_key_line}&#34;)
        # self.w3.eth.defaultAccount = keyoo.address
        self.w3.eth.account = keyLo
        # self.w3.eth.get_transaction_count
        # self.w3.eth.accounts[0] = keyLo.address
        # self.w3.eth.defaultAccount(f&#34;0x{keyLo.key}&#34;)
        is_address = self.w3.isAddress(keyLo.address)
        # self.w3.isChecksumAddress(keyLo.address)
        self.accountAddr = keyLo.address
        print(f&#34;🔫 You are now using {keyLo.address} and it is a {&#39;valid key&#39; if is_address else &#39;invalid key&#39;}&#34;)

        return self

    def estimateGas(self, class_name: str) -&gt; int:
        &#34;&#34;&#34;
        only for testing the contract deploy gas requirement
        :param class_name:
        :return:
        &#34;&#34;&#34;
        # estimate_gas
        solc_artifact = SolWeb3Tool()
        solc_artifact.setBasePath(self.project_workspace_root)
        solc_artifact = solc_artifact.GetCodeClassFromBuild(class_name)
        nr = self.w3.eth.contract(abi=solc_artifact.abi, bytecode=solc_artifact.bin)
        gas_est_amount = nr.constructor().estimateGas()
        price = self.w3.eth.generate_gas_price()
        # source: https://ethereum.stackexchange.com/questions/84943/what-is-the-equivalent-of-buildtransaction-of-web3py-in-web3js
        print(f&#34;Price: {price}&#34;)
        return gas_est_amount

    def OverrideGasConfig(self, gas: int, gas_price: int) -&gt; None:
        &#34;&#34;&#34;
        the override the configuration for the gas amount and the gas price
        :param gas: int
        :param gas_price: int
        :return: NONE
        &#34;&#34;&#34;
        self.network_cfg.gas = gas
        self.network_cfg.gasPrice = gas_price

    def OverrideChainConfig(self, one: int, wait: int) -&gt; None:
        &#34;&#34;&#34;
        Lets have the configuration done now.
        :param one: ONE coin to measure
        :param wait: the waiting time from each block confirmation
        :return:
        &#34;&#34;&#34;
        self.network_cfg.wait_time = wait
        self.network_cfg.one = one

    @property
    def gas(self) -&gt; int:
        return self.network_cfg.gas

    @property
    def gasPrice(self) -&gt; int:
        return self.network_cfg.gasPrice

    @property
    def one(self) -&gt; int:
        &#34;&#34;&#34;
        ONE platform coin will be decoded to be...
        :return: int
        &#34;&#34;&#34;
        return self.network_cfg.one

    @property
    def waitSec(self) -&gt; int:
        return self.network_cfg.wait_time

    @property
    def LinkVRFHashKey(self) -&gt; str:
        if self.network_cfg.link_keyhash is None:
            raise ValueError(&#34;Link VRF Hash Key is endorsed on this network&#34;)
        else:
            return self.network_cfg.link_keyhash

    @property
    def LinkVRFCoordinator(self) -&gt; str:
        if self.network_cfg.link_vrf_coordinator is None:
            raise ValueError(&#34;Link VRF is endorsed on this network&#34;)
        else:
            return self.network_cfg.link_vrf_coordinator

    @property
    def LinkTokenAddress(self) -&gt; str:
        if self.network_cfg.link_token is None:
            raise ValueError(&#34;Link Token is endorsed on this network&#34;)
        else:
            return self.network_cfg.link_token

    def _checkErrorForTxReceipt(self, receipt: any, class_name: str, jsonfile: str) -&gt; None:
        if &#34;contractAddress&#34; not in receipt:
            print(f&#34;⚠️ Error from deploy contract and no valid address found for {class_name}.&#34;)
            raise InvalidAddress

        if &#34;transactionHash&#34; not in receipt:
            print(f&#34;⚠️ The deployment is failed because there is no valid address found from {class_name}. Please check for internal errors from deployment has {receipt.transactionHash}&#34;)
            raise InvalidAddress

        hash = str(receipt.transactionHash)
        preaddress = str(receipt.contractAddress)
        if self.isAddress(preaddress) is False:
            print(f&#34;⚠️ The deployment is failed because there is no valid address found from {class_name}. Please check for internal errors from deployment hash from {jsonfile}&#34;)
            raise InvalidAddress

    def provide_artifact_extends(self, class_name: str) -&gt; SolWeb3Tool:
        &#34;&#34;&#34;
        Following the class name of the contract
        :param class_name:
        :return:
        &#34;&#34;&#34;
        if not self.artifact_manager:
            print(&#34;❌ Root path is not setup. please setup the workspace first.&#34;)
            exit(2)

        sol = self.artifact_manager
        sol.setBasePath(self.project_workspace_root)
        sol.setBuildNameSpace(&#34;build&#34;)
        sol = sol.GetCodeClassFromBuild(class_name)
        self.artifact_manager = sol
        return sol

    def provide_artifact_implemented(self, class_name: str) -&gt; SolWeb3Tool:
        &#34;&#34;&#34;
        Use the internal available class names. Please see the internal class name list
        :param class_name:
        :return:
        &#34;&#34;&#34;
        if not self.artifact_manager:
            print(&#34;❌ Root path is not setup. please setup the workspace first.&#34;)
            exit(2)

        sol = self.artifact_manager
        sol.setBasePath(root_base_path)
        sol.setBuildNameSpace(&#34;artifacts&#34;)
        sol = sol.GetCodeClassFromBuild(class_name)
        self.artifact_manager = sol
        return sol

    def deployImple(self, class_name: str, params: list = [], gas_price: int = 0, gas_limit: int = 0) -&gt; bool:
        &#34;&#34;&#34;
        Deployment of implemented abi and code
        :param class_name:
        :param params:
        :param gas_price:
        :param gas_limit:
        :return:
        &#34;&#34;&#34;
        contract_nv = None
        try:
            solc_artifact = self.provide_artifact_implemented(class_name)
            bin = BinOp(solc_artifact.bin, class_name)
            if bin.checkBinForUndeployLib() is True:
                bin.setDebug(True)
                # try to find the needed libraries in address..
                bin.anaylze(self)
                contract_nv = self.w3.eth.contract(abi=solc_artifact.abi, bytecode=bin.GetKnifedBin())
            else:
                contract_nv = self.w3.eth.contract(abi=solc_artifact.abi, bytecode=bin.GetRawBin())

        except FileNotFoundError:
            print(&#34;💢 bin or abi file is not found.&#34;)
            exit(3)
        except FoundUndeployedLibraries:
            exit(4)
        except ContractLogicError as e:
            print(f&#34;💢 Contract error {e}&#34;)
            exit(5)
        gasprice = self.gasPrice if gas_price == 0 else gas_price
        gas = self.gas if gas_limit == 0 else gas_limit
        if len(params) &gt; 0:
            _transaction = contract_nv.constructor(*params).buildTransaction({
                &#34;gasPrice&#34;: gasprice,
                &#34;gas&#34;: gas
            })
        else:
            _transaction = contract_nv.constructor().buildTransaction({
                &#34;gasPrice&#34;: gasprice,
                &#34;gas&#34;: gas
            })
        self.artifact_manager.setBasePath(self.project_workspace_root)
        return self._endingdeployment(_transaction, class_name)

    def deploy(self, class_name: str, params: list = [], gas_price: int = 0, gas_limit: int = 0) -&gt; bool:
        &#34;&#34;&#34;
        This is using the faster way to deploy files by using the specific abi and bin files.
        If all these parameters to be ignored then these things will be taken from other available
        valuables for gas price and gas limit
        :param class_name: the input class name
        :param params: the parameters
        :param gas_price: the gas price
        :param gas_limit: the gas limit
        :return:
        &#34;&#34;&#34;
        contract_nv = None
        try:
            solc_artifact = self.provide_artifact_extends(class_name)
            bin = BinOp(solc_artifact.bin, class_name)
            if bin.checkBinForUndeployLib() is True:
                bin.setDebug(True)
                # try to find the needed libraries in address..
                bin.anaylze(self)
                contract_nv = self.w3.eth.contract(abi=solc_artifact.abi, bytecode=bin.GetKnifedBin())
            else:
                contract_nv = self.w3.eth.contract(abi=solc_artifact.abi, bytecode=bin.GetRawBin())

        except FileNotFoundError:
            print(&#34;💢 bin or abi file is not found.&#34;)
            exit(3)
        except FoundUndeployedLibraries:
            exit(4)
        except ContractLogicError as e:
            print(f&#34;💢 Contract error {e}&#34;)
            exit(5)

        gasprice = self.gasPrice if gas_price == 0 else gas_price
        gas = self.gas if gas_limit == 0 else gas_limit
        if len(params) &gt; 0:
            _transaction = contract_nv.constructor(*params).buildTransaction({
                &#34;gasPrice&#34;: gasprice,
                &#34;gas&#34;: gas
            })
        else:
            _transaction = contract_nv.constructor().buildTransaction({
                &#34;gasPrice&#34;: gasprice,
                &#34;gas&#34;: gas
            })
        return self._endingdeployment(_transaction, class_name)

    def _endingdeployment(self, _transaction: any, class_name: str) -&gt; bool:
        try:
            _transaction[&#39;nonce&#39;] = self.w3.eth.getTransactionCount(self.accountAddr)
            _transaction[&#39;to&#39;] = None
            # _transaction[&#39;gas&#39;] = self.gas if gas_limit == 0 else gas_limit
            # _transaction[&#39;gasPrice&#39;] = self.gasPrice if gas_price == 0 else gas_price
            # _transaction[&#39;gas&#39;] = 2200000000,
            print(&#34;ok --- &#34;, _transaction)
            # Get correct transaction nonce for sender from the node
            print(f&#34;========🖍 Signing {class_name}, gas:{_transaction[&#39;gas&#39;]}, price:{_transaction[&#39;gasPrice&#39;]} ...&#34;)
            signed = self.w3.eth.account.sign_transaction(_transaction)

            txHash = self.w3.eth.sendRawTransaction(signed.rawTransaction)
            # print(f&#34;Contract &#39;{class_name}&#39; deployed; Waiting to transaction receipt&#34;)
            print(f&#34;========Wait for Block Confirmation - {class_name} ☕️&#34;)
            tx_receipt = self.w3.eth.waitForTransactionReceipt(txHash)
            print(&#34;========TX Pre-Result ✅&#34;)
            print(tx_receipt)
            print(f&#34;========Broadcast Result ✅ -&gt; {Paths.showCurrentDeployedClass(class_name)}&#34;)

            self._checkErrorForTxReceipt(tx_receipt, class_name, Paths.showCurrentDeployedClass(class_name))
            fresh_address = tx_receipt.contractAddress
            self._contract_dict[class_name] = fresh_address
            self.deployed_address = fresh_address
            self.setTargetClass(class_name)
            self.setKV(&#34;by&#34;, self.accountAddr)
            print(&#34;📦 Address saved to ✅ {} -&gt; {}&#34;.format(fresh_address, class_name))
            print(f&#34;🔍 You can check with the explorer for more detail: {Bolors.WARNING} {self.network_cfg.block_explorer}{Bolors.RESET}&#34;)

            self.artifact_manager.StoreTxResult(tx_receipt, self.pathfinder.classObject(class_name))
            self.complete_deployment()
            return True
        except InvalidAddress:
            return False
        except ContractLogicError as e:
            print(f&#34;Error: {e}&#34;)
            return False
        except TimeExhausted:
            print(&#34;After 120 seconds, the boardcast block is not in the chain.&#34;)
            return False
        except ValueError as te:
            if &#34;code&#34; in te:
                code = int(te[&#34;code&#34;])
                if code == -32000:
                    print(&#34;NOT ENOUGH GAS - insufficient funds for gas&#34;)
                    return False
            print(te)
            return False

    @property
    def __list_key_label(self) -&gt; str:
        return &#34;{}_{}&#34;.format(self.list_type, self.last_class)

    @property
    def __kv_label(self) -&gt; str:
        return &#34;kv_{}&#34;.format(self.last_class)

    def getAddr(self, keyname: str) -&gt; str:
        &#34;&#34;&#34;example: TT67rPNwgmpeimvHUMVzFfKsjL9GZ1wGw8&#34;&#34;&#34;
        return self._contract_dict.get(keyname)

    def getAllAddress(self) -&gt; dict:
        return self._contract_dict

    def preview_all_addresses(self) -&gt; None:
        print(self._contract_dict)

    def is_deployment(self) -&gt; bool:
        return self.is_deploy

    def ready_io(self, show_address: bool = False):
        &#34;&#34;&#34;try to load up the file from the existing path&#34;&#34;&#34;
        try:
            self._contract_dict = self.pathfinder.LoadDeploymentFile()
            print(&#34;📦 Review the loaded deployment data from ... &#34;)
            if show_address:
                self.preview_all_addresses()
        except FileNotFoundError:
            print(&#34;💢 Deployment File is not found ...&#34;)
        except TypeError as e:
            print(e)

    def setTargetClass(self, classname: str) -&gt; &#34;MiliDoS&#34;:
        self.last_class = classname
        return self

    def setTargetListName(self, listname: str) -&gt; &#34;MiliDoS&#34;:
        self.list_type = listname
        return self

    def setKV(self, key: str, value: any) -&gt; &#34;MiliDoS&#34;:
        if self.__kv_label not in self._contract_dict:
            self._contract_dict[self.__kv_label] = dict()
        self._contract_dict[self.__kv_label][key] = value
        return self

    def hasAddressInList(self, address: str) -&gt; bool:
        if self.__list_key_label not in self._contract_dict:
            return False
        try:
            v = self._contract_dict[self.__list_key_label].index(address)
            return True
        except ValueError:
            return False

    def pushAddress(self, address: str, unique: bool = True) -&gt; bool:
        if self.__list_key_label not in self._contract_dict:
            self._contract_dict[self.__list_key_label] = list()

        if unique is True:
            try:
                found_index = self._contract_dict[self.__list_key_label].index(address)
                return False
            except ValueError:
                self._contract_dict[self.__list_key_label].append(address)
                return True
            except IndexError:
                self._contract_dict[self.__list_key_label].append(address)
                return True
        else:
            self._contract_dict[self.__list_key_label].append(address)
            return True

    def removeAddress(self, address: str) -&gt; bool:
        if self.__list_key_label not in self._contract_dict:
            return False
        self._contract_dict[self.__list_key_label].remove(address)
        return True

    def iterList(self) -&gt; iter:
        if self.__list_key_label not in self._contract_dict:
            raise Exception(&#34;there is no list in the map&#34;)
        return iter(self._contract_dict[self.__list_key_label])

    def hasList(self) -&gt; bool:
        if self.__list_key_label not in self._contract_dict:
            return False
        return len(self._contract_dict[self.__list_key_label]) &gt; 0

    def hasField(self, key: str) -&gt; bool:
        if self.__kv_label not in self._contract_dict:
            self._contract_dict[self.__kv_label] = dict()

        if key not in self._contract_dict[self.__kv_label]:
            return False
        else:
            return True

    def hasContractName(self, name: str) -&gt; bool:
        return name in self._contract_dict

    def getString(self, key: str) -&gt; str:
        return str(self.getVal(key))

    def getInt(self, key: str) -&gt; int:
        return int(self.getVal(key))

    def getBytesArray(self, key: str) -&gt; bytearray:
        return bytearray(self.getVal(key))

    def getBytes(self, key: str) -&gt; bytes:
        return bytes(self.getVal(key))

    def getFloat(self, key: str) -&gt; float:
        return float(self.getVal(key))

    def getVal(self, key: str) -&gt; any:
        if self.__kv_label not in self._contract_dict:
            self._contract_dict[self.__kv_label] = dict()

        if key in self._contract_dict[self.__kv_label]:
            return self._contract_dict[self.__kv_label][key]

        return &#34;&#34;

    def complete_deployment(self) -&gt; None:
        &#34;&#34;&#34;store up the deployed contrcat addresses to the local file storage&#34;&#34;&#34;
        self.artifact_manager.StoreTxResult(self._contract_dict, self.pathfinder.SaveDeployConfig)

    def SaveConfig(self) -&gt; None:
        self.complete_deployment()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="moody.libeb.Logd"><code class="name flex">
<span>def <span class="ident">Logd</span></span>(<span>anystr: <built-in function any>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Logd(anystr: any):
    print(anystr)</code></pre>
</details>
</dd>
<dt id="moody.libeb.event_log"><code class="name flex">
<span>def <span class="ident">event_log</span></span>(<span>tx_hash: str, events: List[str], provider: web3.main.Web3, contract: web3.contract.Contract) ‑> Tuple[str, Union[web3.datastructures.AttributeDict, NoneType]]</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts logs of @event from tx_hash if present
:param tx_hash:
:param events: Case sensitive events name
:param provider:
:param contract: Web3 Contract
:return: event name and log represented in 'AttributeDict' or 'None' if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event_log(tx_hash: str, events: List[str], provider: Web3, contract: Web3Contract) -&gt; Tuple[str, Optional[AttributeDict]]:
    &#34;&#34;&#34;
    Extracts logs of @event from tx_hash if present
    :param tx_hash:
    :param events: Case sensitive events name
    :param provider:
    :param contract: Web3 Contract
    :return: event name and log represented in &#39;AttributeDict&#39; or &#39;None&#39; if not found
    &#34;&#34;&#34;
    try:
        receipt = provider.eth.getTransactionReceipt(tx_hash)
    except TransactionNotFound:
        time.sleep(3000)  # hard coded sleep for 3 seconds... maybe this will help?
        # retry
        try:
            receipt = provider.eth.getTransactionReceipt(tx_hash)
        except TransactionNotFound:
            return &#39;&#39;, None

    for event in events:
        # we discard warning as we do best effort to find wanted event, not always there
        # as we listen to the entire contract tx, might
        log = getattr(contract.events, event)().processReceipt(receipt, DISCARD)
        if log:
            data_index = 0
            return event, log[data_index]
    # todo: fix this - seems like some weird return
    return &#39;&#39;, None</code></pre>
</details>
</dd>
<dt id="moody.libeb.extract_tx_by_address"><code class="name flex">
<span>def <span class="ident">extract_tx_by_address</span></span>(<span>address, block: web3.types.BlockData) ‑> list</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_tx_by_address(address, block: BlockData) -&gt; list:
    # Note: block attribute dict has to be generated with full_transactions=True flag
    return [tx for tx in block.transactions if tx.to and address.lower() == tx.to.lower()]</code></pre>
</details>
</dd>
<dt id="moody.libeb.normalize_address"><code class="name flex">
<span>def <span class="ident">normalize_address</span></span>(<span>address: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts address to address acceptable by web3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_address(address: str):
    &#34;&#34;&#34;Converts address to address acceptable by web3&#34;&#34;&#34;
    return Web3.toChecksumAddress(address.lower())</code></pre>
</details>
</dd>
<dt id="moody.libeb.toDict"><code class="name flex">
<span>def <span class="ident">toDict</span></span>(<span>dictToParse)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toDict(dictToParse):
    # convert any &#39;AttributeDict&#39; type found to &#39;dict&#39;
    parsedDict = dict(dictToParse)
    for key, val in parsedDict.items():
        if &#39;list&#39; in str(type(val)):
            parsedDict[key] = [_parseValue(x) for x in val]
        else:
            parsedDict[key] = _parseValue(val)
    return parsedDict</code></pre>
</details>
</dd>
<dt id="moody.libeb.web3_provider"><code class="name flex">
<span>def <span class="ident">web3_provider</span></span>(<span>address: str) ‑> web3.main.Web3</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def web3_provider(address: str) -&gt; Web3:
    try:
        if address.startswith(&#39;http&#39;):  # HTTP
            return Web3(Web3.HTTPProvider(address))
        if address.startswith(&#39;ws&#39;):  # WebSocket
            return Web3(Web3.WebsocketProvider(address))
        return Web3(Web3.IPCProvider(address))
    except FileNotFoundError:
        raise ValueError(&#34;Failed to initialize web3 provider (is eth_node set?)&#34;) from None</code></pre>
</details>
</dd>
<dt id="moody.libeb.writeFile"><code class="name flex">
<span>def <span class="ident">writeFile</span></span>(<span>content, filename)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeFile(content, filename):
    fo = open(filename, &#34;w&#34;)
    fo.write(content)
    fo.close()
    print(statement.format(time.ctime(), filename))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="moody.libeb.BinOp"><code class="flex name class">
<span>class <span class="ident">BinOp</span></span>
<span>(</span><span>bin_content: str, file_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>The binary operation for the ops. Taking care the operations for library linking and the related stuffs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BinOp:
    &#34;&#34;&#34;
    The binary operation for the ops. Taking care the operations for library linking and the related stuffs.
    &#34;&#34;&#34;

    def __init__(self, bin_content: str, file_name: str):
        self.bin_raw = bin_content
        self.bin_knifed = bin_content
        self.bin_undeploy_lib = dict()
        self.file_name = file_name
        self.debug = False

    def setDebug(self, de: bool):
        self.debug = de

    def GetRawBin(self) -&gt; str:
        return self.bin_raw

    def GetKnifedBin(self) -&gt; str:
        return self.bin_knifed

    def checkBinForUndeployLib(self) -&gt; bool:
        matches = re.finditer(regex1, self.bin_raw, re.MULTILINE)
        found = False
        for matchNum, match in enumerate(matches, start=1):
            print(&#34;Library {matchNum} is found at {start}-{end}: {match}&#34;.format(matchNum=matchNum, start=match.start(), end=match.end(), match=match.group()))
            k, v = self.fromLine(match.group())
            self.bin_undeploy_lib[k] = v
            found = True
        return found

    def fromLine(self, input_line: str) -&gt; Tuple[str, str]:
        class_name = input_line.split(&#34;:&#34;)[1]
        return class_name, input_line

    def _placehd(self, instruction_line: str) -&gt; str:
        return &#34;__{}__&#34;.format(str(instruction_line).split(&#34;-&gt;&#34;)[0].strip(&#34; //&#34;))

    def anaylze(self, databank: IDos) -&gt; bool:
        if len(self.bin_undeploy_lib) == 0:
            print(&#34;🚧 Nothing to process&#34;)
            return False

        for class_name, instruction_line in self.bin_undeploy_lib.items():
            if databank.hasContractName(class_name) is True:
                print(f&#34;💽 Found support Class {class_name} - deployment address&#34;)
                if databank.isAddress(databank.getAddr(class_name)):
                    self._knifeBinClass(class_name, self._placehd(instruction_line), databank.getAddr(class_name))
                else:
                    print(&#34;🧊 The found library address is not valid - {}, {}&#34;.format(class_name, databank.getAddr(class_name)))
                    raise FoundUndeployedLibraries
            else:
                print(&#34;⚠️ Unfound library Error- {}, please make sure you have this library deployed.&#34;.format(class_name))
                raise FoundUndeployedLibraries

        self.bin_knifed = self.bin_knifed.splitlines(True)[0]
        self.bin_knifed = self.bin_knifed.replace(&#34;\n&#34;, &#34;&#34;)
        # self.bin_knifed = &#34;0x&#34; + self.bin_knifed
        if self.debug is True:
            print(f&#34;After processed bin file - {self.file_name}.bin (should be done now)&#34;)
            print(self.bin_knifed)
            # print(self.bin_raw)
            print(&#34;File content end ##&#34;)
        else:
            print(f&#34;After processed bin file - {self.file_name}.bin&#34;)

        return True

    def _knifeBinClass(self, c: str, k: str, address: str) -&gt; None:
        # address_step_1 = address.lower()
        address_step_2 = address.replace(&#34;0x&#34;, &#34;&#34;)
        self.bin_knifed = self.bin_knifed.replace(k, address_step_2)
        print(f&#34;🍡 Linked successfully for Solidity Class {c} with {address}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="moody.libeb.BinOp.GetKnifedBin"><code class="name flex">
<span>def <span class="ident">GetKnifedBin</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetKnifedBin(self) -&gt; str:
    return self.bin_knifed</code></pre>
</details>
</dd>
<dt id="moody.libeb.BinOp.GetRawBin"><code class="name flex">
<span>def <span class="ident">GetRawBin</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetRawBin(self) -&gt; str:
    return self.bin_raw</code></pre>
</details>
</dd>
<dt id="moody.libeb.BinOp.anaylze"><code class="name flex">
<span>def <span class="ident">anaylze</span></span>(<span>self, databank: <a title="moody.libeb.IDos" href="#moody.libeb.IDos">IDos</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def anaylze(self, databank: IDos) -&gt; bool:
    if len(self.bin_undeploy_lib) == 0:
        print(&#34;🚧 Nothing to process&#34;)
        return False

    for class_name, instruction_line in self.bin_undeploy_lib.items():
        if databank.hasContractName(class_name) is True:
            print(f&#34;💽 Found support Class {class_name} - deployment address&#34;)
            if databank.isAddress(databank.getAddr(class_name)):
                self._knifeBinClass(class_name, self._placehd(instruction_line), databank.getAddr(class_name))
            else:
                print(&#34;🧊 The found library address is not valid - {}, {}&#34;.format(class_name, databank.getAddr(class_name)))
                raise FoundUndeployedLibraries
        else:
            print(&#34;⚠️ Unfound library Error- {}, please make sure you have this library deployed.&#34;.format(class_name))
            raise FoundUndeployedLibraries

    self.bin_knifed = self.bin_knifed.splitlines(True)[0]
    self.bin_knifed = self.bin_knifed.replace(&#34;\n&#34;, &#34;&#34;)
    # self.bin_knifed = &#34;0x&#34; + self.bin_knifed
    if self.debug is True:
        print(f&#34;After processed bin file - {self.file_name}.bin (should be done now)&#34;)
        print(self.bin_knifed)
        # print(self.bin_raw)
        print(&#34;File content end ##&#34;)
    else:
        print(f&#34;After processed bin file - {self.file_name}.bin&#34;)

    return True</code></pre>
</details>
</dd>
<dt id="moody.libeb.BinOp.checkBinForUndeployLib"><code class="name flex">
<span>def <span class="ident">checkBinForUndeployLib</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkBinForUndeployLib(self) -&gt; bool:
    matches = re.finditer(regex1, self.bin_raw, re.MULTILINE)
    found = False
    for matchNum, match in enumerate(matches, start=1):
        print(&#34;Library {matchNum} is found at {start}-{end}: {match}&#34;.format(matchNum=matchNum, start=match.start(), end=match.end(), match=match.group()))
        k, v = self.fromLine(match.group())
        self.bin_undeploy_lib[k] = v
        found = True
    return found</code></pre>
</details>
</dd>
<dt id="moody.libeb.BinOp.fromLine"><code class="name flex">
<span>def <span class="ident">fromLine</span></span>(<span>self, input_line: str) ‑> Tuple[str, str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fromLine(self, input_line: str) -&gt; Tuple[str, str]:
    class_name = input_line.split(&#34;:&#34;)[1]
    return class_name, input_line</code></pre>
</details>
</dd>
<dt id="moody.libeb.BinOp.setDebug"><code class="name flex">
<span>def <span class="ident">setDebug</span></span>(<span>self, de: bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setDebug(self, de: bool):
    self.debug = de</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="moody.libeb.HexJsonEncoder"><code class="flex name class">
<span>class <span class="ident">HexJsonEncoder</span></span>
<span>(</span><span>*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Extensible JSON <a href="http://json.org">http://json.org</a> encoder for Python data structures.</p>
<p>Supports the following objects and types by default:</p>
<p>+-------------------+---------------+
| Python
| JSON
|
+===================+===============+
| dict
| object
|
+-------------------+---------------+
| list, tuple
| array
|
+-------------------+---------------+
| str
| string
|
+-------------------+---------------+
| int, float
| number
|
+-------------------+---------------+
| True
| true
|
+-------------------+---------------+
| False
| false
|
+-------------------+---------------+
| None
| null
|
+-------------------+---------------+</p>
<p>To extend this to recognize other objects, subclass and implement a
<code>.default()</code> method with another method that returns a serializable
object for <code>o</code> if possible, otherwise it should call the superclass
implementation (to raise <code>TypeError</code>).</p>
<p>Constructor for JSONEncoder, with sensible defaults.</p>
<p>If skipkeys is false, then it is a TypeError to attempt
encoding of keys that are not str, int, float or None.
If
skipkeys is True, such items are simply skipped.</p>
<p>If ensure_ascii is true, the output is guaranteed to be str
objects with all incoming non-ASCII characters escaped.
If
ensure_ascii is false, the output can contain non-ASCII characters.</p>
<p>If check_circular is true, then lists, dicts, and custom encoded
objects will be checked for circular references during encoding to
prevent an infinite recursion (which would cause an OverflowError).
Otherwise, no such check takes place.</p>
<p>If allow_nan is true, then NaN, Infinity, and -Infinity will be
encoded as such.
This behavior is not JSON specification compliant,
but is consistent with most JavaScript based encoders and decoders.
Otherwise, it will be a ValueError to encode such floats.</p>
<p>If sort_keys is true, then the output of dictionaries will be
sorted by key; this is useful for regression tests to ensure
that JSON serializations can be compared on a day-to-day basis.</p>
<p>If indent is a non-negative integer, then JSON array
elements and object members will be pretty-printed with that
indent level.
An indent level of 0 will only insert newlines.
None is the most compact representation.</p>
<p>If specified, separators should be an (item_separator, key_separator)
tuple.
The default is (', ', ': ') if <em>indent</em> is <code>None</code> and
(',', ': ') otherwise.
To get the most compact JSON representation,
you should specify (',', ':') to eliminate whitespace.</p>
<p>If specified, default is a function that gets called for objects
that can't otherwise be serialized.
It should return a JSON encodable
version of the object or raise a <code>TypeError</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HexJsonEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, HexBytes):
            return obj.hex()
        return super().default(obj)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>json.encoder.JSONEncoder</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.libeb.HexJsonEncoder.default"><code class="name flex">
<span>def <span class="ident">default</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement this method in a subclass such that it returns
a serializable object for <code>o</code>, or calls the base implementation
(to raise a <code>TypeError</code>).</p>
<p>For example, to support arbitrary iterators, you could
implement default like this::</p>
<pre><code>def default(self, o):
    try:
        iterable = iter(o)
    except TypeError:
        pass
    else:
        return list(iterable)
    # Let the base class default method raise the TypeError
    return JSONEncoder.default(self, o)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default(self, obj):
    if isinstance(obj, HexBytes):
        return obj.hex()
    return super().default(obj)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="moody.libeb.IDos"><code class="flex name class">
<span>class <span class="ident">IDos</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IDos:
    def hasContractName(self, name: str) -&gt; bool:
        pass

    def getAddr(self, keyname: str) -&gt; str:
        pass

    def isAddress(self, add: str) -&gt; bool:
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="moody.libeb.MiliDoS" href="#moody.libeb.MiliDoS">MiliDoS</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="moody.libeb.IDos.getAddr"><code class="name flex">
<span>def <span class="ident">getAddr</span></span>(<span>self, keyname: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAddr(self, keyname: str) -&gt; str:
    pass</code></pre>
</details>
</dd>
<dt id="moody.libeb.IDos.hasContractName"><code class="name flex">
<span>def <span class="ident">hasContractName</span></span>(<span>self, name: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasContractName(self, name: str) -&gt; bool:
    pass</code></pre>
</details>
</dd>
<dt id="moody.libeb.IDos.isAddress"><code class="name flex">
<span>def <span class="ident">isAddress</span></span>(<span>self, add: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isAddress(self, add: str) -&gt; bool:
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="moody.libeb.MiliDoS"><code class="flex name class">
<span>class <span class="ident">MiliDoS</span></span>
<span>(</span><span>_nodeCfg: <a title="moody.Config" href="index.html#moody.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the base package function core for all the related operations to execute
The center hub of the progress source code is in here</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MiliDoS(IDos):
    &#34;&#34;&#34;
    This is the base package function core for all the related operations to execute
    The center hub of the progress source code is in here
    &#34;&#34;&#34;

    EVM_VERSION = Evm.BERLIN

    def __init__(self, _nodeCfg: Config):
        # the hidden list
        self._contract_dict = dict()
        self._sol_list = list()
        # publicly accessible
        self.project_workspace_root = &#34;&#34;
        self.accountAddr = None
        self.pathfinder = None
        self.artifact_manager = None
        self._sol_link = None
        self.is_deploy = False
        self.is_internal = False
        self.is_forge = False
        self.deployed_address = False
        self.last_class = &#34;&#34;
        self.list_type = &#34;list_address&#34;
        self.network_cfg = _nodeCfg
        self.w3 = web3_provider(_nodeCfg.rpc_url)
        self._optimizations = 200
        result = self.w3.isConnected()
        if not result:
            print(f&#34;try to connect {self.network_cfg.network_name}  {Bolors.WARNING} {self.network_cfg.rpc_url}: {result} {Bolors.RESET}&#34;)
            exit(0)
            return
        else:
            print(f&#34;You are now connected to {Bolors.OK} {self.network_cfg.network_name} {self.network_cfg.rpc_url} {Bolors.RESET}&#34;)

    def withPOA(self) -&gt; &#34;MiliDoS&#34;:
        &#34;&#34;&#34;
        the normal usual term to fix some POA related problems
        :return:
        &#34;&#34;&#34;
        self.w3.middleware_onion.inject(geth_poa_middleware, layer=0)
        return self

    def isAddress(self, address: str) -&gt; bool:
        &#34;&#34;&#34;
        Verification of the valid EVM address
        :param address:
        :return:
        &#34;&#34;&#34;
        return self.w3.isAddress(address)

    def connect(self, workspace: str, history: any) -&gt; None:

        &#34;&#34;&#34;
        connect the existing deployed contract
        :param workspace: the workspace directory
        :param history: the deployed history folder under the deploy_history
        :return:
        &#34;&#34;&#34;
        self.is_deploy = False
        self.artifact_manager = SolWeb3Tool()
        if history is False:
            self.pathfinder = Paths(workspace).setDefaultPath().Network(self.network_cfg.network_name)
        else:
            self.pathfinder = Paths(workspace).SetUseHistory(history).Network(self.network_cfg.network_name)

        self.ready_io(True)

    def SetupContract(self):
        pass

    def after_deployment_initialize_settings(self):
        &#34;&#34;&#34;
        setup contract starting params
        setup the starting time using bang
        setup the first member
        :return:
        &#34;&#34;&#34;
        pass

    def setWorkspace(self, path: str, readio: bool = True) -&gt; &#34;MiliDoS&#34;:
        self.project_workspace_root = path
        self.artifact_manager = SolWeb3Tool()
        self.pathfinder = Paths(path).setDefaultPath().Network(self.network_cfg.network_name)
        if readio:
            self.ready_io(True)
        return self

    def setClassSolNames(self, to_compile_contract_list: list) -&gt; &#34;MiliDoS&#34;:
        self._sol_list = to_compile_contract_list
        return self

    def setClassSolLinks(self, compile_links: list) -&gt; &#34;MiliDoS&#34;:
        self._sol_link = compile_links
        return self

    def setEvm(self, version_evm: str) -&gt; &#34;MiliDoS&#34;:
        &#34;&#34;&#34;
        the specify the version of the ethereum virtual machine
        :param version_evm: the version of the EVM
        :return:
        &#34;&#34;&#34;
        self.EVM_VERSION = version_evm
        return self

    def setOptimizationRuns(self, runs: int) -&gt; &#34;MiliDoS&#34;:
        self._optimizations = runs
        return self

    def remoteCompile(self, ver: str) -&gt; &#34;MiliDoS&#34;:
        &#34;&#34;&#34;
        all parameters will be inserted automatically according to the previous setup
        :param ver:
        :return:
        &#34;&#34;&#34;
        if ver == &#34;&#34;:
            print(&#34;there is no solidity version specified&#34;)
            exit(0)
        self.pathfinder.setSolVersion(ver)
        self.pathfinder.setEvm(self.EVM_VERSION)
        BuildRemoteLinuxCommand(self.pathfinder, self._optimizations, self._sol_list, self._sol_link)
        return self

    def useForge(self) -&gt; &#34;MiliDoS&#34;:
        # ==================================================
        if self._sol_list is not None:
            for v in self._sol_list:
                based_name = os.path.basename(v)
                class_name = based_name.replace(&#34;.sol&#34;, &#34;&#34;)
                # class_name_process = filter_file_name(based_name).replace(&#39;.sol&#39;, &#39;&#39;)
                self.artifact_manager.SplitForgeBuild(class_name)
            self.is_forge = True
        return self

    def localTranspile(self, dapp_ts_folder: str = None) -&gt; &#34;MiliDoS&#34;:
        &#34;&#34;&#34;
        :param dapp_ts_folder: the destination is follow by this path {dapp_ts_folder}/src/api/abi/xxx.ts
        if this valuable is None then there will not be any copy files to the destination
        :return: instance of moody
        &#34;&#34;&#34;
        self.pathfinder.updateTargetDappFolder(dapp_ts_folder)
        if self.is_forge:
            BuildLangForge(self.pathfinder, self._sol_list)
        else:
            BuildLang(self.pathfinder, self._sol_list)
        return self

    def get_block(self, block_identifier, full_transactions: bool = False):
        &#34;&#34;&#34;
        to see the block information
        :param block_identifier:
        :param full_transactions:
        :return: instance of moody
        &#34;&#34;&#34;
        with w3_lock:
            res = self.w3.eth.getBlock(block_identifier, full_transactions)
        return res

    def erc20_contract(self):
        cTool = SolWeb3Tool()
        cTool.setBuildNameSpace(&#34;artifact&#34;).GetCodeClassFromBuild(&#34;ERC20&#34;)
        return self.w3.eth.contract(abi=cTool.abi)

    def estimate_gas_price(self):
        return self.w3.eth.gasPrice

    def send_contract_tx(self, contract: Web3Contract, function_name: str, from_acc: str,
                         private_key: bytes, gas: int = 0, gas_price: int = 0, _value: int = 0,
                         args: Tuple = ()):
        &#34;&#34;&#34;
        Creates the contract tx and signs it with private_key to be transmitted as raw tx
        &#34;&#34;&#34;

        tx = getattr(contract.functions, function_name)(*args).buildTransaction(
            {
                &#39;from&#39;: from_acc,
                &#39;chainId&#39;: self.w3.eth.chainId,
                # gas_price is in gwei
                &#39;gasPrice&#39;: gas_price * 1e9 if gas_price else self.estimate_gas_price(),
                &#39;gas&#39;: gas or None,
                &#39;nonce&#39;: self.w3.eth.getTransactionCount(from_acc, block_identifier=&#39;pending&#39;),
                &#39;value&#39;: _value
            })
        signed_txn = self.w3.eth.account.sign_transaction(tx, private_key)
        return self.w3.eth.sendRawTransaction(signed_txn.rawTransaction)

    def contract_event_in_range(self, contract, event_name: str, from_block: int = 0, to_block: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        scans the blockchain, and yields blocks that has contract tx with the provided event
        Note: Be cautions with the range provided, as the logic creates query for each block which could be a bottleneck.
        :param from_block: starting block, defaults to 0
        :param to_block: end block, defaults to &#39;latest&#39;
        :param provider:
        :param logger:
        :param contract:
        :param event_name: name of the contract emit event you wish to be notified of
        &#34;&#34;&#34;
        if to_block is None:
            to_block = self.w3.eth.blockNumber

        with w3_lock:

            if isinstance(self.w3.provider, HTTPProvider):
                for block_num in range(from_block, to_block + 1):
                    block = self.w3.eth.getBlock(block_num, full_transactions=True)
                    contract_transactions = extract_tx_by_address(contract.address, block)

                    if not contract_transactions:
                        continue
                    for tx in contract_transactions:
                        _, log = event_log(tx_hash=tx.hash, events=[event_name], provider=self.w3, contract=contract.tracked_contract)
                        if log is None:
                            continue
                        yield log
            else:
                event = getattr(contract.tracked_contract.events, event_name)
                event_filter = event.createFilter(fromBlock=from_block, toBlock=to_block)

                for tx in event_filter.get_new_entries():
                    _, log = event_log(tx_hash=tx.hash, events=[event_name], provider=self.w3, contract=contract.tracked_contract)

                    if log is None:
                        continue

                    yield log

    def AuthByMemo(self, phrase: str = None) -&gt; &#34;MiliDoS&#34;:
        keyLo = self.w3.eth.account.from_mnemonic(phrase)
        # self.w3.eth.defaultAccount = keyoo.address
        self.w3.eth.account = keyLo
        # self.w3.eth.get_transaction_count
        # self.w3.eth.accounts[0] = keyLo.address
        # self.w3.eth.defaultAccount(f&#34;0x{keyLo.key}&#34;)
        is_address = self.w3.isAddress(keyLo.address)
        # self.w3.isChecksumAddress(keyLo.address)
        self.accountAddr = keyLo.address
        print(f&#34;🔫 You are now using {keyLo.address} and it is a {&#39;valid key&#39; if is_address else &#39;invalid key&#39;}&#34;)

        return self

    def Auth(self, private_key_line: str = None) -&gt; &#34;MiliDoS&#34;:
        &#34;&#34;&#34;
        switching the operating address to a different one that is given by the private key
        :param private_key_line: the input private key
        :return:
        &#34;&#34;&#34;
        if private_key_line is None:
            private_key_line = DefaultKeys.k0

        # f&#34;0x{private_key_line}&#34;
        keyLo = self.w3.eth.account.from_key(f&#34;0x{private_key_line}&#34;)
        # self.w3.eth.defaultAccount = keyoo.address
        self.w3.eth.account = keyLo
        # self.w3.eth.get_transaction_count
        # self.w3.eth.accounts[0] = keyLo.address
        # self.w3.eth.defaultAccount(f&#34;0x{keyLo.key}&#34;)
        is_address = self.w3.isAddress(keyLo.address)
        # self.w3.isChecksumAddress(keyLo.address)
        self.accountAddr = keyLo.address
        print(f&#34;🔫 You are now using {keyLo.address} and it is a {&#39;valid key&#39; if is_address else &#39;invalid key&#39;}&#34;)

        return self

    def estimateGas(self, class_name: str) -&gt; int:
        &#34;&#34;&#34;
        only for testing the contract deploy gas requirement
        :param class_name:
        :return:
        &#34;&#34;&#34;
        # estimate_gas
        solc_artifact = SolWeb3Tool()
        solc_artifact.setBasePath(self.project_workspace_root)
        solc_artifact = solc_artifact.GetCodeClassFromBuild(class_name)
        nr = self.w3.eth.contract(abi=solc_artifact.abi, bytecode=solc_artifact.bin)
        gas_est_amount = nr.constructor().estimateGas()
        price = self.w3.eth.generate_gas_price()
        # source: https://ethereum.stackexchange.com/questions/84943/what-is-the-equivalent-of-buildtransaction-of-web3py-in-web3js
        print(f&#34;Price: {price}&#34;)
        return gas_est_amount

    def OverrideGasConfig(self, gas: int, gas_price: int) -&gt; None:
        &#34;&#34;&#34;
        the override the configuration for the gas amount and the gas price
        :param gas: int
        :param gas_price: int
        :return: NONE
        &#34;&#34;&#34;
        self.network_cfg.gas = gas
        self.network_cfg.gasPrice = gas_price

    def OverrideChainConfig(self, one: int, wait: int) -&gt; None:
        &#34;&#34;&#34;
        Lets have the configuration done now.
        :param one: ONE coin to measure
        :param wait: the waiting time from each block confirmation
        :return:
        &#34;&#34;&#34;
        self.network_cfg.wait_time = wait
        self.network_cfg.one = one

    @property
    def gas(self) -&gt; int:
        return self.network_cfg.gas

    @property
    def gasPrice(self) -&gt; int:
        return self.network_cfg.gasPrice

    @property
    def one(self) -&gt; int:
        &#34;&#34;&#34;
        ONE platform coin will be decoded to be...
        :return: int
        &#34;&#34;&#34;
        return self.network_cfg.one

    @property
    def waitSec(self) -&gt; int:
        return self.network_cfg.wait_time

    @property
    def LinkVRFHashKey(self) -&gt; str:
        if self.network_cfg.link_keyhash is None:
            raise ValueError(&#34;Link VRF Hash Key is endorsed on this network&#34;)
        else:
            return self.network_cfg.link_keyhash

    @property
    def LinkVRFCoordinator(self) -&gt; str:
        if self.network_cfg.link_vrf_coordinator is None:
            raise ValueError(&#34;Link VRF is endorsed on this network&#34;)
        else:
            return self.network_cfg.link_vrf_coordinator

    @property
    def LinkTokenAddress(self) -&gt; str:
        if self.network_cfg.link_token is None:
            raise ValueError(&#34;Link Token is endorsed on this network&#34;)
        else:
            return self.network_cfg.link_token

    def _checkErrorForTxReceipt(self, receipt: any, class_name: str, jsonfile: str) -&gt; None:
        if &#34;contractAddress&#34; not in receipt:
            print(f&#34;⚠️ Error from deploy contract and no valid address found for {class_name}.&#34;)
            raise InvalidAddress

        if &#34;transactionHash&#34; not in receipt:
            print(f&#34;⚠️ The deployment is failed because there is no valid address found from {class_name}. Please check for internal errors from deployment has {receipt.transactionHash}&#34;)
            raise InvalidAddress

        hash = str(receipt.transactionHash)
        preaddress = str(receipt.contractAddress)
        if self.isAddress(preaddress) is False:
            print(f&#34;⚠️ The deployment is failed because there is no valid address found from {class_name}. Please check for internal errors from deployment hash from {jsonfile}&#34;)
            raise InvalidAddress

    def provide_artifact_extends(self, class_name: str) -&gt; SolWeb3Tool:
        &#34;&#34;&#34;
        Following the class name of the contract
        :param class_name:
        :return:
        &#34;&#34;&#34;
        if not self.artifact_manager:
            print(&#34;❌ Root path is not setup. please setup the workspace first.&#34;)
            exit(2)

        sol = self.artifact_manager
        sol.setBasePath(self.project_workspace_root)
        sol.setBuildNameSpace(&#34;build&#34;)
        sol = sol.GetCodeClassFromBuild(class_name)
        self.artifact_manager = sol
        return sol

    def provide_artifact_implemented(self, class_name: str) -&gt; SolWeb3Tool:
        &#34;&#34;&#34;
        Use the internal available class names. Please see the internal class name list
        :param class_name:
        :return:
        &#34;&#34;&#34;
        if not self.artifact_manager:
            print(&#34;❌ Root path is not setup. please setup the workspace first.&#34;)
            exit(2)

        sol = self.artifact_manager
        sol.setBasePath(root_base_path)
        sol.setBuildNameSpace(&#34;artifacts&#34;)
        sol = sol.GetCodeClassFromBuild(class_name)
        self.artifact_manager = sol
        return sol

    def deployImple(self, class_name: str, params: list = [], gas_price: int = 0, gas_limit: int = 0) -&gt; bool:
        &#34;&#34;&#34;
        Deployment of implemented abi and code
        :param class_name:
        :param params:
        :param gas_price:
        :param gas_limit:
        :return:
        &#34;&#34;&#34;
        contract_nv = None
        try:
            solc_artifact = self.provide_artifact_implemented(class_name)
            bin = BinOp(solc_artifact.bin, class_name)
            if bin.checkBinForUndeployLib() is True:
                bin.setDebug(True)
                # try to find the needed libraries in address..
                bin.anaylze(self)
                contract_nv = self.w3.eth.contract(abi=solc_artifact.abi, bytecode=bin.GetKnifedBin())
            else:
                contract_nv = self.w3.eth.contract(abi=solc_artifact.abi, bytecode=bin.GetRawBin())

        except FileNotFoundError:
            print(&#34;💢 bin or abi file is not found.&#34;)
            exit(3)
        except FoundUndeployedLibraries:
            exit(4)
        except ContractLogicError as e:
            print(f&#34;💢 Contract error {e}&#34;)
            exit(5)
        gasprice = self.gasPrice if gas_price == 0 else gas_price
        gas = self.gas if gas_limit == 0 else gas_limit
        if len(params) &gt; 0:
            _transaction = contract_nv.constructor(*params).buildTransaction({
                &#34;gasPrice&#34;: gasprice,
                &#34;gas&#34;: gas
            })
        else:
            _transaction = contract_nv.constructor().buildTransaction({
                &#34;gasPrice&#34;: gasprice,
                &#34;gas&#34;: gas
            })
        self.artifact_manager.setBasePath(self.project_workspace_root)
        return self._endingdeployment(_transaction, class_name)

    def deploy(self, class_name: str, params: list = [], gas_price: int = 0, gas_limit: int = 0) -&gt; bool:
        &#34;&#34;&#34;
        This is using the faster way to deploy files by using the specific abi and bin files.
        If all these parameters to be ignored then these things will be taken from other available
        valuables for gas price and gas limit
        :param class_name: the input class name
        :param params: the parameters
        :param gas_price: the gas price
        :param gas_limit: the gas limit
        :return:
        &#34;&#34;&#34;
        contract_nv = None
        try:
            solc_artifact = self.provide_artifact_extends(class_name)
            bin = BinOp(solc_artifact.bin, class_name)
            if bin.checkBinForUndeployLib() is True:
                bin.setDebug(True)
                # try to find the needed libraries in address..
                bin.anaylze(self)
                contract_nv = self.w3.eth.contract(abi=solc_artifact.abi, bytecode=bin.GetKnifedBin())
            else:
                contract_nv = self.w3.eth.contract(abi=solc_artifact.abi, bytecode=bin.GetRawBin())

        except FileNotFoundError:
            print(&#34;💢 bin or abi file is not found.&#34;)
            exit(3)
        except FoundUndeployedLibraries:
            exit(4)
        except ContractLogicError as e:
            print(f&#34;💢 Contract error {e}&#34;)
            exit(5)

        gasprice = self.gasPrice if gas_price == 0 else gas_price
        gas = self.gas if gas_limit == 0 else gas_limit
        if len(params) &gt; 0:
            _transaction = contract_nv.constructor(*params).buildTransaction({
                &#34;gasPrice&#34;: gasprice,
                &#34;gas&#34;: gas
            })
        else:
            _transaction = contract_nv.constructor().buildTransaction({
                &#34;gasPrice&#34;: gasprice,
                &#34;gas&#34;: gas
            })
        return self._endingdeployment(_transaction, class_name)

    def _endingdeployment(self, _transaction: any, class_name: str) -&gt; bool:
        try:
            _transaction[&#39;nonce&#39;] = self.w3.eth.getTransactionCount(self.accountAddr)
            _transaction[&#39;to&#39;] = None
            # _transaction[&#39;gas&#39;] = self.gas if gas_limit == 0 else gas_limit
            # _transaction[&#39;gasPrice&#39;] = self.gasPrice if gas_price == 0 else gas_price
            # _transaction[&#39;gas&#39;] = 2200000000,
            print(&#34;ok --- &#34;, _transaction)
            # Get correct transaction nonce for sender from the node
            print(f&#34;========🖍 Signing {class_name}, gas:{_transaction[&#39;gas&#39;]}, price:{_transaction[&#39;gasPrice&#39;]} ...&#34;)
            signed = self.w3.eth.account.sign_transaction(_transaction)

            txHash = self.w3.eth.sendRawTransaction(signed.rawTransaction)
            # print(f&#34;Contract &#39;{class_name}&#39; deployed; Waiting to transaction receipt&#34;)
            print(f&#34;========Wait for Block Confirmation - {class_name} ☕️&#34;)
            tx_receipt = self.w3.eth.waitForTransactionReceipt(txHash)
            print(&#34;========TX Pre-Result ✅&#34;)
            print(tx_receipt)
            print(f&#34;========Broadcast Result ✅ -&gt; {Paths.showCurrentDeployedClass(class_name)}&#34;)

            self._checkErrorForTxReceipt(tx_receipt, class_name, Paths.showCurrentDeployedClass(class_name))
            fresh_address = tx_receipt.contractAddress
            self._contract_dict[class_name] = fresh_address
            self.deployed_address = fresh_address
            self.setTargetClass(class_name)
            self.setKV(&#34;by&#34;, self.accountAddr)
            print(&#34;📦 Address saved to ✅ {} -&gt; {}&#34;.format(fresh_address, class_name))
            print(f&#34;🔍 You can check with the explorer for more detail: {Bolors.WARNING} {self.network_cfg.block_explorer}{Bolors.RESET}&#34;)

            self.artifact_manager.StoreTxResult(tx_receipt, self.pathfinder.classObject(class_name))
            self.complete_deployment()
            return True
        except InvalidAddress:
            return False
        except ContractLogicError as e:
            print(f&#34;Error: {e}&#34;)
            return False
        except TimeExhausted:
            print(&#34;After 120 seconds, the boardcast block is not in the chain.&#34;)
            return False
        except ValueError as te:
            if &#34;code&#34; in te:
                code = int(te[&#34;code&#34;])
                if code == -32000:
                    print(&#34;NOT ENOUGH GAS - insufficient funds for gas&#34;)
                    return False
            print(te)
            return False

    @property
    def __list_key_label(self) -&gt; str:
        return &#34;{}_{}&#34;.format(self.list_type, self.last_class)

    @property
    def __kv_label(self) -&gt; str:
        return &#34;kv_{}&#34;.format(self.last_class)

    def getAddr(self, keyname: str) -&gt; str:
        &#34;&#34;&#34;example: TT67rPNwgmpeimvHUMVzFfKsjL9GZ1wGw8&#34;&#34;&#34;
        return self._contract_dict.get(keyname)

    def getAllAddress(self) -&gt; dict:
        return self._contract_dict

    def preview_all_addresses(self) -&gt; None:
        print(self._contract_dict)

    def is_deployment(self) -&gt; bool:
        return self.is_deploy

    def ready_io(self, show_address: bool = False):
        &#34;&#34;&#34;try to load up the file from the existing path&#34;&#34;&#34;
        try:
            self._contract_dict = self.pathfinder.LoadDeploymentFile()
            print(&#34;📦 Review the loaded deployment data from ... &#34;)
            if show_address:
                self.preview_all_addresses()
        except FileNotFoundError:
            print(&#34;💢 Deployment File is not found ...&#34;)
        except TypeError as e:
            print(e)

    def setTargetClass(self, classname: str) -&gt; &#34;MiliDoS&#34;:
        self.last_class = classname
        return self

    def setTargetListName(self, listname: str) -&gt; &#34;MiliDoS&#34;:
        self.list_type = listname
        return self

    def setKV(self, key: str, value: any) -&gt; &#34;MiliDoS&#34;:
        if self.__kv_label not in self._contract_dict:
            self._contract_dict[self.__kv_label] = dict()
        self._contract_dict[self.__kv_label][key] = value
        return self

    def hasAddressInList(self, address: str) -&gt; bool:
        if self.__list_key_label not in self._contract_dict:
            return False
        try:
            v = self._contract_dict[self.__list_key_label].index(address)
            return True
        except ValueError:
            return False

    def pushAddress(self, address: str, unique: bool = True) -&gt; bool:
        if self.__list_key_label not in self._contract_dict:
            self._contract_dict[self.__list_key_label] = list()

        if unique is True:
            try:
                found_index = self._contract_dict[self.__list_key_label].index(address)
                return False
            except ValueError:
                self._contract_dict[self.__list_key_label].append(address)
                return True
            except IndexError:
                self._contract_dict[self.__list_key_label].append(address)
                return True
        else:
            self._contract_dict[self.__list_key_label].append(address)
            return True

    def removeAddress(self, address: str) -&gt; bool:
        if self.__list_key_label not in self._contract_dict:
            return False
        self._contract_dict[self.__list_key_label].remove(address)
        return True

    def iterList(self) -&gt; iter:
        if self.__list_key_label not in self._contract_dict:
            raise Exception(&#34;there is no list in the map&#34;)
        return iter(self._contract_dict[self.__list_key_label])

    def hasList(self) -&gt; bool:
        if self.__list_key_label not in self._contract_dict:
            return False
        return len(self._contract_dict[self.__list_key_label]) &gt; 0

    def hasField(self, key: str) -&gt; bool:
        if self.__kv_label not in self._contract_dict:
            self._contract_dict[self.__kv_label] = dict()

        if key not in self._contract_dict[self.__kv_label]:
            return False
        else:
            return True

    def hasContractName(self, name: str) -&gt; bool:
        return name in self._contract_dict

    def getString(self, key: str) -&gt; str:
        return str(self.getVal(key))

    def getInt(self, key: str) -&gt; int:
        return int(self.getVal(key))

    def getBytesArray(self, key: str) -&gt; bytearray:
        return bytearray(self.getVal(key))

    def getBytes(self, key: str) -&gt; bytes:
        return bytes(self.getVal(key))

    def getFloat(self, key: str) -&gt; float:
        return float(self.getVal(key))

    def getVal(self, key: str) -&gt; any:
        if self.__kv_label not in self._contract_dict:
            self._contract_dict[self.__kv_label] = dict()

        if key in self._contract_dict[self.__kv_label]:
            return self._contract_dict[self.__kv_label][key]

        return &#34;&#34;

    def complete_deployment(self) -&gt; None:
        &#34;&#34;&#34;store up the deployed contrcat addresses to the local file storage&#34;&#34;&#34;
        self.artifact_manager.StoreTxResult(self._contract_dict, self.pathfinder.SaveDeployConfig)

    def SaveConfig(self) -&gt; None:
        self.complete_deployment()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="moody.libeb.IDos" href="#moody.libeb.IDos">IDos</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="moody.bussen.BusExpress" href="bussen.html#moody.bussen.BusExpress">BusExpress</a></li>
<li><a title="moody.contracttool.ContractTool" href="contracttool.html#moody.contracttool.ContractTool">ContractTool</a></li>
<li><a title="moody.erc20.ERC20H" href="erc20.html#moody.erc20.ERC20H">ERC20H</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="moody.libeb.MiliDoS.EVM_VERSION"><code class="name">var <span class="ident">EVM_VERSION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="moody.libeb.MiliDoS.LinkTokenAddress"><code class="name">var <span class="ident">LinkTokenAddress</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def LinkTokenAddress(self) -&gt; str:
    if self.network_cfg.link_token is None:
        raise ValueError(&#34;Link Token is endorsed on this network&#34;)
    else:
        return self.network_cfg.link_token</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.LinkVRFCoordinator"><code class="name">var <span class="ident">LinkVRFCoordinator</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def LinkVRFCoordinator(self) -&gt; str:
    if self.network_cfg.link_vrf_coordinator is None:
        raise ValueError(&#34;Link VRF is endorsed on this network&#34;)
    else:
        return self.network_cfg.link_vrf_coordinator</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.LinkVRFHashKey"><code class="name">var <span class="ident">LinkVRFHashKey</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def LinkVRFHashKey(self) -&gt; str:
    if self.network_cfg.link_keyhash is None:
        raise ValueError(&#34;Link VRF Hash Key is endorsed on this network&#34;)
    else:
        return self.network_cfg.link_keyhash</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.gas"><code class="name">var <span class="ident">gas</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gas(self) -&gt; int:
    return self.network_cfg.gas</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.gasPrice"><code class="name">var <span class="ident">gasPrice</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gasPrice(self) -&gt; int:
    return self.network_cfg.gasPrice</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.one"><code class="name">var <span class="ident">one</span> : int</code></dt>
<dd>
<div class="desc"><p>ONE platform coin will be decoded to be&hellip;
:return: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def one(self) -&gt; int:
    &#34;&#34;&#34;
    ONE platform coin will be decoded to be...
    :return: int
    &#34;&#34;&#34;
    return self.network_cfg.one</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.waitSec"><code class="name">var <span class="ident">waitSec</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def waitSec(self) -&gt; int:
    return self.network_cfg.wait_time</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="moody.libeb.MiliDoS.Auth"><code class="name flex">
<span>def <span class="ident">Auth</span></span>(<span>self, private_key_line: str = None) ‑> <a title="moody.libeb.MiliDoS" href="#moody.libeb.MiliDoS">MiliDoS</a></span>
</code></dt>
<dd>
<div class="desc"><p>switching the operating address to a different one that is given by the private key
:param private_key_line: the input private key
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Auth(self, private_key_line: str = None) -&gt; &#34;MiliDoS&#34;:
    &#34;&#34;&#34;
    switching the operating address to a different one that is given by the private key
    :param private_key_line: the input private key
    :return:
    &#34;&#34;&#34;
    if private_key_line is None:
        private_key_line = DefaultKeys.k0

    # f&#34;0x{private_key_line}&#34;
    keyLo = self.w3.eth.account.from_key(f&#34;0x{private_key_line}&#34;)
    # self.w3.eth.defaultAccount = keyoo.address
    self.w3.eth.account = keyLo
    # self.w3.eth.get_transaction_count
    # self.w3.eth.accounts[0] = keyLo.address
    # self.w3.eth.defaultAccount(f&#34;0x{keyLo.key}&#34;)
    is_address = self.w3.isAddress(keyLo.address)
    # self.w3.isChecksumAddress(keyLo.address)
    self.accountAddr = keyLo.address
    print(f&#34;🔫 You are now using {keyLo.address} and it is a {&#39;valid key&#39; if is_address else &#39;invalid key&#39;}&#34;)

    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.AuthByMemo"><code class="name flex">
<span>def <span class="ident">AuthByMemo</span></span>(<span>self, phrase: str = None) ‑> <a title="moody.libeb.MiliDoS" href="#moody.libeb.MiliDoS">MiliDoS</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AuthByMemo(self, phrase: str = None) -&gt; &#34;MiliDoS&#34;:
    keyLo = self.w3.eth.account.from_mnemonic(phrase)
    # self.w3.eth.defaultAccount = keyoo.address
    self.w3.eth.account = keyLo
    # self.w3.eth.get_transaction_count
    # self.w3.eth.accounts[0] = keyLo.address
    # self.w3.eth.defaultAccount(f&#34;0x{keyLo.key}&#34;)
    is_address = self.w3.isAddress(keyLo.address)
    # self.w3.isChecksumAddress(keyLo.address)
    self.accountAddr = keyLo.address
    print(f&#34;🔫 You are now using {keyLo.address} and it is a {&#39;valid key&#39; if is_address else &#39;invalid key&#39;}&#34;)

    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.OverrideChainConfig"><code class="name flex">
<span>def <span class="ident">OverrideChainConfig</span></span>(<span>self, one: int, wait: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Lets have the configuration done now.
:param one: ONE coin to measure
:param wait: the waiting time from each block confirmation
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OverrideChainConfig(self, one: int, wait: int) -&gt; None:
    &#34;&#34;&#34;
    Lets have the configuration done now.
    :param one: ONE coin to measure
    :param wait: the waiting time from each block confirmation
    :return:
    &#34;&#34;&#34;
    self.network_cfg.wait_time = wait
    self.network_cfg.one = one</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.OverrideGasConfig"><code class="name flex">
<span>def <span class="ident">OverrideGasConfig</span></span>(<span>self, gas: int, gas_price: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>the override the configuration for the gas amount and the gas price
:param gas: int
:param gas_price: int
:return: NONE</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OverrideGasConfig(self, gas: int, gas_price: int) -&gt; None:
    &#34;&#34;&#34;
    the override the configuration for the gas amount and the gas price
    :param gas: int
    :param gas_price: int
    :return: NONE
    &#34;&#34;&#34;
    self.network_cfg.gas = gas
    self.network_cfg.gasPrice = gas_price</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.SaveConfig"><code class="name flex">
<span>def <span class="ident">SaveConfig</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SaveConfig(self) -&gt; None:
    self.complete_deployment()</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.SetupContract"><code class="name flex">
<span>def <span class="ident">SetupContract</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetupContract(self):
    pass</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.after_deployment_initialize_settings"><code class="name flex">
<span>def <span class="ident">after_deployment_initialize_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>setup contract starting params
setup the starting time using bang
setup the first member
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def after_deployment_initialize_settings(self):
    &#34;&#34;&#34;
    setup contract starting params
    setup the starting time using bang
    setup the first member
    :return:
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.complete_deployment"><code class="name flex">
<span>def <span class="ident">complete_deployment</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>store up the deployed contrcat addresses to the local file storage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complete_deployment(self) -&gt; None:
    &#34;&#34;&#34;store up the deployed contrcat addresses to the local file storage&#34;&#34;&#34;
    self.artifact_manager.StoreTxResult(self._contract_dict, self.pathfinder.SaveDeployConfig)</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self, workspace: str, history: <built-in function any>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>connect the existing deployed contract
:param workspace: the workspace directory
:param history: the deployed history folder under the deploy_history
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self, workspace: str, history: any) -&gt; None:

    &#34;&#34;&#34;
    connect the existing deployed contract
    :param workspace: the workspace directory
    :param history: the deployed history folder under the deploy_history
    :return:
    &#34;&#34;&#34;
    self.is_deploy = False
    self.artifact_manager = SolWeb3Tool()
    if history is False:
        self.pathfinder = Paths(workspace).setDefaultPath().Network(self.network_cfg.network_name)
    else:
        self.pathfinder = Paths(workspace).SetUseHistory(history).Network(self.network_cfg.network_name)

    self.ready_io(True)</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.contract_event_in_range"><code class="name flex">
<span>def <span class="ident">contract_event_in_range</span></span>(<span>self, contract, event_name: str, from_block: int = 0, to_block: Union[int, NoneType] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>scans the blockchain, and yields blocks that has contract tx with the provided event
Note: Be cautions with the range provided, as the logic creates query for each block which could be a bottleneck.
:param from_block: starting block, defaults to 0
:param to_block: end block, defaults to 'latest'
:param provider:
:param logger:
:param contract:
:param event_name: name of the contract emit event you wish to be notified of</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contract_event_in_range(self, contract, event_name: str, from_block: int = 0, to_block: Optional[int] = None) -&gt; None:
    &#34;&#34;&#34;
    scans the blockchain, and yields blocks that has contract tx with the provided event
    Note: Be cautions with the range provided, as the logic creates query for each block which could be a bottleneck.
    :param from_block: starting block, defaults to 0
    :param to_block: end block, defaults to &#39;latest&#39;
    :param provider:
    :param logger:
    :param contract:
    :param event_name: name of the contract emit event you wish to be notified of
    &#34;&#34;&#34;
    if to_block is None:
        to_block = self.w3.eth.blockNumber

    with w3_lock:

        if isinstance(self.w3.provider, HTTPProvider):
            for block_num in range(from_block, to_block + 1):
                block = self.w3.eth.getBlock(block_num, full_transactions=True)
                contract_transactions = extract_tx_by_address(contract.address, block)

                if not contract_transactions:
                    continue
                for tx in contract_transactions:
                    _, log = event_log(tx_hash=tx.hash, events=[event_name], provider=self.w3, contract=contract.tracked_contract)
                    if log is None:
                        continue
                    yield log
        else:
            event = getattr(contract.tracked_contract.events, event_name)
            event_filter = event.createFilter(fromBlock=from_block, toBlock=to_block)

            for tx in event_filter.get_new_entries():
                _, log = event_log(tx_hash=tx.hash, events=[event_name], provider=self.w3, contract=contract.tracked_contract)

                if log is None:
                    continue

                yield log</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.deploy"><code class="name flex">
<span>def <span class="ident">deploy</span></span>(<span>self, class_name: str, params: list = [], gas_price: int = 0, gas_limit: int = 0) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>This is using the faster way to deploy files by using the specific abi and bin files.
If all these parameters to be ignored then these things will be taken from other available
valuables for gas price and gas limit
:param class_name: the input class name
:param params: the parameters
:param gas_price: the gas price
:param gas_limit: the gas limit
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deploy(self, class_name: str, params: list = [], gas_price: int = 0, gas_limit: int = 0) -&gt; bool:
    &#34;&#34;&#34;
    This is using the faster way to deploy files by using the specific abi and bin files.
    If all these parameters to be ignored then these things will be taken from other available
    valuables for gas price and gas limit
    :param class_name: the input class name
    :param params: the parameters
    :param gas_price: the gas price
    :param gas_limit: the gas limit
    :return:
    &#34;&#34;&#34;
    contract_nv = None
    try:
        solc_artifact = self.provide_artifact_extends(class_name)
        bin = BinOp(solc_artifact.bin, class_name)
        if bin.checkBinForUndeployLib() is True:
            bin.setDebug(True)
            # try to find the needed libraries in address..
            bin.anaylze(self)
            contract_nv = self.w3.eth.contract(abi=solc_artifact.abi, bytecode=bin.GetKnifedBin())
        else:
            contract_nv = self.w3.eth.contract(abi=solc_artifact.abi, bytecode=bin.GetRawBin())

    except FileNotFoundError:
        print(&#34;💢 bin or abi file is not found.&#34;)
        exit(3)
    except FoundUndeployedLibraries:
        exit(4)
    except ContractLogicError as e:
        print(f&#34;💢 Contract error {e}&#34;)
        exit(5)

    gasprice = self.gasPrice if gas_price == 0 else gas_price
    gas = self.gas if gas_limit == 0 else gas_limit
    if len(params) &gt; 0:
        _transaction = contract_nv.constructor(*params).buildTransaction({
            &#34;gasPrice&#34;: gasprice,
            &#34;gas&#34;: gas
        })
    else:
        _transaction = contract_nv.constructor().buildTransaction({
            &#34;gasPrice&#34;: gasprice,
            &#34;gas&#34;: gas
        })
    return self._endingdeployment(_transaction, class_name)</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.deployImple"><code class="name flex">
<span>def <span class="ident">deployImple</span></span>(<span>self, class_name: str, params: list = [], gas_price: int = 0, gas_limit: int = 0) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Deployment of implemented abi and code
:param class_name:
:param params:
:param gas_price:
:param gas_limit:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deployImple(self, class_name: str, params: list = [], gas_price: int = 0, gas_limit: int = 0) -&gt; bool:
    &#34;&#34;&#34;
    Deployment of implemented abi and code
    :param class_name:
    :param params:
    :param gas_price:
    :param gas_limit:
    :return:
    &#34;&#34;&#34;
    contract_nv = None
    try:
        solc_artifact = self.provide_artifact_implemented(class_name)
        bin = BinOp(solc_artifact.bin, class_name)
        if bin.checkBinForUndeployLib() is True:
            bin.setDebug(True)
            # try to find the needed libraries in address..
            bin.anaylze(self)
            contract_nv = self.w3.eth.contract(abi=solc_artifact.abi, bytecode=bin.GetKnifedBin())
        else:
            contract_nv = self.w3.eth.contract(abi=solc_artifact.abi, bytecode=bin.GetRawBin())

    except FileNotFoundError:
        print(&#34;💢 bin or abi file is not found.&#34;)
        exit(3)
    except FoundUndeployedLibraries:
        exit(4)
    except ContractLogicError as e:
        print(f&#34;💢 Contract error {e}&#34;)
        exit(5)
    gasprice = self.gasPrice if gas_price == 0 else gas_price
    gas = self.gas if gas_limit == 0 else gas_limit
    if len(params) &gt; 0:
        _transaction = contract_nv.constructor(*params).buildTransaction({
            &#34;gasPrice&#34;: gasprice,
            &#34;gas&#34;: gas
        })
    else:
        _transaction = contract_nv.constructor().buildTransaction({
            &#34;gasPrice&#34;: gasprice,
            &#34;gas&#34;: gas
        })
    self.artifact_manager.setBasePath(self.project_workspace_root)
    return self._endingdeployment(_transaction, class_name)</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.erc20_contract"><code class="name flex">
<span>def <span class="ident">erc20_contract</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def erc20_contract(self):
    cTool = SolWeb3Tool()
    cTool.setBuildNameSpace(&#34;artifact&#34;).GetCodeClassFromBuild(&#34;ERC20&#34;)
    return self.w3.eth.contract(abi=cTool.abi)</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.estimateGas"><code class="name flex">
<span>def <span class="ident">estimateGas</span></span>(<span>self, class_name: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>only for testing the contract deploy gas requirement
:param class_name:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimateGas(self, class_name: str) -&gt; int:
    &#34;&#34;&#34;
    only for testing the contract deploy gas requirement
    :param class_name:
    :return:
    &#34;&#34;&#34;
    # estimate_gas
    solc_artifact = SolWeb3Tool()
    solc_artifact.setBasePath(self.project_workspace_root)
    solc_artifact = solc_artifact.GetCodeClassFromBuild(class_name)
    nr = self.w3.eth.contract(abi=solc_artifact.abi, bytecode=solc_artifact.bin)
    gas_est_amount = nr.constructor().estimateGas()
    price = self.w3.eth.generate_gas_price()
    # source: https://ethereum.stackexchange.com/questions/84943/what-is-the-equivalent-of-buildtransaction-of-web3py-in-web3js
    print(f&#34;Price: {price}&#34;)
    return gas_est_amount</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.estimate_gas_price"><code class="name flex">
<span>def <span class="ident">estimate_gas_price</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_gas_price(self):
    return self.w3.eth.gasPrice</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.getAddr"><code class="name flex">
<span>def <span class="ident">getAddr</span></span>(<span>self, keyname: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>example: TT67rPNwgmpeimvHUMVzFfKsjL9GZ1wGw8</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAddr(self, keyname: str) -&gt; str:
    &#34;&#34;&#34;example: TT67rPNwgmpeimvHUMVzFfKsjL9GZ1wGw8&#34;&#34;&#34;
    return self._contract_dict.get(keyname)</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.getAllAddress"><code class="name flex">
<span>def <span class="ident">getAllAddress</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAllAddress(self) -&gt; dict:
    return self._contract_dict</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.getBytes"><code class="name flex">
<span>def <span class="ident">getBytes</span></span>(<span>self, key: str) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getBytes(self, key: str) -&gt; bytes:
    return bytes(self.getVal(key))</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.getBytesArray"><code class="name flex">
<span>def <span class="ident">getBytesArray</span></span>(<span>self, key: str) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getBytesArray(self, key: str) -&gt; bytearray:
    return bytearray(self.getVal(key))</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.getFloat"><code class="name flex">
<span>def <span class="ident">getFloat</span></span>(<span>self, key: str) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getFloat(self, key: str) -&gt; float:
    return float(self.getVal(key))</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.getInt"><code class="name flex">
<span>def <span class="ident">getInt</span></span>(<span>self, key: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInt(self, key: str) -&gt; int:
    return int(self.getVal(key))</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.getString"><code class="name flex">
<span>def <span class="ident">getString</span></span>(<span>self, key: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getString(self, key: str) -&gt; str:
    return str(self.getVal(key))</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.getVal"><code class="name flex">
<span>def <span class="ident">getVal</span></span>(<span>self, key: str) ‑> <built-in function any></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getVal(self, key: str) -&gt; any:
    if self.__kv_label not in self._contract_dict:
        self._contract_dict[self.__kv_label] = dict()

    if key in self._contract_dict[self.__kv_label]:
        return self._contract_dict[self.__kv_label][key]

    return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.get_block"><code class="name flex">
<span>def <span class="ident">get_block</span></span>(<span>self, block_identifier, full_transactions: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>to see the block information
:param block_identifier:
:param full_transactions:
:return: instance of moody</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_block(self, block_identifier, full_transactions: bool = False):
    &#34;&#34;&#34;
    to see the block information
    :param block_identifier:
    :param full_transactions:
    :return: instance of moody
    &#34;&#34;&#34;
    with w3_lock:
        res = self.w3.eth.getBlock(block_identifier, full_transactions)
    return res</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.hasAddressInList"><code class="name flex">
<span>def <span class="ident">hasAddressInList</span></span>(<span>self, address: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasAddressInList(self, address: str) -&gt; bool:
    if self.__list_key_label not in self._contract_dict:
        return False
    try:
        v = self._contract_dict[self.__list_key_label].index(address)
        return True
    except ValueError:
        return False</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.hasContractName"><code class="name flex">
<span>def <span class="ident">hasContractName</span></span>(<span>self, name: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasContractName(self, name: str) -&gt; bool:
    return name in self._contract_dict</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.hasField"><code class="name flex">
<span>def <span class="ident">hasField</span></span>(<span>self, key: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasField(self, key: str) -&gt; bool:
    if self.__kv_label not in self._contract_dict:
        self._contract_dict[self.__kv_label] = dict()

    if key not in self._contract_dict[self.__kv_label]:
        return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.hasList"><code class="name flex">
<span>def <span class="ident">hasList</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasList(self) -&gt; bool:
    if self.__list_key_label not in self._contract_dict:
        return False
    return len(self._contract_dict[self.__list_key_label]) &gt; 0</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.isAddress"><code class="name flex">
<span>def <span class="ident">isAddress</span></span>(<span>self, address: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Verification of the valid EVM address
:param address:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isAddress(self, address: str) -&gt; bool:
    &#34;&#34;&#34;
    Verification of the valid EVM address
    :param address:
    :return:
    &#34;&#34;&#34;
    return self.w3.isAddress(address)</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.is_deployment"><code class="name flex">
<span>def <span class="ident">is_deployment</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_deployment(self) -&gt; bool:
    return self.is_deploy</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.iterList"><code class="name flex">
<span>def <span class="ident">iterList</span></span>(<span>self) ‑> <built-in function iter></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterList(self) -&gt; iter:
    if self.__list_key_label not in self._contract_dict:
        raise Exception(&#34;there is no list in the map&#34;)
    return iter(self._contract_dict[self.__list_key_label])</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.localTranspile"><code class="name flex">
<span>def <span class="ident">localTranspile</span></span>(<span>self, dapp_ts_folder: str = None) ‑> <a title="moody.libeb.MiliDoS" href="#moody.libeb.MiliDoS">MiliDoS</a></span>
</code></dt>
<dd>
<div class="desc"><p>:param dapp_ts_folder: the destination is follow by this path {dapp_ts_folder}/src/api/abi/xxx.ts
if this valuable is None then there will not be any copy files to the destination
:return: instance of moody</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def localTranspile(self, dapp_ts_folder: str = None) -&gt; &#34;MiliDoS&#34;:
    &#34;&#34;&#34;
    :param dapp_ts_folder: the destination is follow by this path {dapp_ts_folder}/src/api/abi/xxx.ts
    if this valuable is None then there will not be any copy files to the destination
    :return: instance of moody
    &#34;&#34;&#34;
    self.pathfinder.updateTargetDappFolder(dapp_ts_folder)
    if self.is_forge:
        BuildLangForge(self.pathfinder, self._sol_list)
    else:
        BuildLang(self.pathfinder, self._sol_list)
    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.preview_all_addresses"><code class="name flex">
<span>def <span class="ident">preview_all_addresses</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preview_all_addresses(self) -&gt; None:
    print(self._contract_dict)</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.provide_artifact_extends"><code class="name flex">
<span>def <span class="ident">provide_artifact_extends</span></span>(<span>self, class_name: str) ‑> <a title="moody.libeb.SolWeb3Tool" href="#moody.libeb.SolWeb3Tool">SolWeb3Tool</a></span>
</code></dt>
<dd>
<div class="desc"><p>Following the class name of the contract
:param class_name:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def provide_artifact_extends(self, class_name: str) -&gt; SolWeb3Tool:
    &#34;&#34;&#34;
    Following the class name of the contract
    :param class_name:
    :return:
    &#34;&#34;&#34;
    if not self.artifact_manager:
        print(&#34;❌ Root path is not setup. please setup the workspace first.&#34;)
        exit(2)

    sol = self.artifact_manager
    sol.setBasePath(self.project_workspace_root)
    sol.setBuildNameSpace(&#34;build&#34;)
    sol = sol.GetCodeClassFromBuild(class_name)
    self.artifact_manager = sol
    return sol</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.provide_artifact_implemented"><code class="name flex">
<span>def <span class="ident">provide_artifact_implemented</span></span>(<span>self, class_name: str) ‑> <a title="moody.libeb.SolWeb3Tool" href="#moody.libeb.SolWeb3Tool">SolWeb3Tool</a></span>
</code></dt>
<dd>
<div class="desc"><p>Use the internal available class names. Please see the internal class name list
:param class_name:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def provide_artifact_implemented(self, class_name: str) -&gt; SolWeb3Tool:
    &#34;&#34;&#34;
    Use the internal available class names. Please see the internal class name list
    :param class_name:
    :return:
    &#34;&#34;&#34;
    if not self.artifact_manager:
        print(&#34;❌ Root path is not setup. please setup the workspace first.&#34;)
        exit(2)

    sol = self.artifact_manager
    sol.setBasePath(root_base_path)
    sol.setBuildNameSpace(&#34;artifacts&#34;)
    sol = sol.GetCodeClassFromBuild(class_name)
    self.artifact_manager = sol
    return sol</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.pushAddress"><code class="name flex">
<span>def <span class="ident">pushAddress</span></span>(<span>self, address: str, unique: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pushAddress(self, address: str, unique: bool = True) -&gt; bool:
    if self.__list_key_label not in self._contract_dict:
        self._contract_dict[self.__list_key_label] = list()

    if unique is True:
        try:
            found_index = self._contract_dict[self.__list_key_label].index(address)
            return False
        except ValueError:
            self._contract_dict[self.__list_key_label].append(address)
            return True
        except IndexError:
            self._contract_dict[self.__list_key_label].append(address)
            return True
    else:
        self._contract_dict[self.__list_key_label].append(address)
        return True</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.ready_io"><code class="name flex">
<span>def <span class="ident">ready_io</span></span>(<span>self, show_address: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>try to load up the file from the existing path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ready_io(self, show_address: bool = False):
    &#34;&#34;&#34;try to load up the file from the existing path&#34;&#34;&#34;
    try:
        self._contract_dict = self.pathfinder.LoadDeploymentFile()
        print(&#34;📦 Review the loaded deployment data from ... &#34;)
        if show_address:
            self.preview_all_addresses()
    except FileNotFoundError:
        print(&#34;💢 Deployment File is not found ...&#34;)
    except TypeError as e:
        print(e)</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.remoteCompile"><code class="name flex">
<span>def <span class="ident">remoteCompile</span></span>(<span>self, ver: str) ‑> <a title="moody.libeb.MiliDoS" href="#moody.libeb.MiliDoS">MiliDoS</a></span>
</code></dt>
<dd>
<div class="desc"><p>all parameters will be inserted automatically according to the previous setup
:param ver:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remoteCompile(self, ver: str) -&gt; &#34;MiliDoS&#34;:
    &#34;&#34;&#34;
    all parameters will be inserted automatically according to the previous setup
    :param ver:
    :return:
    &#34;&#34;&#34;
    if ver == &#34;&#34;:
        print(&#34;there is no solidity version specified&#34;)
        exit(0)
    self.pathfinder.setSolVersion(ver)
    self.pathfinder.setEvm(self.EVM_VERSION)
    BuildRemoteLinuxCommand(self.pathfinder, self._optimizations, self._sol_list, self._sol_link)
    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.removeAddress"><code class="name flex">
<span>def <span class="ident">removeAddress</span></span>(<span>self, address: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeAddress(self, address: str) -&gt; bool:
    if self.__list_key_label not in self._contract_dict:
        return False
    self._contract_dict[self.__list_key_label].remove(address)
    return True</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.send_contract_tx"><code class="name flex">
<span>def <span class="ident">send_contract_tx</span></span>(<span>self, contract: web3.contract.Contract, function_name: str, from_acc: str, private_key: bytes, gas: int = 0, gas_price: int = 0, args: Tuple = ())</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the contract tx and signs it with private_key to be transmitted as raw tx</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_contract_tx(self, contract: Web3Contract, function_name: str, from_acc: str,
                     private_key: bytes, gas: int = 0, gas_price: int = 0, _value: int = 0,
                     args: Tuple = ()):
    &#34;&#34;&#34;
    Creates the contract tx and signs it with private_key to be transmitted as raw tx
    &#34;&#34;&#34;

    tx = getattr(contract.functions, function_name)(*args).buildTransaction(
        {
            &#39;from&#39;: from_acc,
            &#39;chainId&#39;: self.w3.eth.chainId,
            # gas_price is in gwei
            &#39;gasPrice&#39;: gas_price * 1e9 if gas_price else self.estimate_gas_price(),
            &#39;gas&#39;: gas or None,
            &#39;nonce&#39;: self.w3.eth.getTransactionCount(from_acc, block_identifier=&#39;pending&#39;),
            &#39;value&#39;: _value
        })
    signed_txn = self.w3.eth.account.sign_transaction(tx, private_key)
    return self.w3.eth.sendRawTransaction(signed_txn.rawTransaction)</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.setClassSolLinks"><code class="name flex">
<span>def <span class="ident">setClassSolLinks</span></span>(<span>self, compile_links: list) ‑> <a title="moody.libeb.MiliDoS" href="#moody.libeb.MiliDoS">MiliDoS</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setClassSolLinks(self, compile_links: list) -&gt; &#34;MiliDoS&#34;:
    self._sol_link = compile_links
    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.setClassSolNames"><code class="name flex">
<span>def <span class="ident">setClassSolNames</span></span>(<span>self, to_compile_contract_list: list) ‑> <a title="moody.libeb.MiliDoS" href="#moody.libeb.MiliDoS">MiliDoS</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setClassSolNames(self, to_compile_contract_list: list) -&gt; &#34;MiliDoS&#34;:
    self._sol_list = to_compile_contract_list
    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.setEvm"><code class="name flex">
<span>def <span class="ident">setEvm</span></span>(<span>self, version_evm: str) ‑> <a title="moody.libeb.MiliDoS" href="#moody.libeb.MiliDoS">MiliDoS</a></span>
</code></dt>
<dd>
<div class="desc"><p>the specify the version of the ethereum virtual machine
:param version_evm: the version of the EVM
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setEvm(self, version_evm: str) -&gt; &#34;MiliDoS&#34;:
    &#34;&#34;&#34;
    the specify the version of the ethereum virtual machine
    :param version_evm: the version of the EVM
    :return:
    &#34;&#34;&#34;
    self.EVM_VERSION = version_evm
    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.setKV"><code class="name flex">
<span>def <span class="ident">setKV</span></span>(<span>self, key: str, value: <built-in function any>) ‑> <a title="moody.libeb.MiliDoS" href="#moody.libeb.MiliDoS">MiliDoS</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setKV(self, key: str, value: any) -&gt; &#34;MiliDoS&#34;:
    if self.__kv_label not in self._contract_dict:
        self._contract_dict[self.__kv_label] = dict()
    self._contract_dict[self.__kv_label][key] = value
    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.setOptimizationRuns"><code class="name flex">
<span>def <span class="ident">setOptimizationRuns</span></span>(<span>self, runs: int) ‑> <a title="moody.libeb.MiliDoS" href="#moody.libeb.MiliDoS">MiliDoS</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setOptimizationRuns(self, runs: int) -&gt; &#34;MiliDoS&#34;:
    self._optimizations = runs
    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.setTargetClass"><code class="name flex">
<span>def <span class="ident">setTargetClass</span></span>(<span>self, classname: str) ‑> <a title="moody.libeb.MiliDoS" href="#moody.libeb.MiliDoS">MiliDoS</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setTargetClass(self, classname: str) -&gt; &#34;MiliDoS&#34;:
    self.last_class = classname
    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.setTargetListName"><code class="name flex">
<span>def <span class="ident">setTargetListName</span></span>(<span>self, listname: str) ‑> <a title="moody.libeb.MiliDoS" href="#moody.libeb.MiliDoS">MiliDoS</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setTargetListName(self, listname: str) -&gt; &#34;MiliDoS&#34;:
    self.list_type = listname
    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.setWorkspace"><code class="name flex">
<span>def <span class="ident">setWorkspace</span></span>(<span>self, path: str, readio: bool = True) ‑> <a title="moody.libeb.MiliDoS" href="#moody.libeb.MiliDoS">MiliDoS</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setWorkspace(self, path: str, readio: bool = True) -&gt; &#34;MiliDoS&#34;:
    self.project_workspace_root = path
    self.artifact_manager = SolWeb3Tool()
    self.pathfinder = Paths(path).setDefaultPath().Network(self.network_cfg.network_name)
    if readio:
        self.ready_io(True)
    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.useForge"><code class="name flex">
<span>def <span class="ident">useForge</span></span>(<span>self) ‑> <a title="moody.libeb.MiliDoS" href="#moody.libeb.MiliDoS">MiliDoS</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def useForge(self) -&gt; &#34;MiliDoS&#34;:
    # ==================================================
    if self._sol_list is not None:
        for v in self._sol_list:
            based_name = os.path.basename(v)
            class_name = based_name.replace(&#34;.sol&#34;, &#34;&#34;)
            # class_name_process = filter_file_name(based_name).replace(&#39;.sol&#39;, &#39;&#39;)
            self.artifact_manager.SplitForgeBuild(class_name)
        self.is_forge = True
    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.MiliDoS.withPOA"><code class="name flex">
<span>def <span class="ident">withPOA</span></span>(<span>self) ‑> <a title="moody.libeb.MiliDoS" href="#moody.libeb.MiliDoS">MiliDoS</a></span>
</code></dt>
<dd>
<div class="desc"><p>the normal usual term to fix some POA related problems
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def withPOA(self) -&gt; &#34;MiliDoS&#34;:
    &#34;&#34;&#34;
    the normal usual term to fix some POA related problems
    :return:
    &#34;&#34;&#34;
    self.w3.middleware_onion.inject(geth_poa_middleware, layer=0)
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="moody.libeb.SolWeb3Tool"><code class="flex name class">
<span>class <span class="ident">SolWeb3Tool</span></span>
</code></dt>
<dd>
<div class="desc"><p>This is the tool to build operation of the compiling solidity contract source code
Try to make some improvement of code to make better access
This is the artifact manager as we know it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SolWeb3Tool(object):
    &#34;&#34;&#34;
    This is the tool to build operation of the compiling solidity contract source code
    Try to make some improvement of code to make better access
    This is the artifact manager as we know it
    &#34;&#34;&#34;
    OUTPUT_BUILD = &#34;build&#34;
    WORKSPACE_PATH = &#34;&#34;
    solfolder = &#34;&#34;
    file_name = &#34;xxx.sol&#34;
    prefixname = &#34;&#34;
    statement = &#39;End : {}, IO File {}&#39;

    def __init__(self):
        self._abi = None
        self._bin = None
        self._meta = None
        self.combined_data = None
        self._key = None

    def setBuildNameSpace(self, path: str) -&gt; &#34;SolWeb3Tool&#34;:
        self.OUTPUT_BUILD = path
        return self

    def setBasePath(self, path: str) -&gt; &#34;SolWeb3Tool&#34;:
        self.WORKSPACE_PATH = path
        return self

    def SplitForgeBuild(self, class_name: str) -&gt; &#34;SolWeb3Tool&#34;:
        uncutjson = dict()
        combinedjson = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}.sol&#34;.format(class_name), &#34;{}.json&#34;.format(class_name))
        try:
            uncutjson = json.load(codecs.open(combinedjson, &#39;r&#39;, &#39;utf-8-sig&#39;))
        except FileNotFoundError:
            print(&#34;Some of the files from the build in forge is not found&#34;)
            exit(3)
        abifile = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}.sol&#34;.format(class_name), &#34;{}.abi&#34;.format(class_name))
        binfile = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}.sol&#34;.format(class_name), &#34;{}.bin&#34;.format(class_name))

        if &#34;abi&#34; in uncutjson:
            predum = uncutjson[&#34;abi&#34;]
            writeFile(json.dumps(predum, ensure_ascii=False), abifile)

        if &#34;deployedBytecode&#34; in uncutjson:
            pr = uncutjson[&#34;deployedBytecode&#34;]
            if &#34;object&#34; in pr:
                pr2 = pr[&#34;object&#34;]
                pr2 = pr2.replace(&#34;0x&#34;, &#34;&#34;)
                writeFile(pr2, binfile)
            if &#34;linkReferences&#34; in pr:
                links = pr[&#34;linkReferences&#34;]
                for a in links:
                    print(&#34;found link&#34;)

        return self

    def GetCodeClassFromBuild(self, class_name: str) -&gt; &#34;SolWeb3Tool&#34;:
        &#34;&#34;&#34;
        get the independent files and content from the file system
        :param class_name:
        :return:
        &#34;&#34;&#34;
        p1bin = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}.bin&#34;.format(class_name))
        p2abi = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}.abi&#34;.format(class_name))
        metafile = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}_meta.json&#34;.format(class_name))
        try:
            self._bin = codecs.open(p1bin, &#39;r&#39;, &#39;utf-8-sig&#39;).read()
            self._abi = json.load(codecs.open(p2abi, &#39;r&#39;, &#39;utf-8-sig&#39;))
            self._meta = json.load(codecs.open(metafile, &#39;r&#39;, &#39;utf-8-sig&#39;))
        except FileNotFoundError:
            print(&#34;Some of the files from the build is not found&#34;)
            exit(3)
        return self

    def LoadInternalMeta(self, class_name: str) -&gt; &#34;SolWeb3Tool&#34;:
        metafile = os.path.join(root_base_path, self.OUTPUT_BUILD, &#34;{}_meta.json&#34;.format(class_name))
        self._meta = json.load(codecs.open(metafile, &#39;r&#39;, &#39;utf-8-sig&#39;))
        return self

    def GetMetadata(self) -&gt; dict:
        return self._meta

    def GetSourceFileRead(self, file_name: str) -&gt; str:
        asfile = os.path.join(self.WORKSPACE_PATH, file_name)
        return self.ReadAsStr(asfile)

    def ReadAsStr(self, file_name: str) -&gt; str:
        return codecs.open(file_name, &#39;r&#39;, &#39;utf-8-sig&#39;).read()

    def ReadAsStrAndEscape(self, file_name: str) -&gt; str:
        loaded = self.ReadAsStr(file_name)
        return re.escape(loaded)

    def GetMetaCompilerVer(self, full: bool = False) -&gt; str:
        if &#34;compiler&#34; not in self._meta:
            print(&#34;key compiler is not found&#34;)
            return &#34;&#34;
        if &#34;version&#34; not in self._meta[&#34;compiler&#34;]:
            print(&#34;key version is not found&#34;)
            return &#34;&#34;

        version_text = self._meta[&#34;compiler&#34;][&#34;version&#34;]
        matches = re.search(regex2, version_text)

        if full is True:
            return version_text.replace(&#39;.Emscripten.clang&#39;, &#39;&#39;)
        else:
            return matches.group()

    def GetMetaSettings(self) -&gt; any:

        if &#34;settings&#34; not in self._meta:
            print(&#34;key settings is not found&#34;)
            return False
        if &#34;evmVersion&#34; not in self._meta[&#34;settings&#34;]:
            print(&#34;key version is not found&#34;)
            return False
        if &#34;libraries&#34; not in self._meta[&#34;settings&#34;]:
            print(&#34;key version is not found&#34;)
            return False

        if &#34;optimizer&#34; not in self._meta[&#34;settings&#34;]:
            print(&#34;key version is not found&#34;)
            return False

        meta = MetaSetting(
            evm=self._meta[&#34;settings&#34;][&#34;evmVersion&#34;],
            solidity_ver=self.GetMetaCompilerVer(False),
            solidity_ver_full=self.GetMetaCompilerVer(True),
            linkLib=self._meta[&#34;settings&#34;][&#34;libraries&#34;],
            optimization_runs=self._meta[&#34;settings&#34;][&#34;optimizer&#34;][&#34;runs&#34;],
            optimization_enabled=self._meta[&#34;settings&#34;][&#34;optimizer&#34;][&#34;enabled&#34;]
        )

        return meta

    def GetCombinedFile(self) -&gt; &#34;SolWeb3Tool&#34;:
        pathc = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;combined.json&#34;)
        try:
            pathcli = codecs.open(pathc, &#39;r&#39;, &#39;utf-8-sig&#39;)
            self.combined_data = json.load(pathcli)
        except Exception as e:
            print(&#34;Problems from loading items from the file: &#34;, e)
        return self

    def byClassName(self, path: str, classname: str) -&gt; str:
        # generating the string with path and class name
        return &#34;{prefix}:{name}&#34;.format(prefix=path, name=classname)

    def GetCodeTag(self, fullname) -&gt; [str, str]:
        &#34;&#34;&#34;
        Search for the abi session and the bin session from the meta source file
        from combined.json
        :param fullname: initial file name
        :return: abi code and the bin code
        &#34;&#34;&#34;
        return self.combined_data[&#34;contracts&#34;][fullname][&#34;abi&#34;], self.combined_data[&#34;contracts&#34;][fullname][&#34;bin&#34;]

    def GetCode(self, path: str, classname: str) -&gt; [str, str]:
        &#34;&#34;&#34;
        Search for the abi session and the bin session from the meta source file
        get the code and abi from combined.json
        :param path:
        :param classname:
        :return:
        &#34;&#34;&#34;
        return self.GetCodeTag(self.byClassName(path, classname))

    def CompileBash(self) -&gt; None:
        &#34;&#34;&#34;
        This is the remote command to execute the solc_remote bash file
        using remote compile method to compile the sol files
        all works will be done with the remote server or using the docker
        &#34;&#34;&#34;
        list_files = subprocess.run([&#34;{}/solc_remote&#34;.format(self.WORKSPACE_PATH)])
        print(&#34;The exit code was: %d&#34; % list_files.returncode)

    @property
    def abi(self) -&gt; str:
        return self._abi

    @property
    def bin(self) -&gt; str:
        return self._bin

    @property
    def workspace(self) -&gt; str:
        return self.WORKSPACE_PATH

    def StoreTxResult(self, tx_result_data: any, filepath: str) -&gt; None:
        &#34;&#34;&#34;
        Having the result of the transaction data to be stored in an external JSON file.
        :param tx_result_data: input data
        :param filepath: the file name path
        :return: nothing to return
        &#34;&#34;&#34;
        predump = toDict(tx_result_data)
        writeFile(json.dumps(predump, ensure_ascii=False), filepath)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="moody.libeb.SolWeb3Tool.OUTPUT_BUILD"><code class="name">var <span class="ident">OUTPUT_BUILD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="moody.libeb.SolWeb3Tool.WORKSPACE_PATH"><code class="name">var <span class="ident">WORKSPACE_PATH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="moody.libeb.SolWeb3Tool.file_name"><code class="name">var <span class="ident">file_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="moody.libeb.SolWeb3Tool.prefixname"><code class="name">var <span class="ident">prefixname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="moody.libeb.SolWeb3Tool.solfolder"><code class="name">var <span class="ident">solfolder</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="moody.libeb.SolWeb3Tool.statement"><code class="name">var <span class="ident">statement</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="moody.libeb.SolWeb3Tool.abi"><code class="name">var <span class="ident">abi</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def abi(self) -&gt; str:
    return self._abi</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.bin"><code class="name">var <span class="ident">bin</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bin(self) -&gt; str:
    return self._bin</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.workspace"><code class="name">var <span class="ident">workspace</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def workspace(self) -&gt; str:
    return self.WORKSPACE_PATH</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="moody.libeb.SolWeb3Tool.CompileBash"><code class="name flex">
<span>def <span class="ident">CompileBash</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>This is the remote command to execute the solc_remote bash file
using remote compile method to compile the sol files
all works will be done with the remote server or using the docker</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CompileBash(self) -&gt; None:
    &#34;&#34;&#34;
    This is the remote command to execute the solc_remote bash file
    using remote compile method to compile the sol files
    all works will be done with the remote server or using the docker
    &#34;&#34;&#34;
    list_files = subprocess.run([&#34;{}/solc_remote&#34;.format(self.WORKSPACE_PATH)])
    print(&#34;The exit code was: %d&#34; % list_files.returncode)</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.GetCode"><code class="name flex">
<span>def <span class="ident">GetCode</span></span>(<span>self, path: str, classname: str) ‑> [<class 'str'>, <class 'str'>]</span>
</code></dt>
<dd>
<div class="desc"><p>Search for the abi session and the bin session from the meta source file
get the code and abi from combined.json
:param path:
:param classname:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetCode(self, path: str, classname: str) -&gt; [str, str]:
    &#34;&#34;&#34;
    Search for the abi session and the bin session from the meta source file
    get the code and abi from combined.json
    :param path:
    :param classname:
    :return:
    &#34;&#34;&#34;
    return self.GetCodeTag(self.byClassName(path, classname))</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.GetCodeClassFromBuild"><code class="name flex">
<span>def <span class="ident">GetCodeClassFromBuild</span></span>(<span>self, class_name: str) ‑> <a title="moody.libeb.SolWeb3Tool" href="#moody.libeb.SolWeb3Tool">SolWeb3Tool</a></span>
</code></dt>
<dd>
<div class="desc"><p>get the independent files and content from the file system
:param class_name:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetCodeClassFromBuild(self, class_name: str) -&gt; &#34;SolWeb3Tool&#34;:
    &#34;&#34;&#34;
    get the independent files and content from the file system
    :param class_name:
    :return:
    &#34;&#34;&#34;
    p1bin = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}.bin&#34;.format(class_name))
    p2abi = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}.abi&#34;.format(class_name))
    metafile = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}_meta.json&#34;.format(class_name))
    try:
        self._bin = codecs.open(p1bin, &#39;r&#39;, &#39;utf-8-sig&#39;).read()
        self._abi = json.load(codecs.open(p2abi, &#39;r&#39;, &#39;utf-8-sig&#39;))
        self._meta = json.load(codecs.open(metafile, &#39;r&#39;, &#39;utf-8-sig&#39;))
    except FileNotFoundError:
        print(&#34;Some of the files from the build is not found&#34;)
        exit(3)
    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.GetCodeTag"><code class="name flex">
<span>def <span class="ident">GetCodeTag</span></span>(<span>self, fullname) ‑> [<class 'str'>, <class 'str'>]</span>
</code></dt>
<dd>
<div class="desc"><p>Search for the abi session and the bin session from the meta source file
from combined.json
:param fullname: initial file name
:return: abi code and the bin code</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetCodeTag(self, fullname) -&gt; [str, str]:
    &#34;&#34;&#34;
    Search for the abi session and the bin session from the meta source file
    from combined.json
    :param fullname: initial file name
    :return: abi code and the bin code
    &#34;&#34;&#34;
    return self.combined_data[&#34;contracts&#34;][fullname][&#34;abi&#34;], self.combined_data[&#34;contracts&#34;][fullname][&#34;bin&#34;]</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.GetCombinedFile"><code class="name flex">
<span>def <span class="ident">GetCombinedFile</span></span>(<span>self) ‑> <a title="moody.libeb.SolWeb3Tool" href="#moody.libeb.SolWeb3Tool">SolWeb3Tool</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetCombinedFile(self) -&gt; &#34;SolWeb3Tool&#34;:
    pathc = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;combined.json&#34;)
    try:
        pathcli = codecs.open(pathc, &#39;r&#39;, &#39;utf-8-sig&#39;)
        self.combined_data = json.load(pathcli)
    except Exception as e:
        print(&#34;Problems from loading items from the file: &#34;, e)
    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.GetMetaCompilerVer"><code class="name flex">
<span>def <span class="ident">GetMetaCompilerVer</span></span>(<span>self, full: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetMetaCompilerVer(self, full: bool = False) -&gt; str:
    if &#34;compiler&#34; not in self._meta:
        print(&#34;key compiler is not found&#34;)
        return &#34;&#34;
    if &#34;version&#34; not in self._meta[&#34;compiler&#34;]:
        print(&#34;key version is not found&#34;)
        return &#34;&#34;

    version_text = self._meta[&#34;compiler&#34;][&#34;version&#34;]
    matches = re.search(regex2, version_text)

    if full is True:
        return version_text.replace(&#39;.Emscripten.clang&#39;, &#39;&#39;)
    else:
        return matches.group()</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.GetMetaSettings"><code class="name flex">
<span>def <span class="ident">GetMetaSettings</span></span>(<span>self) ‑> <built-in function any></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetMetaSettings(self) -&gt; any:

    if &#34;settings&#34; not in self._meta:
        print(&#34;key settings is not found&#34;)
        return False
    if &#34;evmVersion&#34; not in self._meta[&#34;settings&#34;]:
        print(&#34;key version is not found&#34;)
        return False
    if &#34;libraries&#34; not in self._meta[&#34;settings&#34;]:
        print(&#34;key version is not found&#34;)
        return False

    if &#34;optimizer&#34; not in self._meta[&#34;settings&#34;]:
        print(&#34;key version is not found&#34;)
        return False

    meta = MetaSetting(
        evm=self._meta[&#34;settings&#34;][&#34;evmVersion&#34;],
        solidity_ver=self.GetMetaCompilerVer(False),
        solidity_ver_full=self.GetMetaCompilerVer(True),
        linkLib=self._meta[&#34;settings&#34;][&#34;libraries&#34;],
        optimization_runs=self._meta[&#34;settings&#34;][&#34;optimizer&#34;][&#34;runs&#34;],
        optimization_enabled=self._meta[&#34;settings&#34;][&#34;optimizer&#34;][&#34;enabled&#34;]
    )

    return meta</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.GetMetadata"><code class="name flex">
<span>def <span class="ident">GetMetadata</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetMetadata(self) -&gt; dict:
    return self._meta</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.GetSourceFileRead"><code class="name flex">
<span>def <span class="ident">GetSourceFileRead</span></span>(<span>self, file_name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetSourceFileRead(self, file_name: str) -&gt; str:
    asfile = os.path.join(self.WORKSPACE_PATH, file_name)
    return self.ReadAsStr(asfile)</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.LoadInternalMeta"><code class="name flex">
<span>def <span class="ident">LoadInternalMeta</span></span>(<span>self, class_name: str) ‑> <a title="moody.libeb.SolWeb3Tool" href="#moody.libeb.SolWeb3Tool">SolWeb3Tool</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LoadInternalMeta(self, class_name: str) -&gt; &#34;SolWeb3Tool&#34;:
    metafile = os.path.join(root_base_path, self.OUTPUT_BUILD, &#34;{}_meta.json&#34;.format(class_name))
    self._meta = json.load(codecs.open(metafile, &#39;r&#39;, &#39;utf-8-sig&#39;))
    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.ReadAsStr"><code class="name flex">
<span>def <span class="ident">ReadAsStr</span></span>(<span>self, file_name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ReadAsStr(self, file_name: str) -&gt; str:
    return codecs.open(file_name, &#39;r&#39;, &#39;utf-8-sig&#39;).read()</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.ReadAsStrAndEscape"><code class="name flex">
<span>def <span class="ident">ReadAsStrAndEscape</span></span>(<span>self, file_name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ReadAsStrAndEscape(self, file_name: str) -&gt; str:
    loaded = self.ReadAsStr(file_name)
    return re.escape(loaded)</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.SplitForgeBuild"><code class="name flex">
<span>def <span class="ident">SplitForgeBuild</span></span>(<span>self, class_name: str) ‑> <a title="moody.libeb.SolWeb3Tool" href="#moody.libeb.SolWeb3Tool">SolWeb3Tool</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SplitForgeBuild(self, class_name: str) -&gt; &#34;SolWeb3Tool&#34;:
    uncutjson = dict()
    combinedjson = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}.sol&#34;.format(class_name), &#34;{}.json&#34;.format(class_name))
    try:
        uncutjson = json.load(codecs.open(combinedjson, &#39;r&#39;, &#39;utf-8-sig&#39;))
    except FileNotFoundError:
        print(&#34;Some of the files from the build in forge is not found&#34;)
        exit(3)
    abifile = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}.sol&#34;.format(class_name), &#34;{}.abi&#34;.format(class_name))
    binfile = os.path.join(self.WORKSPACE_PATH, self.OUTPUT_BUILD, &#34;{}.sol&#34;.format(class_name), &#34;{}.bin&#34;.format(class_name))

    if &#34;abi&#34; in uncutjson:
        predum = uncutjson[&#34;abi&#34;]
        writeFile(json.dumps(predum, ensure_ascii=False), abifile)

    if &#34;deployedBytecode&#34; in uncutjson:
        pr = uncutjson[&#34;deployedBytecode&#34;]
        if &#34;object&#34; in pr:
            pr2 = pr[&#34;object&#34;]
            pr2 = pr2.replace(&#34;0x&#34;, &#34;&#34;)
            writeFile(pr2, binfile)
        if &#34;linkReferences&#34; in pr:
            links = pr[&#34;linkReferences&#34;]
            for a in links:
                print(&#34;found link&#34;)

    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.StoreTxResult"><code class="name flex">
<span>def <span class="ident">StoreTxResult</span></span>(<span>self, tx_result_data: <built-in function any>, filepath: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Having the result of the transaction data to be stored in an external JSON file.
:param tx_result_data: input data
:param filepath: the file name path
:return: nothing to return</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StoreTxResult(self, tx_result_data: any, filepath: str) -&gt; None:
    &#34;&#34;&#34;
    Having the result of the transaction data to be stored in an external JSON file.
    :param tx_result_data: input data
    :param filepath: the file name path
    :return: nothing to return
    &#34;&#34;&#34;
    predump = toDict(tx_result_data)
    writeFile(json.dumps(predump, ensure_ascii=False), filepath)</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.byClassName"><code class="name flex">
<span>def <span class="ident">byClassName</span></span>(<span>self, path: str, classname: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def byClassName(self, path: str, classname: str) -&gt; str:
    # generating the string with path and class name
    return &#34;{prefix}:{name}&#34;.format(prefix=path, name=classname)</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.setBasePath"><code class="name flex">
<span>def <span class="ident">setBasePath</span></span>(<span>self, path: str) ‑> <a title="moody.libeb.SolWeb3Tool" href="#moody.libeb.SolWeb3Tool">SolWeb3Tool</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setBasePath(self, path: str) -&gt; &#34;SolWeb3Tool&#34;:
    self.WORKSPACE_PATH = path
    return self</code></pre>
</details>
</dd>
<dt id="moody.libeb.SolWeb3Tool.setBuildNameSpace"><code class="name flex">
<span>def <span class="ident">setBuildNameSpace</span></span>(<span>self, path: str) ‑> <a title="moody.libeb.SolWeb3Tool" href="#moody.libeb.SolWeb3Tool">SolWeb3Tool</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setBuildNameSpace(self, path: str) -&gt; &#34;SolWeb3Tool&#34;:
    self.OUTPUT_BUILD = path
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="moody" href="index.html">moody</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="moody.libeb.Logd" href="#moody.libeb.Logd">Logd</a></code></li>
<li><code><a title="moody.libeb.event_log" href="#moody.libeb.event_log">event_log</a></code></li>
<li><code><a title="moody.libeb.extract_tx_by_address" href="#moody.libeb.extract_tx_by_address">extract_tx_by_address</a></code></li>
<li><code><a title="moody.libeb.normalize_address" href="#moody.libeb.normalize_address">normalize_address</a></code></li>
<li><code><a title="moody.libeb.toDict" href="#moody.libeb.toDict">toDict</a></code></li>
<li><code><a title="moody.libeb.web3_provider" href="#moody.libeb.web3_provider">web3_provider</a></code></li>
<li><code><a title="moody.libeb.writeFile" href="#moody.libeb.writeFile">writeFile</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="moody.libeb.BinOp" href="#moody.libeb.BinOp">BinOp</a></code></h4>
<ul class="">
<li><code><a title="moody.libeb.BinOp.GetKnifedBin" href="#moody.libeb.BinOp.GetKnifedBin">GetKnifedBin</a></code></li>
<li><code><a title="moody.libeb.BinOp.GetRawBin" href="#moody.libeb.BinOp.GetRawBin">GetRawBin</a></code></li>
<li><code><a title="moody.libeb.BinOp.anaylze" href="#moody.libeb.BinOp.anaylze">anaylze</a></code></li>
<li><code><a title="moody.libeb.BinOp.checkBinForUndeployLib" href="#moody.libeb.BinOp.checkBinForUndeployLib">checkBinForUndeployLib</a></code></li>
<li><code><a title="moody.libeb.BinOp.fromLine" href="#moody.libeb.BinOp.fromLine">fromLine</a></code></li>
<li><code><a title="moody.libeb.BinOp.setDebug" href="#moody.libeb.BinOp.setDebug">setDebug</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.libeb.HexJsonEncoder" href="#moody.libeb.HexJsonEncoder">HexJsonEncoder</a></code></h4>
<ul class="">
<li><code><a title="moody.libeb.HexJsonEncoder.default" href="#moody.libeb.HexJsonEncoder.default">default</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.libeb.IDos" href="#moody.libeb.IDos">IDos</a></code></h4>
<ul class="">
<li><code><a title="moody.libeb.IDos.getAddr" href="#moody.libeb.IDos.getAddr">getAddr</a></code></li>
<li><code><a title="moody.libeb.IDos.hasContractName" href="#moody.libeb.IDos.hasContractName">hasContractName</a></code></li>
<li><code><a title="moody.libeb.IDos.isAddress" href="#moody.libeb.IDos.isAddress">isAddress</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.libeb.MiliDoS" href="#moody.libeb.MiliDoS">MiliDoS</a></code></h4>
<ul class="">
<li><code><a title="moody.libeb.MiliDoS.Auth" href="#moody.libeb.MiliDoS.Auth">Auth</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.AuthByMemo" href="#moody.libeb.MiliDoS.AuthByMemo">AuthByMemo</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.EVM_VERSION" href="#moody.libeb.MiliDoS.EVM_VERSION">EVM_VERSION</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.LinkTokenAddress" href="#moody.libeb.MiliDoS.LinkTokenAddress">LinkTokenAddress</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.LinkVRFCoordinator" href="#moody.libeb.MiliDoS.LinkVRFCoordinator">LinkVRFCoordinator</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.LinkVRFHashKey" href="#moody.libeb.MiliDoS.LinkVRFHashKey">LinkVRFHashKey</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.OverrideChainConfig" href="#moody.libeb.MiliDoS.OverrideChainConfig">OverrideChainConfig</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.OverrideGasConfig" href="#moody.libeb.MiliDoS.OverrideGasConfig">OverrideGasConfig</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.SaveConfig" href="#moody.libeb.MiliDoS.SaveConfig">SaveConfig</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.SetupContract" href="#moody.libeb.MiliDoS.SetupContract">SetupContract</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.after_deployment_initialize_settings" href="#moody.libeb.MiliDoS.after_deployment_initialize_settings">after_deployment_initialize_settings</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.complete_deployment" href="#moody.libeb.MiliDoS.complete_deployment">complete_deployment</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.connect" href="#moody.libeb.MiliDoS.connect">connect</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.contract_event_in_range" href="#moody.libeb.MiliDoS.contract_event_in_range">contract_event_in_range</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.deploy" href="#moody.libeb.MiliDoS.deploy">deploy</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.deployImple" href="#moody.libeb.MiliDoS.deployImple">deployImple</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.erc20_contract" href="#moody.libeb.MiliDoS.erc20_contract">erc20_contract</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.estimateGas" href="#moody.libeb.MiliDoS.estimateGas">estimateGas</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.estimate_gas_price" href="#moody.libeb.MiliDoS.estimate_gas_price">estimate_gas_price</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.gas" href="#moody.libeb.MiliDoS.gas">gas</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.gasPrice" href="#moody.libeb.MiliDoS.gasPrice">gasPrice</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.getAddr" href="#moody.libeb.MiliDoS.getAddr">getAddr</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.getAllAddress" href="#moody.libeb.MiliDoS.getAllAddress">getAllAddress</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.getBytes" href="#moody.libeb.MiliDoS.getBytes">getBytes</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.getBytesArray" href="#moody.libeb.MiliDoS.getBytesArray">getBytesArray</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.getFloat" href="#moody.libeb.MiliDoS.getFloat">getFloat</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.getInt" href="#moody.libeb.MiliDoS.getInt">getInt</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.getString" href="#moody.libeb.MiliDoS.getString">getString</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.getVal" href="#moody.libeb.MiliDoS.getVal">getVal</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.get_block" href="#moody.libeb.MiliDoS.get_block">get_block</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.hasAddressInList" href="#moody.libeb.MiliDoS.hasAddressInList">hasAddressInList</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.hasContractName" href="#moody.libeb.MiliDoS.hasContractName">hasContractName</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.hasField" href="#moody.libeb.MiliDoS.hasField">hasField</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.hasList" href="#moody.libeb.MiliDoS.hasList">hasList</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.isAddress" href="#moody.libeb.MiliDoS.isAddress">isAddress</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.is_deployment" href="#moody.libeb.MiliDoS.is_deployment">is_deployment</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.iterList" href="#moody.libeb.MiliDoS.iterList">iterList</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.localTranspile" href="#moody.libeb.MiliDoS.localTranspile">localTranspile</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.one" href="#moody.libeb.MiliDoS.one">one</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.preview_all_addresses" href="#moody.libeb.MiliDoS.preview_all_addresses">preview_all_addresses</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.provide_artifact_extends" href="#moody.libeb.MiliDoS.provide_artifact_extends">provide_artifact_extends</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.provide_artifact_implemented" href="#moody.libeb.MiliDoS.provide_artifact_implemented">provide_artifact_implemented</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.pushAddress" href="#moody.libeb.MiliDoS.pushAddress">pushAddress</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.ready_io" href="#moody.libeb.MiliDoS.ready_io">ready_io</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.remoteCompile" href="#moody.libeb.MiliDoS.remoteCompile">remoteCompile</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.removeAddress" href="#moody.libeb.MiliDoS.removeAddress">removeAddress</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.send_contract_tx" href="#moody.libeb.MiliDoS.send_contract_tx">send_contract_tx</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.setClassSolLinks" href="#moody.libeb.MiliDoS.setClassSolLinks">setClassSolLinks</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.setClassSolNames" href="#moody.libeb.MiliDoS.setClassSolNames">setClassSolNames</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.setEvm" href="#moody.libeb.MiliDoS.setEvm">setEvm</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.setKV" href="#moody.libeb.MiliDoS.setKV">setKV</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.setOptimizationRuns" href="#moody.libeb.MiliDoS.setOptimizationRuns">setOptimizationRuns</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.setTargetClass" href="#moody.libeb.MiliDoS.setTargetClass">setTargetClass</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.setTargetListName" href="#moody.libeb.MiliDoS.setTargetListName">setTargetListName</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.setWorkspace" href="#moody.libeb.MiliDoS.setWorkspace">setWorkspace</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.useForge" href="#moody.libeb.MiliDoS.useForge">useForge</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.waitSec" href="#moody.libeb.MiliDoS.waitSec">waitSec</a></code></li>
<li><code><a title="moody.libeb.MiliDoS.withPOA" href="#moody.libeb.MiliDoS.withPOA">withPOA</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="moody.libeb.SolWeb3Tool" href="#moody.libeb.SolWeb3Tool">SolWeb3Tool</a></code></h4>
<ul class="">
<li><code><a title="moody.libeb.SolWeb3Tool.CompileBash" href="#moody.libeb.SolWeb3Tool.CompileBash">CompileBash</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.GetCode" href="#moody.libeb.SolWeb3Tool.GetCode">GetCode</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.GetCodeClassFromBuild" href="#moody.libeb.SolWeb3Tool.GetCodeClassFromBuild">GetCodeClassFromBuild</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.GetCodeTag" href="#moody.libeb.SolWeb3Tool.GetCodeTag">GetCodeTag</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.GetCombinedFile" href="#moody.libeb.SolWeb3Tool.GetCombinedFile">GetCombinedFile</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.GetMetaCompilerVer" href="#moody.libeb.SolWeb3Tool.GetMetaCompilerVer">GetMetaCompilerVer</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.GetMetaSettings" href="#moody.libeb.SolWeb3Tool.GetMetaSettings">GetMetaSettings</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.GetMetadata" href="#moody.libeb.SolWeb3Tool.GetMetadata">GetMetadata</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.GetSourceFileRead" href="#moody.libeb.SolWeb3Tool.GetSourceFileRead">GetSourceFileRead</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.LoadInternalMeta" href="#moody.libeb.SolWeb3Tool.LoadInternalMeta">LoadInternalMeta</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.OUTPUT_BUILD" href="#moody.libeb.SolWeb3Tool.OUTPUT_BUILD">OUTPUT_BUILD</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.ReadAsStr" href="#moody.libeb.SolWeb3Tool.ReadAsStr">ReadAsStr</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.ReadAsStrAndEscape" href="#moody.libeb.SolWeb3Tool.ReadAsStrAndEscape">ReadAsStrAndEscape</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.SplitForgeBuild" href="#moody.libeb.SolWeb3Tool.SplitForgeBuild">SplitForgeBuild</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.StoreTxResult" href="#moody.libeb.SolWeb3Tool.StoreTxResult">StoreTxResult</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.WORKSPACE_PATH" href="#moody.libeb.SolWeb3Tool.WORKSPACE_PATH">WORKSPACE_PATH</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.abi" href="#moody.libeb.SolWeb3Tool.abi">abi</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.bin" href="#moody.libeb.SolWeb3Tool.bin">bin</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.byClassName" href="#moody.libeb.SolWeb3Tool.byClassName">byClassName</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.file_name" href="#moody.libeb.SolWeb3Tool.file_name">file_name</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.prefixname" href="#moody.libeb.SolWeb3Tool.prefixname">prefixname</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.setBasePath" href="#moody.libeb.SolWeb3Tool.setBasePath">setBasePath</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.setBuildNameSpace" href="#moody.libeb.SolWeb3Tool.setBuildNameSpace">setBuildNameSpace</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.solfolder" href="#moody.libeb.SolWeb3Tool.solfolder">solfolder</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.statement" href="#moody.libeb.SolWeb3Tool.statement">statement</a></code></li>
<li><code><a title="moody.libeb.SolWeb3Tool.workspace" href="#moody.libeb.SolWeb3Tool.workspace">workspace</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>